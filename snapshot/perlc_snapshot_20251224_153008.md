# Perl Compiler Snapshot - Wed, Dec 24, 2025  3:30:08 PM

## Project Structure
```
./cmd/perlc/main.go
./cmd/xs2go/main.go
./pkg/ast/decl.go
./pkg/ast/expr.go
./pkg/ast/node.go
./pkg/ast/stmt.go
./pkg/av/av.go
./pkg/av/av_test.go
./pkg/c2go/translator.go
./pkg/cache/cache.go
./pkg/codegen/codegen.go
./pkg/compiler/compiler.go
./pkg/context/context.go
./pkg/context/context_test.go
./pkg/context/interp.go
./pkg/cv/cv.go
./pkg/cv/cv_test.go
./pkg/deps/detector.go
./pkg/eval/builtins.go
./pkg/eval/builtins_additions.go
./pkg/eval/eval.go
./pkg/eval/eval_test.go
./pkg/gv/gv.go
./pkg/gv/gv_test.go
./pkg/hv/hv.go
./pkg/hv/hv_test.go
./pkg/lexer/lexer.go
./pkg/lexer/lexer_test.go
./pkg/lexer/token.go
./pkg/parser/parser.go
./pkg/parser/parser_additional.go
./pkg/parser/parser_test.go
./pkg/stash/stash.go
./pkg/stash/stash_test.go
./pkg/sv/ops.go
./pkg/sv/ops_test.go
./pkg/sv/sv.go
./pkg/sv/sv_test.go
./pkg/xs2go/translator.go
./shell/create_snapshot.sh
./test_pl/test_at.pl
./test_pl/test_at2.pl
./test_pl/test_at3.pl
./test_pl/test_at4.pl
./test_pl/test_at5.pl
./test_pl/test_cap.pl
./test_pl/test_cap2.pl
./test_pl/test_cap3.pl
./test_pl/test_debug.pl
./test_pl/test_deref.pl
./test_pl/test_deref2.pl
./test_pl/test_dot.pl
./test_pl/test_email.pl
./test_pl/test_lex.pl
./test_pl/test_modifier.pl
./test_pl/test_ref.pl
./test_pl/test_refs.pl
./test_pl/test_regex_esc.pl
./test_pl/test_sort.pl
./test_pl/test_tokens.pl
./test_pl/test_var1.pl
./test_xs/test_xs_compiled.go
./tests/fileio_test.go
./tests/integration_test.go
./tests/quick/01_control.pl
./tests/quick/02_arrays.pl
./tests/quick/03_hashes.pl
./tests/quick/04_fileio.pl
./tests/quick/05_regex.pl
./tests/quick/06_subs.pl
./tests/quick/07_refs.pl
./tests/quick/08_expressions.pl
./tests/quick/09_push.pl
./tests/quick/10_oop.pl
./tests/quick/11_advanced.pl
./tests/quick/12_mixed.pl
./tests/quick_test.sh
./tests/run_tests.sh
./tmp/json_xs_output.go
```

## File: ./cmd/perlc/main.go
```go
package main

import (
	"flag"
	"fmt"
	"io"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"perlc/pkg/codegen"
	"perlc/pkg/eval"
	"perlc/pkg/lexer"
	"perlc/pkg/parser"
)

func main() {
	compile := flag.Bool("c", false, "Compile to Go code")
	output := flag.String("o", "", "Output file name")
	run := flag.Bool("r", false, "Compile and run")
	flag.Parse()

	if flag.NArg() < 1 {
		repl()
		return
	}

	filename := flag.Arg(0)
	data, err := os.ReadFile(filename)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading file: %v\n", err)
		os.Exit(1)
	}

	input := string(data)

	if *compile || *run {
		compileToGo(input, filename, *output, *run)
	} else {
		interpret(input)
	}
}

func interpret(input string) {
	l := lexer.New(input)
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		for _, e := range p.Errors() {
			fmt.Fprintf(os.Stderr, "Parse error: %s\n", e)
		}
		os.Exit(1)
	}

	interp := eval.New()
	interp.Eval(program)
}

func compileToGo(input, filename, outputName string, runAfter bool) {
	l := lexer.New(input)
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		for _, e := range p.Errors() {
			fmt.Fprintf(os.Stderr, "Parse error: %s\n", e)
		}
		os.Exit(1)
	}

	gen := codegen.New()
	goCode := gen.Generate(program)

	fmt.Println("=== Generated Go Code ===")
	fmt.Println(goCode)
	fmt.Println("=== End Generated Code ===")

	// Determine output filename
	if outputName == "" {
		base := strings.TrimSuffix(filepath.Base(filename), filepath.Ext(filename))
		outputName = base
	}

	// Create temp directory for compilation
	tmpDir, err := os.MkdirTemp("", "perlc-*")
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating temp dir: %v\n", err)
		os.Exit(1)
	}
	defer os.RemoveAll(tmpDir)

	goFile := filepath.Join(tmpDir, "main.go")

	// Write Go file
	err = os.WriteFile(goFile, []byte(goCode), 0644)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error writing Go file: %v\n", err)
		os.Exit(1)
	}

	// Compile with go build
	exeName := outputName
	if os.PathSeparator == '\\' {
		exeName += ".exe"
	}

	// Get absolute path for output
	absExe, _ := filepath.Abs(exeName)

	cmd := exec.Command("go", "build", "-o", absExe, goFile)
	cmd.Stdout = os.Stdout
	cmd.Stderr = os.Stderr
	err = cmd.Run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error compiling: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Compiled: %s\n", exeName)

	// Run if requested
	if runAfter {
		fmt.Println("---")
		cmd = exec.Command(absExe)
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		cmd.Run()
	}
}
func repl() {
	fmt.Println("perlc REPL (type 'exit' to quit)")
	interp := eval.New()

	for {
		fmt.Print("perl> ")
		var input string
		_, err := fmt.Scanln(&input)
		if err != nil {
			if err == io.EOF {
				break
			}
			continue
		}

		if input == "exit" || input == "quit" {
			break
		}

		l := lexer.New(input)
		p := parser.New(l)
		program := p.ParseProgram()

		if len(p.Errors()) > 0 {
			for _, e := range p.Errors() {
				fmt.Printf("Error: %s\n", e)
			}
			continue
		}

		interp.Eval(program)
	}
}

func Run(input string) {
	l := lexer.New(input)
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		for _, e := range p.Errors() {
			fmt.Fprintf(os.Stderr, "Parse error: %s\n", e)
		}
		os.Exit(1)
	}

	interp := eval.New()
	interp.Eval(program)
}
```

## File: ./cmd/xs2go/main.go
```go
// cmd/xs2go/main.go
package main

import (
	"fmt"
	"os"
	"perlc/pkg/xs2go"
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: xs2go <file.xs>")
		os.Exit(1)
	}

	translator := xs2go.New()

	code, err := translator.Translate(os.Args[1])
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error: %v\n", err)
		os.Exit(1)
	}

	fmt.Println(code)
}
```

## File: ./pkg/ast/decl.go
```go
package ast

import (
	"fmt"
	"strings"

	"perlc/pkg/lexer"
)

// ============================================================
// Variable Declarations
// Değişken Bildirimleri
// ============================================================

// VarDecl represents my/our/local/state declaration.
// VarDecl, my/our/local/state bildirimini temsil eder.
type VarDecl struct {
	Token  lexer.Token
	Kind   string       // "my", "our", "local", "state"
	Names  []Expression // Variables being declared
	Value  Expression   // Optional initializer
	IsList bool         // true if declared with parentheses: my ($x) vs my $x
}

func (vd *VarDecl) statementNode()       {}
func (vd *VarDecl) declarationNode()     {}
func (vd *VarDecl) TokenLiteral() string { return vd.Token.Value }
func (vd *VarDecl) String() string {
	names := make([]string, len(vd.Names))
	for i, n := range vd.Names {
		names[i] = n.String()
	}

	var out string
	if len(names) == 1 {
		out = fmt.Sprintf("%s %s", vd.Kind, names[0])
	} else {
		out = fmt.Sprintf("%s (%s)", vd.Kind, strings.Join(names, ", "))
	}

	if vd.Value != nil {
		out += " = " + vd.Value.String()
	}
	return out + ";"
}

// ============================================================
// Subroutine Declaration
// Altyordam Bildirimi
// ============================================================

// SubDecl represents sub name { }.
// SubDecl, sub name { }'ı temsil eder.
type SubDecl struct {
	Token      lexer.Token
	Name       string
	Prototype  string // Optional prototype
	Attributes []string
	Params     []*Param // With signatures
	Body       *BlockStmt
}

func (sd *SubDecl) statementNode()       {}
func (sd *SubDecl) declarationNode()     {}
func (sd *SubDecl) TokenLiteral() string { return sd.Token.Value }
func (sd *SubDecl) String() string {
	var out strings.Builder
	out.WriteString("sub ")
	out.WriteString(sd.Name)
	if sd.Prototype != "" {
		out.WriteString(fmt.Sprintf("(%s)", sd.Prototype))
	}
	for _, attr := range sd.Attributes {
		out.WriteString(" :" + attr)
	}
	out.WriteString(" ")
	out.WriteString(sd.Body.String())
	return out.String()
}

// ============================================================
// Package Declaration
// Paket Bildirimi
// ============================================================

// PackageDecl represents package Name;
// PackageDecl, package Name;'i temsil eder.
type PackageDecl struct {
	Token   lexer.Token
	Name    string
	Version string     // Optional version
	Block   *BlockStmt // Optional block form: package Foo { }
}

func (pd *PackageDecl) statementNode()       {}
func (pd *PackageDecl) declarationNode()     {}
func (pd *PackageDecl) TokenLiteral() string { return pd.Token.Value }
func (pd *PackageDecl) String() string {
	out := "package " + pd.Name
	if pd.Version != "" {
		out += " " + pd.Version
	}
	if pd.Block != nil {
		out += " " + pd.Block.String()
	} else {
		out += ";"
	}
	return out
}

// ============================================================
// Use/No/Require Declarations
// Use/No/Require Bildirimleri
// ============================================================

// UseDecl represents use Module [VERSION] [LIST];
// UseDecl, use Module [VERSION] [LIST];'ı temsil eder.
type UseDecl struct {
	Token   lexer.Token
	Module  string
	Version string
	Args    []Expression // Import list
}

func (ud *UseDecl) statementNode()       {}
func (ud *UseDecl) declarationNode()     {}
func (ud *UseDecl) TokenLiteral() string { return ud.Token.Value }
func (ud *UseDecl) String() string {
	out := "use " + ud.Module
	if ud.Version != "" {
		out += " " + ud.Version
	}
	if len(ud.Args) > 0 {
		args := make([]string, len(ud.Args))
		for i, a := range ud.Args {
			args[i] = a.String()
		}
		out += " " + strings.Join(args, ", ")
	}
	return out + ";"
}

// NoDecl represents no Module;
// NoDecl, no Module;'u temsil eder.
type NoDecl struct {
	Token  lexer.Token
	Module string
	Args   []Expression
}

func (nd *NoDecl) statementNode()       {}
func (nd *NoDecl) declarationNode()     {}
func (nd *NoDecl) TokenLiteral() string { return nd.Token.Value }
func (nd *NoDecl) String() string {
	out := "no " + nd.Module
	if len(nd.Args) > 0 {
		args := make([]string, len(nd.Args))
		for i, a := range nd.Args {
			args[i] = a.String()
		}
		out += " " + strings.Join(args, ", ")
	}
	return out + ";"
}

// RequireDecl represents require Module or require "file".
// RequireDecl, require Module veya require "file"'ı temsil eder.
type RequireDecl struct {
	Token  lexer.Token
	Module string     // Module name
	Expr   Expression // Or expression (require $var)
}

func (rd *RequireDecl) statementNode()       {}
func (rd *RequireDecl) declarationNode()     {}
func (rd *RequireDecl) TokenLiteral() string { return rd.Token.Value }
func (rd *RequireDecl) String() string {
	if rd.Module != "" {
		return "require " + rd.Module + ";"
	}
	return "require " + rd.Expr.String() + ";"
}

// ============================================================
// Special Blocks
// Özel Bloklar
// ============================================================

// SpecialBlock represents BEGIN/END/CHECK/INIT/UNITCHECK blocks.
// SpecialBlock, BEGIN/END/CHECK/INIT/UNITCHECK bloklarını temsil eder.
type SpecialBlock struct {
	Token lexer.Token
	Kind  string // "BEGIN", "END", "CHECK", "INIT", "UNITCHECK"
	Body  *BlockStmt
}

func (sb *SpecialBlock) statementNode()       {}
func (sb *SpecialBlock) declarationNode()     {}
func (sb *SpecialBlock) TokenLiteral() string { return sb.Token.Value }
func (sb *SpecialBlock) String() string {
	return sb.Kind + " " + sb.Body.String()
}
```

## File: ./pkg/ast/expr.go
```go
package ast

import (
	"fmt"
	"strings"

	"perlc/pkg/lexer"
)

// ============================================================
// Literal Expressions
// Literal İfadeler
// ============================================================

// IntegerLiteral represents an integer literal.
// IntegerLiteral, bir tamsayı literalini temsil eder.
type IntegerLiteral struct {
	Token lexer.Token
	Value int64
}

func (il *IntegerLiteral) expressionNode()      {}
func (il *IntegerLiteral) TokenLiteral() string { return il.Token.Value }
func (il *IntegerLiteral) String() string       { return il.Token.Value }

// FloatLiteral represents a floating-point literal.
// FloatLiteral, bir kayan nokta literalini temsil eder.
type FloatLiteral struct {
	Token lexer.Token
	Value float64
}

func (fl *FloatLiteral) expressionNode()      {}
func (fl *FloatLiteral) TokenLiteral() string { return fl.Token.Value }
func (fl *FloatLiteral) String() string       { return fl.Token.Value }

// StringLiteral represents a string literal.
// StringLiteral, bir string literalini temsil eder.
type StringLiteral struct {
	Token        lexer.Token
	Value        string
	Interpolated bool // true for "", false for ''
}

func (sl *StringLiteral) expressionNode()      {}
func (sl *StringLiteral) TokenLiteral() string { return sl.Token.Value }
func (sl *StringLiteral) String() string {
	if sl.Interpolated {
		return fmt.Sprintf(`"%s"`, sl.Value)
	}
	return fmt.Sprintf(`'%s'`, sl.Value)
}

// RegexLiteral represents a regex literal /pattern/flags.
// RegexLiteral, bir regex literalini temsil eder /pattern/flags.
type RegexLiteral struct {
	Token   lexer.Token
	Pattern string
	Flags   string
}

func (rl *RegexLiteral) expressionNode()      {}
func (rl *RegexLiteral) TokenLiteral() string { return rl.Token.Value }
func (rl *RegexLiteral) String() string       { return fmt.Sprintf("/%s/%s", rl.Pattern, rl.Flags) }

// UndefLiteral represents undef.
// UndefLiteral, undef'i temsil eder.
type UndefLiteral struct {
	Token lexer.Token
}

func (ul *UndefLiteral) expressionNode()      {}
func (ul *UndefLiteral) TokenLiteral() string { return "undef" }
func (ul *UndefLiteral) String() string       { return "undef" }

// ============================================================
// Variable Expressions
// Değişken İfadeleri
// ============================================================

// ScalarVar represents $var.
// ScalarVar, $var'ı temsil eder.
type ScalarVar struct {
	Token lexer.Token
	Name  string // Without sigil / Sigil olmadan
}

func (sv *ScalarVar) expressionNode()      {}
func (sv *ScalarVar) TokenLiteral() string { return sv.Token.Value }
func (sv *ScalarVar) String() string       { return "$" + sv.Name }

// ArrayVar represents @arr.
// ArrayVar, @arr'ı temsil eder.
type ArrayVar struct {
	Token lexer.Token
	Name  string
}

func (av *ArrayVar) expressionNode()      {}
func (av *ArrayVar) TokenLiteral() string { return av.Token.Value }
func (av *ArrayVar) String() string       { return "@" + av.Name }

// HashVar represents %hash.
// HashVar, %hash'i temsil eder.
type HashVar struct {
	Token lexer.Token
	Name  string
}

func (hv *HashVar) expressionNode()      {}
func (hv *HashVar) TokenLiteral() string { return hv.Token.Value }
func (hv *HashVar) String() string       { return "%" + hv.Name }

// CodeVar represents &sub.
// CodeVar, &sub'ı temsil eder.
type CodeVar struct {
	Token lexer.Token
	Name  string
}

func (cv *CodeVar) expressionNode()      {}
func (cv *CodeVar) TokenLiteral() string { return cv.Token.Value }
func (cv *CodeVar) String() string       { return "&" + cv.Name }

// GlobVar represents *glob.
// GlobVar, *glob'u temsil eder.
type GlobVar struct {
	Token lexer.Token
	Name  string
}

func (gv *GlobVar) expressionNode()      {}
func (gv *GlobVar) TokenLiteral() string { return gv.Token.Value }
func (gv *GlobVar) String() string       { return "*" + gv.Name }

// ArrayLengthVar represents $#arr.
// ArrayLengthVar, $#arr'ı temsil eder.
type ArrayLengthVar struct {
	Token lexer.Token
	Name  string
}

func (al *ArrayLengthVar) expressionNode()      {}
func (al *ArrayLengthVar) TokenLiteral() string { return al.Token.Value }
func (al *ArrayLengthVar) String() string       { return "$#" + al.Name }

// SpecialVar represents special variables like $_, $@, etc.
// SpecialVar, $_, $@ gibi özel değişkenleri temsil eder.
type SpecialVar struct {
	Token lexer.Token
	Name  string // Full name including sigil / Sigil dahil tam isim
}

func (sv *SpecialVar) expressionNode()      {}
func (sv *SpecialVar) TokenLiteral() string { return sv.Token.Value }
func (sv *SpecialVar) String() string       { return sv.Name }

// ============================================================
// Operator Expressions
// Operatör İfadeleri
// ============================================================

// PrefixExpr represents prefix operators like !$x, -$x, ++$x.
// PrefixExpr, !$x, -$x, ++$x gibi önek operatörlerini temsil eder.
type PrefixExpr struct {
	Token    lexer.Token
	Operator string
	Right    Expression
}

func (pe *PrefixExpr) expressionNode()      {}
func (pe *PrefixExpr) TokenLiteral() string { return pe.Token.Value }
func (pe *PrefixExpr) String() string {
	return fmt.Sprintf("(%s%s)", pe.Operator, pe.Right.String())
}

// PostfixExpr represents postfix operators like $x++, $x--.
// PostfixExpr, $x++, $x-- gibi sonek operatörlerini temsil eder.
type PostfixExpr struct {
	Token    lexer.Token
	Left     Expression
	Operator string
}

func (pe *PostfixExpr) expressionNode()      {}
func (pe *PostfixExpr) TokenLiteral() string { return pe.Token.Value }
func (pe *PostfixExpr) String() string {
	return fmt.Sprintf("(%s%s)", pe.Left.String(), pe.Operator)
}

// InfixExpr represents binary operators like $x + $y.
// InfixExpr, $x + $y gibi ikili operatörleri temsil eder.
type InfixExpr struct {
	Token    lexer.Token
	Left     Expression
	Operator string
	Right    Expression
}

func (ie *InfixExpr) expressionNode()      {}
func (ie *InfixExpr) TokenLiteral() string { return ie.Token.Value }
func (ie *InfixExpr) String() string {
	return fmt.Sprintf("(%s %s %s)", ie.Left.String(), ie.Operator, ie.Right.String())
}

// TernaryExpr represents $cond ? $then : $else.
// TernaryExpr, $cond ? $then : $else'i temsil eder.
type TernaryExpr struct {
	Token     lexer.Token
	Condition Expression
	Then      Expression
	Else      Expression
}

func (te *TernaryExpr) expressionNode()      {}
func (te *TernaryExpr) TokenLiteral() string { return te.Token.Value }
func (te *TernaryExpr) String() string {
	return fmt.Sprintf("(%s ? %s : %s)",
		te.Condition.String(), te.Then.String(), te.Else.String())
}

// AssignExpr represents assignment $x = $y.
// AssignExpr, $x = $y atamasını temsil eder.
type AssignExpr struct {
	Token    lexer.Token
	Left     Expression
	Operator string // =, +=, -=, etc.
	Right    Expression
}

func (ae *AssignExpr) expressionNode()      {}
func (ae *AssignExpr) TokenLiteral() string { return ae.Token.Value }
func (ae *AssignExpr) String() string {
	return fmt.Sprintf("(%s %s %s)", ae.Left.String(), ae.Operator, ae.Right.String())
}

// ============================================================
// Access Expressions
// Erişim İfadeleri
// ============================================================

// ArrayAccess represents $arr[index].
// ArrayAccess, $arr[index]'i temsil eder.
type ArrayAccess struct {
	Token lexer.Token
	Array Expression
	Index Expression
}

func (aa *ArrayAccess) expressionNode()      {}
func (aa *ArrayAccess) TokenLiteral() string { return aa.Token.Value }
func (aa *ArrayAccess) String() string {
	return fmt.Sprintf("%s[%s]", aa.Array.String(), aa.Index.String())
}

// HashAccess represents $hash{key}.
// HashAccess, $hash{key}'i temsil eder.
type HashAccess struct {
	Token lexer.Token
	Hash  Expression
	Key   Expression
}

func (ha *HashAccess) expressionNode()      {}
func (ha *HashAccess) TokenLiteral() string { return ha.Token.Value }
func (ha *HashAccess) String() string {
	return fmt.Sprintf("%s{%s}", ha.Hash.String(), ha.Key.String())
}

// ArrowAccess represents $ref->[index] or $ref->{key} or $obj->method.
// ArrowAccess, $ref->[index], $ref->{key} veya $obj->method'u temsil eder.
type ArrowAccess struct {
	Token lexer.Token
	Left  Expression
	Right Expression // ArrayAccess, HashAccess, or CallExpr
}

func (aa *ArrowAccess) expressionNode()      {}
func (aa *ArrowAccess) TokenLiteral() string { return aa.Token.Value }
func (aa *ArrowAccess) String() string {
	return fmt.Sprintf("%s->%s", aa.Left.String(), aa.Right.String())
}

// ============================================================
// Call Expressions
// Çağrı İfadeleri
// ============================================================

// CallExpr represents function/method call.
// CallExpr, fonksiyon/method çağrısını temsil eder.
type CallExpr struct {
	Token    lexer.Token
	Function Expression // Identifier or expression
	Args     []Expression
}

func (ce *CallExpr) expressionNode()      {}
func (ce *CallExpr) TokenLiteral() string { return ce.Token.Value }
func (ce *CallExpr) String() string {
	args := make([]string, len(ce.Args))
	for i, a := range ce.Args {
		args[i] = a.String()
	}
	return fmt.Sprintf("%s(%s)", ce.Function.String(), strings.Join(args, ", "))
}

// MethodCall represents $obj->method(args).
// MethodCall, $obj->method(args)'ı temsil eder.
type MethodCall struct {
	Token  lexer.Token
	Object Expression
	Method string
	Args   []Expression
}

func (mc *MethodCall) expressionNode()      {}
func (mc *MethodCall) TokenLiteral() string { return mc.Token.Value }
func (mc *MethodCall) String() string {
	args := make([]string, len(mc.Args))
	for i, a := range mc.Args {
		args[i] = a.String()
	}
	return fmt.Sprintf("%s->%s(%s)", mc.Object.String(), mc.Method, strings.Join(args, ", "))
}

// ============================================================
// Composite Expressions
// Bileşik İfadeler
// ============================================================

// ArrayExpr represents [...] array literal.
// ArrayExpr, [...] dizi literalini temsil eder.
type ArrayExpr struct {
	Token    lexer.Token
	Elements []Expression
}

func (ae *ArrayExpr) expressionNode()      {}
func (ae *ArrayExpr) TokenLiteral() string { return ae.Token.Value }
func (ae *ArrayExpr) String() string {
	elements := make([]string, len(ae.Elements))
	for i, e := range ae.Elements {
		elements[i] = e.String()
	}
	return "[" + strings.Join(elements, ", ") + "]"
}

// HashExpr represents {...} hash literal.
// HashExpr, {...} hash literalini temsil eder.
type HashExpr struct {
	Token lexer.Token
	Pairs []*HashPair
}

type HashPair struct {
	Key   Expression
	Value Expression
}

func (he *HashExpr) expressionNode()      {}
func (he *HashExpr) TokenLiteral() string { return he.Token.Value }
func (he *HashExpr) String() string {
	pairs := make([]string, len(he.Pairs))
	for i, p := range he.Pairs {
		pairs[i] = fmt.Sprintf("%s => %s", p.Key.String(), p.Value.String())
	}
	return "{" + strings.Join(pairs, ", ") + "}"
}

// ReadLineExpr represents <FH> or <$fh>.
type ReadLineExpr struct {
	Token      lexer.Token
	Filehandle Expression // can be Identifier or ScalarVar
}

func (rl *ReadLineExpr) expressionNode()      {}
func (rl *ReadLineExpr) TokenLiteral() string { return rl.Token.Value }
func (rl *ReadLineExpr) String() string {
	if rl.Filehandle != nil {
		return "<" + rl.Filehandle.String() + ">"
	}
	return "<>"
}

// RangeExpr represents $a .. $b or $a ... $b.
// RangeExpr, $a .. $b veya $a ... $b'yi temsil eder.
type RangeExpr struct {
	Token    lexer.Token
	Start    Expression
	End      Expression
	ThreeDot bool // ... vs ..
}

func (re *RangeExpr) expressionNode()      {}
func (re *RangeExpr) TokenLiteral() string { return re.Token.Value }
func (re *RangeExpr) String() string {
	op := ".."
	if re.ThreeDot {
		op = "..."
	}
	return fmt.Sprintf("(%s %s %s)", re.Start.String(), op, re.End.String())
}

// ============================================================
// Reference Expressions
// Referans İfadeleri
// ============================================================

// RefExpr represents \$var (reference creation).
// RefExpr, \$var (referans oluşturma) temsil eder.
type RefExpr struct {
	Token lexer.Token
	Value Expression
}

func (re *RefExpr) expressionNode()      {}
func (re *RefExpr) TokenLiteral() string { return re.Token.Value }
func (re *RefExpr) String() string       { return "\\" + re.Value.String() }

// DerefExpr represents $$ref, @$ref, %$ref.
// DerefExpr, $$ref, @$ref, %$ref'i temsil eder.
type DerefExpr struct {
	Token lexer.Token
	Sigil string // $, @, %, &, *
	Value Expression
}

func (de *DerefExpr) expressionNode()      {}
func (de *DerefExpr) TokenLiteral() string { return de.Token.Value }
func (de *DerefExpr) String() string       { return de.Sigil + de.Value.String() }

// ============================================================
// Anonymous Sub Expression
// Anonim Sub İfadesi
// ============================================================

// AnonSubExpr represents sub { ... }.
// AnonSubExpr, sub { ... }'u temsil eder.
type AnonSubExpr struct {
	Token  lexer.Token
	Params []*Param
	Body   *BlockStmt
}

func (as *AnonSubExpr) expressionNode()      {}
func (as *AnonSubExpr) TokenLiteral() string { return as.Token.Value }
func (as *AnonSubExpr) String() string {
	return fmt.Sprintf("sub { %s }", as.Body.String())
}

// Param represents a subroutine parameter.
// Param, bir altyordam parametresini temsil eder.
type Param struct {
	Name    string
	Sigil   string // $, @, %
	Default Expression
}

// ============================================================
// Regex Expressions
// Regex İfadeleri
// ============================================================

// MatchExpr represents $str =~ /pattern/.
// MatchExpr, $str =~ /pattern/'ı temsil eder.
type MatchExpr struct {
	Token   lexer.Token
	Target  Expression
	Pattern *RegexLiteral
	Negate  bool // !~
}

func (me *MatchExpr) expressionNode()      {}
func (me *MatchExpr) TokenLiteral() string { return me.Token.Value }
func (me *MatchExpr) String() string {
	op := "=~"
	if me.Negate {
		op = "!~"
	}
	return fmt.Sprintf("(%s %s %s)", me.Target.String(), op, me.Pattern.String())
}

// SubstExpr represents $str =~ s/pattern/replacement/.
// SubstExpr, $str =~ s/pattern/replacement/'i temsil eder.
type SubstExpr struct {
	Token       lexer.Token
	Target      Expression
	Pattern     string
	Replacement string
	Flags       string
}

func (se *SubstExpr) expressionNode()      {}
func (se *SubstExpr) TokenLiteral() string { return se.Token.Value }
func (se *SubstExpr) String() string {
	return fmt.Sprintf("(%s =~ s/%s/%s/%s)",
		se.Target.String(), se.Pattern, se.Replacement, se.Flags)
}

// ============================================================
// Identifier
// Tanımlayıcı
// ============================================================

// Identifier represents a bare identifier (sub name, label, etc.).
// Identifier, bir çıplak tanımlayıcıyı temsil eder (sub adı, etiket, vb.).
type Identifier struct {
	Token lexer.Token
	Value string
}

func (i *Identifier) expressionNode()      {}
func (i *Identifier) TokenLiteral() string { return i.Token.Value }
func (i *Identifier) String() string       { return i.Value }
```

## File: ./pkg/ast/node.go
```go
// Package ast defines the Abstract Syntax Tree for Perl.
// Paket ast, Perl için Soyut Sözdizimi Ağacını tanımlar.
package ast

import "perlc/pkg/lexer"

// Node is the interface for all AST nodes.
// Node, tüm AST düğümleri için arayüzdür.
type Node interface {
	TokenLiteral() string
	String() string
}

// Statement is an AST node that represents a statement.
// Statement, bir ifadeyi temsil eden AST düğümüdür.
type Statement interface {
	Node
	statementNode()
}

// Expression is an AST node that represents an expression.
// Expression, bir ifadeyi temsil eden AST düğümüdür.
type Expression interface {
	Node
	expressionNode()
}

// Declaration is an AST node that represents a declaration.
// Declaration, bir bildirimi temsil eden AST düğümüdür.
type Declaration interface {
	Node
	declarationNode()
}

// Program is the root node of the AST.
// Program, AST'nin kök düğümüdür.
type Program struct {
	Statements []Statement
}

func (p *Program) TokenLiteral() string {
	if len(p.Statements) > 0 {
		return p.Statements[0].TokenLiteral()
	}
	return ""
}

func (p *Program) String() string {
	var out string
	for _, s := range p.Statements {
		out += s.String()
	}
	return out
}

// Position stores source location information.
// Position, kaynak konum bilgisini saklar.
type Position struct {
	File   string
	Line   int
	Column int
}

// FromToken creates Position from a Token.
// FromToken, Token'dan Position oluşturur.
func FromToken(tok lexer.Token) Position {
	return Position{
		File:   tok.File,
		Line:   tok.Line,
		Column: tok.Column,
	}
}
```

## File: ./pkg/ast/stmt.go
```go
package ast

import (
	"fmt"
	"strings"

	"perlc/pkg/lexer"
)

// ============================================================
// Block Statement
// Blok İfadesi
// ============================================================

// BlockStmt represents { statements }.
// BlockStmt, { statements }'ı temsil eder.
type BlockStmt struct {
	Token      lexer.Token
	Statements []Statement
}

func (bs *BlockStmt) statementNode()       {}
func (bs *BlockStmt) TokenLiteral() string { return bs.Token.Value }
func (bs *BlockStmt) String() string {
	var out strings.Builder
	out.WriteString("{ ")
	for _, s := range bs.Statements {
		out.WriteString(s.String())
	}
	out.WriteString(" }")
	return out.String()
}

// ============================================================
// Expression Statement
// İfade Deyimi
// ============================================================

// ExprStmt wraps an expression as a statement.
// ExprStmt, bir ifadeyi deyim olarak sarar.
type ExprStmt struct {
	Token      lexer.Token
	Expression Expression
}

func (es *ExprStmt) statementNode()       {}
func (es *ExprStmt) TokenLiteral() string { return es.Token.Value }
func (es *ExprStmt) String() string {
	if es.Expression != nil {
		return es.Expression.String() + ";"
	}
	return ""
}

// ============================================================
// Control Flow Statements
// Kontrol Akışı Deyimleri
// ============================================================

// IfStmt represents if/unless/elsif/else.
// IfStmt, if/unless/elsif/else'i temsil eder.
type IfStmt struct {
	Token     lexer.Token
	Unless    bool // true for 'unless'
	Condition Expression
	Then      *BlockStmt
	Elsif     []*ElsifClause
	Else      *BlockStmt
}

type ElsifClause struct {
	Condition Expression
	Body      *BlockStmt
}

func (is *IfStmt) statementNode()       {}
func (is *IfStmt) TokenLiteral() string { return is.Token.Value }
func (is *IfStmt) String() string {
	var out strings.Builder
	kw := "if"
	if is.Unless {
		kw = "unless"
	}
	out.WriteString(fmt.Sprintf("%s (%s) %s", kw, is.Condition.String(), is.Then.String()))
	for _, elsif := range is.Elsif {
		out.WriteString(fmt.Sprintf(" elsif (%s) %s", elsif.Condition.String(), elsif.Body.String()))
	}
	if is.Else != nil {
		out.WriteString(" else ")
		out.WriteString(is.Else.String())
	}
	return out.String()
}

// WhileStmt represents while/until loops.
// WhileStmt, while/until döngülerini temsil eder.
type WhileStmt struct {
	Token     lexer.Token
	Until     bool // true for 'until'
	Condition Expression
	Body      *BlockStmt
	Continue  *BlockStmt // continue block
}

func (ws *WhileStmt) statementNode()       {}
func (ws *WhileStmt) TokenLiteral() string { return ws.Token.Value }
func (ws *WhileStmt) String() string {
	kw := "while"
	if ws.Until {
		kw = "until"
	}
	out := fmt.Sprintf("%s (%s) %s", kw, ws.Condition.String(), ws.Body.String())
	if ws.Continue != nil {
		out += " continue " + ws.Continue.String()
	}
	return out
}

// ForStmt represents C-style for loop.
// ForStmt, C-tarzı for döngüsünü temsil eder.
type ForStmt struct {
	Token     lexer.Token
	Init      Statement
	Condition Expression
	Post      Expression
	Body      *BlockStmt
}

func (fs *ForStmt) statementNode()       {}
func (fs *ForStmt) TokenLiteral() string { return fs.Token.Value }
func (fs *ForStmt) String() string {
	init := ""
	if fs.Init != nil {
		init = fs.Init.String()
	}
	cond := ""
	if fs.Condition != nil {
		cond = fs.Condition.String()
	}
	post := ""
	if fs.Post != nil {
		post = fs.Post.String()
	}
	return fmt.Sprintf("for (%s; %s; %s) %s", init, cond, post, fs.Body.String())
}

// ForeachStmt represents foreach loop.
// ForeachStmt, foreach döngüsünü temsil eder.
type ForeachStmt struct {
	Token    lexer.Token
	Variable Expression // $item
	List     Expression // @array or (list)
	Body     *BlockStmt
	Continue *BlockStmt
}

func (fs *ForeachStmt) statementNode()       {}
func (fs *ForeachStmt) TokenLiteral() string { return fs.Token.Value }
func (fs *ForeachStmt) String() string {
	out := fmt.Sprintf("foreach %s (%s) %s",
		fs.Variable.String(), fs.List.String(), fs.Body.String())
	if fs.Continue != nil {
		out += " continue " + fs.Continue.String()
	}
	return out
}

// ============================================================
// Loop Control Statements
// Döngü Kontrol Deyimleri
// ============================================================

// LastStmt represents 'last' (break).
// LastStmt, 'last' (break)'i temsil eder.
type LastStmt struct {
	Token lexer.Token
	Label string // Optional label
}

func (ls *LastStmt) statementNode()       {}
func (ls *LastStmt) TokenLiteral() string { return ls.Token.Value }
func (ls *LastStmt) String() string {
	if ls.Label != "" {
		return "last " + ls.Label
	}
	return "last"
}

// NextStmt represents 'next' (continue).
// NextStmt, 'next' (continue)'i temsil eder.
type NextStmt struct {
	Token lexer.Token
	Label string
}

func (ns *NextStmt) statementNode()       {}
func (ns *NextStmt) TokenLiteral() string { return ns.Token.Value }
func (ns *NextStmt) String() string {
	if ns.Label != "" {
		return "next " + ns.Label
	}
	return "next"
}

// RedoStmt represents 'redo'.
// RedoStmt, 'redo'yu temsil eder.
type RedoStmt struct {
	Token lexer.Token
	Label string
}

func (rs *RedoStmt) statementNode()       {}
func (rs *RedoStmt) TokenLiteral() string { return rs.Token.Value }
func (rs *RedoStmt) String() string {
	if rs.Label != "" {
		return "redo " + rs.Label
	}
	return "redo"
}

// ReturnStmt represents 'return'.
// ReturnStmt, 'return'ü temsil eder.
type ReturnStmt struct {
	Token lexer.Token
	Value Expression
}

func (rs *ReturnStmt) statementNode()       {}
func (rs *ReturnStmt) TokenLiteral() string { return rs.Token.Value }
func (rs *ReturnStmt) String() string {
	if rs.Value != nil {
		return "return " + rs.Value.String()
	}
	return "return"
}

// ============================================================
// Modifier Statements (postfix if/unless/while/until/for)
// Değiştirici Deyimler (sonek if/unless/while/until/for)
// ============================================================

// ModifierStmt represents statement if/unless/while/until condition.
// ModifierStmt, statement if/unless/while/until condition'ı temsil eder.
type ModifierStmt struct {
	Token     lexer.Token
	Statement Statement
	Modifier  string // "if", "unless", "while", "until", "for", "foreach"
	Condition Expression
}

func (ms *ModifierStmt) statementNode()       {}
func (ms *ModifierStmt) TokenLiteral() string { return ms.Token.Value }
func (ms *ModifierStmt) String() string {
	return fmt.Sprintf("%s %s %s",
		ms.Statement.String(), ms.Modifier, ms.Condition.String())
}

// ============================================================
// Do/Eval Statements
// Do/Eval Deyimleri
// ============================================================

// DoStmt represents do { } while/until or do EXPR.
// DoStmt, do { } while/until veya do EXPR'i temsil eder.
type DoStmt struct {
	Token     lexer.Token
	Body      *BlockStmt
	Condition Expression // for do-while
	Until     bool       // true for do-until
}

func (ds *DoStmt) statementNode()       {}
func (ds *DoStmt) TokenLiteral() string { return ds.Token.Value }
func (ds *DoStmt) String() string {
	if ds.Condition != nil {
		kw := "while"
		if ds.Until {
			kw = "until"
		}
		return fmt.Sprintf("do %s %s (%s)", ds.Body.String(), kw, ds.Condition.String())
	}
	return "do " + ds.Body.String()
}

// EvalStmt represents eval { } or eval EXPR.
// EvalStmt, eval { } veya eval EXPR'i temsil eder.
type EvalStmt struct {
	Token lexer.Token
	Body  *BlockStmt // eval { }
	Expr  Expression // eval EXPR
}

func (es *EvalStmt) statementNode()       {}
func (es *EvalStmt) TokenLiteral() string { return es.Token.Value }
func (es *EvalStmt) String() string {
	if es.Body != nil {
		return "eval " + es.Body.String()
	}
	return "eval " + es.Expr.String()
}

// ============================================================
// Label Statement
// Etiket Deyimi
// ============================================================

// LabelStmt represents LABEL: statement.
// LabelStmt, LABEL: statement'ı temsil eder.
type LabelStmt struct {
	Token     lexer.Token
	Label     string
	Statement Statement
}

func (ls *LabelStmt) statementNode()       {}
func (ls *LabelStmt) TokenLiteral() string { return ls.Token.Value }
func (ls *LabelStmt) String() string {
	return ls.Label + ": " + ls.Statement.String()
}

// ============================================================
// Given/When (switch)
// Given/When (switch)
// ============================================================

// GivenStmt represents given/when/default.
// GivenStmt, given/when/default'u temsil eder.
type GivenStmt struct {
	Token   lexer.Token
	Topic   Expression
	Clauses []*WhenClause
	Default *BlockStmt
}

type WhenClause struct {
	Condition Expression
	Body      *BlockStmt
}

func (gs *GivenStmt) statementNode()       {}
func (gs *GivenStmt) TokenLiteral() string { return gs.Token.Value }
func (gs *GivenStmt) String() string {
	var out strings.Builder
	out.WriteString(fmt.Sprintf("given (%s) { ", gs.Topic.String()))
	for _, w := range gs.Clauses {
		out.WriteString(fmt.Sprintf("when (%s) %s ", w.Condition.String(), w.Body.String()))
	}
	if gs.Default != nil {
		out.WriteString("default ")
		out.WriteString(gs.Default.String())
	}
	out.WriteString("}")
	return out.String()
}

// OpenStmt represents open(FH, MODE, FILE).
type OpenStmt struct {
	Token      lexer.Token
	Filehandle Expression
	Mode       Expression
	Filename   Expression
}

func (os *OpenStmt) statementNode()       {}
func (os *OpenStmt) TokenLiteral() string { return os.Token.Value }
func (os *OpenStmt) String() string {
	return fmt.Sprintf("open(%s, %s, %s)", os.Filehandle.String(), os.Mode.String(), os.Filename.String())
}

// CloseStmt represents close(FH).
type CloseStmt struct {
	Token      lexer.Token
	Filehandle Expression
}

func (cs *CloseStmt) statementNode()       {}
func (cs *CloseStmt) TokenLiteral() string { return cs.Token.Value }
func (cs *CloseStmt) String() string {
	return fmt.Sprintf("close(%s)", cs.Filehandle.String())
}

// ============================================================
// End of File
// Dosya Sonu
// ============================================================
```

## File: ./pkg/av/av.go
```go
// Package av implements Perl's array operations.
// Paket av, Perl'in dizi işlemlerini uygular.
//
// Arrays in Perl are heterogeneous - can hold any mix of types.
// Perl'deki diziler heterojendir - herhangi bir tür karışımı içerebilir.
package av

import (
	"sort"

	"perlc/pkg/sv"
)

// ============================================================
// Array Access Operations
// Dizi Erişim İşlemleri
// ============================================================

// Fetch gets element at index (handles negative indices like Perl).
// Fetch, indeksteki öğeyi alır (Perl gibi negatif indeksleri destekler).
func Fetch(arr *sv.SV, idx *sv.SV) *sv.SV {
	if arr == nil {
		return sv.NewUndef()
	}

	// Dereference if it's a reference
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewUndef()
	}

	elements := target.ArrayData()
	if elements == nil {
		return sv.NewUndef()
	}

	i := int(idx.AsInt())
	length := len(elements)

	// Handle negative index
	if i < 0 {
		i = length + i
	}

	if i < 0 || i >= length {
		return sv.NewUndef()
	}

	if elements[i] == nil {
		return sv.NewUndef()
	}
	return elements[i]
}

// Store sets element at index (auto-extends array)
// Store, indeksteki öğeyi ayarlar (gerekirse diziyi otomatik genişletir).
func Store(arr *sv.SV, idx *sv.SV, val *sv.SV) {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		panic("Not an array / Dizi değil")
	}

	i := int(idx.AsInt())
	elements := target.ArrayData()
	length := len(elements)

	// Handle negative index
	// Negatif indeks işle
	if i < 0 {
		i = length + i
	}
	if i < 0 {
		panic("Modification of non-creatable array value attempted / Oluşturulamaz dizi değeri değiştirilmeye çalışıldı")
	}

	// Auto-extend if needed
	// Gerekirse otomatik genişlet
	if i >= length {
		newElements := make([]*sv.SV, i+1)
		copy(newElements, elements)
		// Fill gaps with undef
		// Boşlukları undef ile doldur
		for j := length; j < i; j++ {
			newElements[j] = sv.NewUndef()
		}
		elements = newElements
		target.SetArrayData(elements)
	}

	// Handle refcounts
	// Referans sayılarını yönet
	if elements[i] != nil {
		elements[i].DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	elements[i] = val
}

// Len returns scalar(@arr) - the length.
// Len, scalar(@arr) döndürür - uzunluk.
func Len(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewInt(0)
	}
	return sv.NewInt(int64(len(target.ArrayData())))
}

// MaxIndex returns $#arr - the last index.
// MaxIndex, $#arr döndürür - son indeks.
func MaxIndex(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewInt(-1)
	}
	return sv.NewInt(int64(len(target.ArrayData()) - 1))
}

// Exists checks if index exists (even if value is undef).
// Exists, indeksin var olup olmadığını kontrol eder (değer undef olsa bile).
func Exists(arr *sv.SV, idx *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewString("")
	}

	elements := target.ArrayData()
	i := int(idx.AsInt())

	if i < 0 {
		i = len(elements) + i
	}

	if i >= 0 && i < len(elements) {
		return sv.NewInt(1)
	}
	return sv.NewString("")
}

// Delete removes element at index, returns the removed value.
// Delete, indeksteki öğeyi kaldırır, kaldırılan değeri döndürür.
func Delete(arr *sv.SV, idx *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewUndef()
	}

	elements := target.ArrayData()
	i := int(idx.AsInt())

	if i < 0 {
		i = len(elements) + i
	}

	if i < 0 || i >= len(elements) {
		return sv.NewUndef()
	}

	val := elements[i]
	elements[i] = sv.NewUndef()

	// Shrink array if we deleted from the end
	// Sondan sildiyse diziyi küçült
	for len(elements) > 0 && elements[len(elements)-1].IsUndef() {
		elements = elements[:len(elements)-1]
	}
	target.SetArrayData(elements)

	return val
}

// Push appends elements to end, returns new length.
// Push, öğeleri sona ekler, yeni uzunluğu döndürür.
func Push(arr *sv.SV, values ...*sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		panic("Not an array / Dizi değil")
	}

	elements := target.ArrayData()
	for _, v := range values {
		if v != nil {
			v.IncRef()
		}
		elements = append(elements, v)
	}
	target.SetArrayData(elements)

	return sv.NewInt(int64(len(elements)))
}

// Pop removes and returns last element.
// Pop, son öğeyi kaldırır ve döndürür.
func Pop(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewUndef()
	}

	elements := target.ArrayData()
	if len(elements) == 0 {
		return sv.NewUndef()
	}

	last := elements[len(elements)-1]
	target.SetArrayData(elements[:len(elements)-1])

	// Don't decref - we're returning it
	// Decref yapma - döndürüyoruz
	return last
}

// Shift removes and returns first element.
// Shift, ilk öğeyi kaldırır ve döndürür.
func Shift(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewUndef()
	}

	elements := target.ArrayData()
	if len(elements) == 0 {
		return sv.NewUndef()
	}

	first := elements[0]
	target.SetArrayData(elements[1:])

	return first
}

// Unshift prepends elements, returns new length.
// Unshift, öğeleri başa ekler, yeni uzunluğu döndürür.
func Unshift(arr *sv.SV, values ...*sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		panic("Not an array / Dizi değil")
	}

	elements := target.ArrayData()

	// Incref new values
	// Yeni değerlerin referanslarını artır
	for _, v := range values {
		if v != nil {
			v.IncRef()
		}
	}

	newElements := make([]*sv.SV, len(values)+len(elements))
	copy(newElements, values)
	copy(newElements[len(values):], elements)
	target.SetArrayData(newElements)

	return sv.NewInt(int64(len(newElements)))
}

// ============================================================
// Splice Operation
// Splice İşlemi
// ============================================================

// Splice implements splice(@arr, $offset, $length, @list).
// Perl's Swiss Army knife for array manipulation.
//
// Splice, splice(@arr, $offset, $length, @list) işlevini uygular.
// Perl'in dizi manipülasyonu için İsviçre çakısı.
func Splice(arr *sv.SV, offset, length *sv.SV, replacement []*sv.SV) []*sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		panic("Not an array / Dizi değil")
	}

	elements := target.ArrayData()
	arrLen := len(elements)

	// Calculate offset
	// Ofseti hesapla
	off := 0
	if offset != nil && !offset.IsUndef() {
		off = int(offset.AsInt())
	}
	if off < 0 {
		off = arrLen + off
	}
	if off < 0 {
		off = 0
	}
	if off > arrLen {
		off = arrLen
	}

	// Calculate length to remove
	// Kaldırılacak uzunluğu hesapla
	removeLen := arrLen - off // Default: remove everything after offset
	if length != nil && !length.IsUndef() {
		removeLen = int(length.AsInt())
	}
	if removeLen < 0 {
		removeLen = arrLen - off + removeLen
	}
	if removeLen < 0 {
		removeLen = 0
	}
	if off+removeLen > arrLen {
		removeLen = arrLen - off
	}

	// Extract removed elements
	// Kaldırılan öğeleri çıkar
	removed := make([]*sv.SV, removeLen)
	copy(removed, elements[off:off+removeLen])

	// Incref replacement values
	// Yeni değerlerin referanslarını artır
	for _, v := range replacement {
		if v != nil {
			v.IncRef()
		}
	}

	// Build new array
	// Yeni diziyi oluştur
	newLen := arrLen - removeLen + len(replacement)
	newElements := make([]*sv.SV, newLen)

	copy(newElements, elements[:off])
	copy(newElements[off:], replacement)
	copy(newElements[off+len(replacement):], elements[off+removeLen:])

	target.SetArrayData(newElements)

	return removed
}

// ============================================================
// Transformation Operations
// Dönüşüm İşlemleri
// ============================================================

// Reverse reverses array in place and returns it.
// Reverse, diziyi yerinde ters çevirir ve döndürür.
func Reverse(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return arr
	}

	elements := target.ArrayData()
	for i, j := 0, len(elements)-1; i < j; i, j = i+1, j-1 {
		elements[i], elements[j] = elements[j], elements[i]
	}

	return arr
}

// CmpFunc is the comparison function type for sorting.
// CmpFunc, sıralama için karşılaştırma fonksiyonu türüdür.
type CmpFunc func(a, b *sv.SV) int

// Sort sorts array using comparison function.
// If cmpFn is nil, uses string comparison (Perl default).
//
// Sort, karşılaştırma fonksiyonu kullanarak diziyi sıralar.
// cmpFn nil ise, string karşılaştırması kullanır (Perl varsayılanı).
func Sort(arr *sv.SV, cmpFn CmpFunc) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return arr
	}

	elements := target.ArrayData()

	if cmpFn == nil {
		// Default: string comparison
		// Varsayılan: string karşılaştırması
		cmpFn = func(a, b *sv.SV) int {
			return int(sv.StrCmp(a, b).AsInt())
		}
	}

	sort.SliceStable(elements, func(i, j int) bool {
		return cmpFn(elements[i], elements[j]) < 0
	})

	return arr
}

// SortNumeric sorts array numerically.
// SortNumeric, diziyi sayısal olarak sıralar.
func SortNumeric(arr *sv.SV) *sv.SV {
	return Sort(arr, func(a, b *sv.SV) int {
		return int(sv.NumCmp(a, b).AsInt())
	})
}

// ============================================================
// List Operations (grep, map, join)
// Liste İşlemleri (grep, map, join)
// ============================================================

// Grep filters array elements using predicate function.
// Returns elements for which predicate returns true.
//
// Grep, predicate fonksiyonu kullanarak dizi öğelerini filtreler.
// Predicate'in true döndürdüğü öğeleri döndürür.
func Grep(arr *sv.SV, predicate func(*sv.SV) bool) []*sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return []*sv.SV{}
	}

	var result []*sv.SV
	for _, el := range target.ArrayData() {
		if predicate(el) {
			el.IncRef()
			result = append(result, el)
		}
	}
	return result
}

// Map transforms array elements using transform function.
// Transform can return multiple values (like Perl's map).
//
// Map, transform fonksiyonu kullanarak dizi öğelerini dönüştürür.
// Transform birden fazla değer döndürebilir (Perl'in map'i gibi).
func Map(arr *sv.SV, transform func(*sv.SV) []*sv.SV) []*sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return []*sv.SV{}
	}

	var result []*sv.SV
	for _, el := range target.ArrayData() {
		transformed := transform(el)
		result = append(result, transformed...)
	}
	return result
}

// Join joins array elements with separator string.
// Join, dizi öğelerini ayırıcı string ile birleştirir.
func Join(sep *sv.SV, arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewString("")
	}

	elements := target.ArrayData()
	if len(elements) == 0 {
		return sv.NewString("")
	}

	sepStr := sep.AsString()
	result := elements[0].AsString()

	for i := 1; i < len(elements); i++ {
		result += sepStr + elements[i].AsString()
	}

	return sv.NewString(result)
}

// ============================================================
// Utility Operations
// Yardımcı İşlemler
// ============================================================

// Clear empties the array.
// Clear, diziyi boşaltır.
func Clear(arr *sv.SV) {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return
	}

	// Decref all elements
	// Tüm öğelerin referanslarını azalt
	for _, el := range target.ArrayData() {
		if el != nil {
			el.DecRef()
		}
	}
	target.SetArrayData([]*sv.SV{})
}

// Clone creates a shallow copy of the array.
// Clone, dizinin sığ bir kopyasını oluşturur.
func Clone(arr *sv.SV) *sv.SV {
	target := arr
	if arr.IsRef() {
		target = arr.Deref()
	}
	if target == nil || !target.IsArray() {
		return sv.NewArrayRef()
	}

	elements := target.ArrayData()
	newElements := make([]*sv.SV, len(elements))
	for i, el := range elements {
		if el != nil {
			el.IncRef()
		}
		newElements[i] = el
	}

	return sv.NewArrayRef(newElements...)
}

// Flatten takes nested arrayrefs and flattens one level.
// Flatten, iç içe dizi referanslarını bir seviye düzleştirir.
func Flatten(elements []*sv.SV) []*sv.SV {
	var result []*sv.SV
	for _, el := range elements {
		if el.IsRef() && el.Deref().IsArray() {
			inner := el.Deref().ArrayData()
			for _, item := range inner {
				if item != nil {
					item.IncRef()
				}
				result = append(result, item)
			}
		} else {
			if el != nil {
				el.IncRef()
			}
			result = append(result, el)
		}
	}
	return result
}

// ============================================================
// Slice Operations
// Dilim İşlemleri
// ============================================================

// Slice gets multiple elements: @arr[@indices]
// Slice, birden fazla öğe alır: @arr[@indices]
func Slice(arr *sv.SV, indices []*sv.SV) []*sv.SV {
	result := make([]*sv.SV, len(indices))
	for i, idx := range indices {
		result[i] = Fetch(arr, idx)
		result[i].IncRef()
	}
	return result
}

// SliceStore sets multiple elements: @arr[@indices] = @values
// SliceStore, birden fazla öğe ayarlar: @arr[@indices] = @values
func SliceStore(arr *sv.SV, indices []*sv.SV, values []*sv.SV) {
	for i, idx := range indices {
		var v *sv.SV
		if i < len(values) {
			v = values[i]
		} else {
			v = sv.NewUndef()
		}
		Store(arr, idx, v)
	}
}

// ============================================================
// Context Detection
// Bağlam Algılama
// ============================================================

// Context represents Perl's wantarray() - calling context.
// Context, Perl'in wantarray() fonksiyonunu temsil eder - çağrı bağlamı.
type Context int

const (
	ContextVoid   Context = iota // No return value expected / Dönüş değeri beklenmiyor
	ContextScalar                // Scalar value expected / Skaler değer bekleniyor
	ContextList                  // List of values expected / Değer listesi bekleniyor
)
```

## File: ./pkg/av/av_test.go
```go
package av

import (
	"testing"

	"perlc/pkg/sv"
)

// TestPushPop tests stack operations.
// TestPushPop, yığın işlemlerini test eder.
func TestPushPop(t *testing.T) {
	arr := sv.NewArrayRef()

	Push(arr, sv.NewInt(1), sv.NewInt(2), sv.NewInt(3))

	if Len(arr).AsInt() != 3 {
		t.Errorf("Length should be 3, got %d", Len(arr).AsInt())
	}

	val := Pop(arr)
	if val.AsInt() != 3 {
		t.Errorf("Pop should return 3, got %d", val.AsInt())
	}

	if Len(arr).AsInt() != 2 {
		t.Errorf("Length should be 2 after pop, got %d", Len(arr).AsInt())
	}
}

// TestShiftUnshift tests queue operations.
// TestShiftUnshift, kuyruk işlemlerini test eder.
func TestShiftUnshift(t *testing.T) {
	arr := sv.NewArrayRef()

	Push(arr, sv.NewInt(2), sv.NewInt(3))
	Unshift(arr, sv.NewInt(1))

	if Len(arr).AsInt() != 3 {
		t.Errorf("Length should be 3, got %d", Len(arr).AsInt())
	}

	val := Shift(arr)
	if val.AsInt() != 1 {
		t.Errorf("Shift should return 1, got %d", val.AsInt())
	}
}

// TestFetchStore tests element access.
// TestFetchStore, eleman erişimini test eder.
func TestFetchStore(t *testing.T) {
	arr := sv.NewArrayRef()

	// Auto-extend on store
	// Store'da otomatik genişletme
	Store(arr, sv.NewInt(2), sv.NewString("hello"))

	if Len(arr).AsInt() != 3 {
		t.Errorf("Length should be 3, got %d", Len(arr).AsInt())
	}

	val := Fetch(arr, sv.NewInt(2))
	if val.AsString() != "hello" {
		t.Errorf("Fetch should return 'hello', got '%s'", val.AsString())
	}

	// Negative index
	// Negatif indeks
	val = Fetch(arr, sv.NewInt(-1))
	if val.AsString() != "hello" {
		t.Errorf("Fetch(-1) should return 'hello', got '%s'", val.AsString())
	}
}

// TestSplice tests the Swiss Army knife.
// TestSplice, İsviçre çakısını test eder.
func TestSplice(t *testing.T) {
	arr := sv.NewArrayRef()
	Push(arr, sv.NewInt(1), sv.NewInt(2), sv.NewInt(3), sv.NewInt(4), sv.NewInt(5))

	// Remove 2 elements starting at index 1, insert "a", "b"
	// İndeks 1'den başlayarak 2 öğe kaldır, "a", "b" ekle
	removed := Splice(arr, sv.NewInt(1), sv.NewInt(2), []*sv.SV{sv.NewString("a"), sv.NewString("b")})

	if len(removed) != 2 {
		t.Errorf("Should remove 2 elements, got %d", len(removed))
	}
	if removed[0].AsInt() != 2 || removed[1].AsInt() != 3 {
		t.Error("Removed wrong elements")
	}

	// Array should be [1, "a", "b", 4, 5]
	// Dizi [1, "a", "b", 4, 5] olmalı
	if Len(arr).AsInt() != 5 {
		t.Errorf("Length should be 5, got %d", Len(arr).AsInt())
	}
	if Fetch(arr, sv.NewInt(1)).AsString() != "a" {
		t.Error("Element at index 1 should be 'a'")
	}
}

// TestJoin tests joining array elements.
// TestJoin, dizi öğelerini birleştirmeyi test eder.
func TestJoin(t *testing.T) {
	arr := sv.NewArrayRef()
	Push(arr, sv.NewString("a"), sv.NewString("b"), sv.NewString("c"))

	result := Join(sv.NewString("-"), arr)
	if result.AsString() != "a-b-c" {
		t.Errorf("Join should be 'a-b-c', got '%s'", result.AsString())
	}
}

// TestSort tests sorting.
// TestSort, sıralamayı test eder.
func TestSort(t *testing.T) {
	arr := sv.NewArrayRef()
	Push(arr, sv.NewString("banana"), sv.NewString("apple"), sv.NewString("cherry"))

	Sort(arr, nil) // Default string sort

	if Fetch(arr, sv.NewInt(0)).AsString() != "apple" {
		t.Error("First element should be 'apple'")
	}
	if Fetch(arr, sv.NewInt(2)).AsString() != "cherry" {
		t.Error("Last element should be 'cherry'")
	}
}

// TestSortNumeric tests numeric sorting.
// TestSortNumeric, sayısal sıralamayı test eder.
func TestSortNumeric(t *testing.T) {
	arr := sv.NewArrayRef()
	Push(arr, sv.NewInt(10), sv.NewInt(2), sv.NewInt(100))

	SortNumeric(arr)

	if Fetch(arr, sv.NewInt(0)).AsInt() != 2 {
		t.Errorf("First should be 2, got %d", Fetch(arr, sv.NewInt(0)).AsInt())
	}
	if Fetch(arr, sv.NewInt(2)).AsInt() != 100 {
		t.Errorf("Last should be 100, got %d", Fetch(arr, sv.NewInt(2)).AsInt())
	}
}
```

## File: ./pkg/c2go/translator.go
```go
// pkg/c2go/translator.go
package c2go

import (
	"fmt"
	"regexp"
	"strings"
)

// Translator транслирует C код в Go
type Translator struct {
	// Можно добавить настройки
}

func New() *Translator {
	return &Translator{}
}

// Translate транслирует C код в Go
func (t *Translator) Translate(cCode string) string {
	lines := strings.Split(cCode, "\n")
	var result []string

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		if t.isSkipLine(line) {
			continue
		}

		translated := t.TranslateLine(line)
		if translated != "" {
			result = append(result, translated)
		}
	}

	return strings.Join(result, "\n")
}

// isSkipLine проверяет нужно ли пропустить строку
func (t *Translator) isSkipLine(line string) bool {
	skipPrefixes := []string{
		// Perl/XS макросы
		"PUTBACK", "SPAGAIN", "EXTEND", "PUSHMARK",
		"XPUSHs", "PUSHs", "POPs", "TOPs",
		"ENTER", "LEAVE", "SAVETMPS", "FREETMPS",
		"dSP", "dXSARGS", "dMARK", "dITEMS",
		"XSRETURN", "RETURN",
		"SvREFCNT_inc", "SvREFCNT_dec",
		"SvREADONLY",
		"ST (",
		// Память
		"Safefree", "Newx",
	}

	for _, prefix := range skipPrefixes {
		if strings.HasPrefix(line, prefix) {
			return true
		}
	}

	// goto и метки
	if strings.HasPrefix(line, "goto ") {
		return true
	}
	if regexp.MustCompile(`^\w+:$`).MatchString(line) && line != "default:" {
		return true
	}

	return false
}

// TranslateLine транслирует одну строку C в Go
func (t *Translator) TranslateLine(line string) string {
	line = strings.TrimSuffix(line, ";")
	line = strings.TrimSpace(line)

	// === Объявления переменных ===

	// char *str = SvPV_nolen(x)
	if m := regexp.MustCompile(`^char\s*\*\s*(\w+)\s*=\s*SvPV_nolen\s*\(\s*(\w+)\s*\)`).FindStringSubmatch(line); len(m) >= 3 {
		return fmt.Sprintf("%s := %s.AsString()", m[1], m[2])
	}

	// char *str = SvPV(x, len)
	if m := regexp.MustCompile(`^char\s*\*\s*(\w+)\s*=\s*SvPV\s*\(\s*(\w+)\s*,`).FindStringSubmatch(line); len(m) >= 3 {
		return fmt.Sprintf("%s := %s.AsString()", m[1], m[2])
	}

	// char *str;
	if m := regexp.MustCompile(`^char\s*\*\s*(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s string", m[1])
	}

	// SV *var = expr
	if m := regexp.MustCompile(`^SV\s*\*\s*(\w+)\s*=\s*(.+)`).FindStringSubmatch(line); len(m) >= 3 {
		return fmt.Sprintf("%s := %s", m[1], t.TranslateExpr(m[2]))
	}

	// SV *var;
	if m := regexp.MustCompile(`^SV\s*\*\s*(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s *SV", m[1])
	}

	// AV *var;
	if m := regexp.MustCompile(`^AV\s*\*\s*(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s *SV // array", m[1])
	}

	// HV *var;
	if m := regexp.MustCompile(`^HV\s*\*\s*(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s *SV // hash", m[1])
	}

	// int var = expr
	if m := regexp.MustCompile(`^int\s+(\w+)\s*=\s*(.+)`).FindStringSubmatch(line); len(m) >= 3 {
		return fmt.Sprintf("%s := int64(%s)", m[1], t.TranslateExpr(m[2]))
	}

	// int var;
	if m := regexp.MustCompile(`^int\s+(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s int64", m[1])
	}

	// STRLEN var;
	if m := regexp.MustCompile(`^STRLEN\s+(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s int", m[1])
	}

	// UV var;
	if m := regexp.MustCompile(`^UV\s+(\w+)$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("var %s uint64", m[1])
	}

	// === Присваивания ===

	// RETVAL = expr
	if m := regexp.MustCompile(`^RETVAL\s*=\s*(.+)`).FindStringSubmatch(line); len(m) >= 2 {
		expr := t.TranslateExpr(m[1])
		// Если выражение простое (арифметика) и не обёрнуто в sv*, оборачиваем
		if !strings.HasPrefix(expr, "sv") && !strings.HasPrefix(expr, "nil") {
			// Проверяем что это арифметика или переменная
			if regexp.MustCompile(`^[\w\s\+\-\*/%\(\)]+$`).MatchString(expr) {
				return fmt.Sprintf("RETVAL = svInt(int64(%s))", expr)
			}
		}
		return fmt.Sprintf("RETVAL = %s", expr)
	}

	// var = expr
	if m := regexp.MustCompile(`^(\w+)\s*=\s*(.+)`).FindStringSubmatch(line); len(m) >= 3 {
		return fmt.Sprintf("%s = %s", m[1], t.TranslateExpr(m[2]))
	}

	// === Условия ===

	// if (expr) {
	if m := regexp.MustCompile(`^if\s*\(\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("if %s {", t.TranslateCondition(m[1]))
	}

	// } else if (expr) {
	if m := regexp.MustCompile(`^}\s*else\s+if\s*\(\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("} else if %s {", t.TranslateCondition(m[1]))
	}

	// else if (expr) {
	if m := regexp.MustCompile(`^else\s+if\s*\(\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("} else if %s {", t.TranslateCondition(m[1]))
	}

	// } else {
	if regexp.MustCompile(`^}\s*else\s*\{?$`).MatchString(line) {
		return "} else {"
	}

	// else {
	if regexp.MustCompile(`^else\s*\{?$`).MatchString(line) {
		return "} else {"
	}

	// }
	if line == "}" {
		return "}"
	}

	// {
	if line == "{" {
		return "{"
	}

	// === Циклы ===

	// while (expr) {
	if m := regexp.MustCompile(`^while\s*\(\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("for %s {", t.TranslateCondition(m[1]))
	}

	// for (;;) {
	if regexp.MustCompile(`^for\s*\(\s*;;\s*\)\s*\{?$`).MatchString(line) {
		return "for {"
	}

	// for (init; cond; post) {
	if m := regexp.MustCompile(`^for\s*\(\s*(.+);\s*(.+);\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 4 {
		init := t.TranslateExpr(m[1])
		cond := t.TranslateCondition(m[2])
		post := t.TranslateExpr(m[3])
		return fmt.Sprintf("for %s; %s; %s {", init, cond, post)
	}

	// do {
	if line == "do {" || line == "do" {
		return "for {"
	}

	// } while (expr);
	if m := regexp.MustCompile(`^}\s*while\s*\(\s*(.+)\s*\)`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("if !(%s) { break } }", t.TranslateCondition(m[1]))
	}

	// break;
	if line == "break" {
		return "break"
	}

	// continue;
	if line == "continue" {
		return "continue"
	}

	// === Switch ===

	// switch (expr) {
	if m := regexp.MustCompile(`^switch\s*\(\s*(.+)\s*\)\s*\{?$`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("switch %s {", t.TranslateExpr(m[1]))
	}

	// case 'x':
	if m := regexp.MustCompile(`^case\s+'(.)':`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("case '%s':", m[1])
	}

	// case X:
	if m := regexp.MustCompile(`^case\s+(\w+):`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("case %s:", m[1])
	}

	// default:
	if line == "default:" {
		return "default:"
	}

	// === Вызовы функций ===

	// croak(...)
	if m := regexp.MustCompile(`^croak\s*\((.+)\)`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("panic(%s)", m[1])
	}

	// warn(...)
	if m := regexp.MustCompile(`^warn\s*\((.+)\)`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("fmt.Fprintf(os.Stderr, %s)", m[1])
	}

	// return expr
	if m := regexp.MustCompile(`^return\s+(.+)`).FindStringSubmatch(line); len(m) >= 2 {
		return fmt.Sprintf("return %s", t.TranslateExpr(m[1]))
	}

	// return;
	if line == "return" {
		return "return"
	}

	// Общая трансляция
	return t.TranslateExpr(line)
}

// TranslateExpr транслирует C выражение в Go
func (t *Translator) TranslateExpr(expr string) string {
	expr = strings.TrimSpace(expr)
	expr = strings.TrimSuffix(expr, ";")

	// === Создание SV ===

	// newSVpvf("fmt", args)
	if m := regexp.MustCompile(`newSVpvf\s*\(\s*"([^"]+)"\s*,\s*(.+)\)`).FindStringSubmatch(expr); len(m) >= 3 {
		return fmt.Sprintf(`svStr(fmt.Sprintf("%s", %s))`, m[1], t.TranslateExpr(m[2]))
	}

	// newSVpv(str, len)
	expr = regexp.MustCompile(`newSVpv\s*\(\s*([^,]+)\s*,\s*\d+\s*\)`).ReplaceAllString(expr, "svStr($1)")

	// newSVpvn(str, len)
	expr = regexp.MustCompile(`newSVpvn\s*\(\s*([^,]+)\s*,\s*\d+\s*\)`).ReplaceAllString(expr, "svStr($1)")

	// newSVpvn("", 0)
	expr = regexp.MustCompile(`newSVpvn\s*\(\s*""\s*,\s*0\s*\)`).ReplaceAllString(expr, `svStr("")`)

	// newSViv(x)
	expr = regexp.MustCompile(`newSViv\s*\(\s*([^)]+)\s*\)`).ReplaceAllString(expr, "svInt(int64($1))")

	// newSVuv(x)
	expr = regexp.MustCompile(`newSVuv\s*\(\s*([^)]+)\s*\)`).ReplaceAllString(expr, "svInt(int64($1))")

	// newSVnv(x)
	expr = regexp.MustCompile(`newSVnv\s*\(\s*([^)]+)\s*\)`).ReplaceAllString(expr, "svFloat($1)")

	// newSVsv(x)
	expr = regexp.MustCompile(`newSVsv\s*\(\s*([^)]+)\s*\)`).ReplaceAllString(expr, "svCopy($1)")

	// newRV_inc(x) / newRV_noinc(x)
	expr = regexp.MustCompile(`newRV_(?:inc|noinc)\s*\(\s*([^)]+)\s*\)`).ReplaceAllString(expr, "svRef($1)")

	// newHV()
	expr = regexp.MustCompile(`newHV\s*\(\s*\)`).ReplaceAllString(expr, "svHash()")

	// newAV()
	expr = regexp.MustCompile(`newAV\s*\(\s*\)`).ReplaceAllString(expr, "svArray()")

	// === Доступ к SV ===

	// SvPV_nolen(x)
	expr = regexp.MustCompile(`SvPV_nolen\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.AsString()")

	// SvPV(x, len)
	expr = regexp.MustCompile(`SvPV\s*\(\s*(\w+)\s*,\s*\w+\s*\)`).ReplaceAllString(expr, "$1.AsString()")

	// SvIV(x)
	expr = regexp.MustCompile(`SvIV\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.AsInt()")

	// SvUV(x)
	expr = regexp.MustCompile(`SvUV\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "uint64($1.AsInt())")

	// SvNV(x)
	expr = regexp.MustCompile(`SvNV\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.AsFloat()")

	// SvTRUE(x)
	expr = regexp.MustCompile(`SvTRUE\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.IsTrue()")

	// SvOK(x)
	expr = regexp.MustCompile(`SvOK\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "(!$1.IsUndef())")

	// SvROK(x)
	expr = regexp.MustCompile(`SvROK\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.IsRef()")

	// SvRV(x)
	expr = regexp.MustCompile(`SvRV\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "$1.Deref()")

	// SvCUR(x) - длина строки
	expr = regexp.MustCompile(`SvCUR\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "len($1.AsString())")

	// === Хеши ===

	// hv_store(hv, key, len, val, hash)
	expr = regexp.MustCompile(`hv_store\s*\(\s*(\w+)\s*,\s*([^,]+)\s*,\s*\d+\s*,\s*([^,]+)\s*,\s*\d+\s*\)`).
		ReplaceAllString(expr, "svHSet($1, svStr($2), $3)")

	// hv_fetch(hv, key, len, lval)
	expr = regexp.MustCompile(`hv_fetch\s*\(\s*(\w+)\s*,\s*([^,]+)\s*,\s*\d+\s*,\s*\d+\s*\)`).
		ReplaceAllString(expr, "svHGet($1, svStr($2))")

	// hv_exists(hv, key, len)
	expr = regexp.MustCompile(`hv_exists\s*\(\s*(\w+)\s*,\s*([^,]+)\s*,\s*\d+\s*\)`).
		ReplaceAllString(expr, "svHExists($1, svStr($2))")

	// hv_delete(hv, key, len, flags)
	expr = regexp.MustCompile(`hv_delete\s*\(\s*(\w+)\s*,\s*([^,]+)\s*,\s*\d+\s*,\s*\w+\s*\)`).
		ReplaceAllString(expr, "svHDelete($1, svStr($2))")

	// === Массивы ===

	// av_push(av, val)
	expr = regexp.MustCompile(`av_push\s*\(\s*(\w+)\s*,\s*([^)]+)\s*\)`).
		ReplaceAllString(expr, "svPush($1, $2)")

	// av_pop(av)
	expr = regexp.MustCompile(`av_pop\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "svPop($1)")

	// av_shift(av)
	expr = regexp.MustCompile(`av_shift\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "svShift($1)")

	// av_len(av)
	expr = regexp.MustCompile(`av_len\s*\(\s*(\w+)\s*\)`).ReplaceAllString(expr, "(len($1.av)-1)")

	// av_fetch(av, idx, lval)
	expr = regexp.MustCompile(`av_fetch\s*\(\s*(\w+)\s*,\s*([^,]+)\s*,\s*\d+\s*\)`).
		ReplaceAllString(expr, "svAGet($1, $2)")

	// === Приведение типов ===

	// (HV *)x
	expr = regexp.MustCompile(`\(\s*HV\s*\*\s*\)\s*(\w+)`).ReplaceAllString(expr, "$1")

	// (AV *)x
	expr = regexp.MustCompile(`\(\s*AV\s*\*\s*\)\s*(\w+)`).ReplaceAllString(expr, "$1")

	// (SV *)x
	expr = regexp.MustCompile(`\(\s*SV\s*\*\s*\)\s*(\w+)`).ReplaceAllString(expr, "$1")

	// (IV)x
	expr = regexp.MustCompile(`\(\s*IV\s*\)\s*(\w+)`).ReplaceAllString(expr, "int64($1)")

	// (UV)x
	expr = regexp.MustCompile(`\(\s*UV\s*\)\s*(\w+)`).ReplaceAllString(expr, "uint64($1)")

	// === Константы ===
	expr = strings.ReplaceAll(expr, "NULL", "nil")
	expr = strings.ReplaceAll(expr, "&PL_sv_undef", "svUndef()")

	return expr
}

// TranslateCondition транслирует условие C в Go
func (t *Translator) TranslateCondition(cond string) string {
	cond = strings.TrimSpace(cond)

	// Убираем внешние скобки если они парные
	if strings.HasPrefix(cond, "(") && strings.HasSuffix(cond, ")") {
		inner := cond[1 : len(cond)-1]
		depth := 0
		valid := true
		for _, ch := range inner {
			if ch == '(' {
				depth++
			} else if ch == ')' {
				depth--
				if depth < 0 {
					valid = false
					break
				}
			}
		}
		if valid && depth == 0 {
			cond = inner
		}
	}

	// !x -> !x
	// x == y -> x == y
	// Применяем общую трансляцию
	return t.TranslateExpr(cond)
}
```

## File: ./pkg/cache/cache.go
```go
// pkg/cache/cache.go
package cache

import (
	"os"
	"path/filepath"
	"time"
)

var cacheDir string

func init() {
	home, err := os.UserHomeDir()
	if err != nil {
		home = "."
	}
	cacheDir = filepath.Join(home, ".perlc", "cache")
}

type CachedModule struct {
	Name       string
	Version    string
	GoCode     string
	CompiledAt time.Time
}

func Get(module, version string) (*CachedModule, bool) {
	path := filepath.Join(cacheDir, module, version+".go")
	if _, err := os.Stat(path); err == nil {
		content, _ := os.ReadFile(path)
		return &CachedModule{
			Name:    module,
			Version: version,
			GoCode:  string(content),
		}, true
	}
	return nil, false
}

func Store(module, version, goCode string) {
	dir := filepath.Join(cacheDir, module)
	os.MkdirAll(dir, 0755)
	path := filepath.Join(dir, version+".go")
	os.WriteFile(path, []byte(goCode), 0644)
}
```

## File: ./pkg/codegen/codegen.go
```go
// Package codegen generates Go code from Perl AST.
package codegen

import (
	"fmt"
	"strings"

	"perlc/pkg/ast"
)

// Generator generates Go code from AST.
type Generator struct {
	output strings.Builder
	indent int
	//varCount  int
	tempCount    int
	declaredVars map[string]bool
}

// New creates a new Generator.
func New() *Generator {
	return &Generator{
		declaredVars: make(map[string]bool),
	}
}

// Generate generates Go code from a program.
func (g *Generator) Generate(program *ast.Program) string {
	g.output.Reset()

	// Header
	g.writeln("package main")
	g.writeln("")
	g.writeln("import (")
	g.indent++
	g.writeln(`"bufio"`)
	g.writeln(`"fmt"`)
	g.writeln(`"math"`)
	g.writeln(`"os"`)
	g.writeln(`"regexp"`)
	g.writeln(`"strings"`)
	g.indent--
	g.writeln(")")
	g.writeln("")

	// Suppress unused import errors
	g.writeln("var _ = fmt.Sprint")
	g.writeln("var _ = strings.Join")
	g.writeln("var _ = math.Abs")
	g.writeln("var _ = regexp.Compile")
	g.writeln("var _ = bufio.NewReader")
	g.writeln("var _ = os.Stdin")
	g.writeln("")

	// Runtime types and functions
	g.writeRuntime()

	// Collect subroutine declarations first
	var subs []*ast.SubDecl
	var stmts []ast.Statement
	for _, stmt := range program.Statements {
		if sub, ok := stmt.(*ast.SubDecl); ok {
			subs = append(subs, sub)
		} else {
			stmts = append(stmts, stmt)
		}
	}

	// Generate subroutines as Go functions
	for _, sub := range subs {
		g.generateSubDecl(sub)
		g.writeln("")
	}

	// Generate init function to register methods
	g.writeln("func init() {")
	g.indent++
	for _, sub := range subs {
		// Register each subroutine as a potential method
		funcName := "perl_" + strings.ReplaceAll(sub.Name, "::", "_")
		g.writeln(fmt.Sprintf("perl_register_method(%q, %s)", strings.ReplaceAll(sub.Name, "::", "_"), funcName))
	}
	g.indent--
	g.writeln("}")
	g.writeln("")

	// Generate main function
	g.writeln("func main() {")
	g.indent++

	for _, stmt := range stmts {
		g.generateStatement(stmt)
	}

	g.indent--
	g.writeln("}")

	return g.output.String()
}

func (g *Generator) writeRuntime() {
	g.writeln("// ============ Runtime ============")
	g.writeln("")

	// SV type
	g.writeln("type SV struct {")
	g.indent++
	g.writeln("iv    int64")
	g.writeln("nv    float64")
	g.writeln("pv    string")
	g.writeln("av    []*SV")
	g.writeln("hv    map[string]*SV")
	g.writeln("flags uint8")
	g.indent--
	g.writeln("}")
	g.writeln("")

	g.writeln("const (")
	g.indent++
	g.writeln("SVf_IOK uint8 = 1 << iota")
	g.writeln("SVf_NOK")
	g.writeln("SVf_POK")
	g.writeln("SVf_AOK")
	g.writeln("SVf_HOK")
	g.indent--
	g.writeln(")")
	g.writeln("")

	// g.writeln("var _ = bufio.NewReader") //- Move to generate

	// Constructors
	g.writeln("func svInt(i int64) *SV { return &SV{iv: i, flags: SVf_IOK} }")
	g.writeln("func svFloat(f float64) *SV { return &SV{nv: f, flags: SVf_NOK} }")
	g.writeln("func svStr(s string) *SV { return &SV{pv: s, flags: SVf_POK} }")
	g.writeln("func svUndef() *SV { return &SV{} }")
	g.writeln("func svArray(elems ...*SV) *SV { return &SV{av: elems, flags: SVf_AOK} }")
	g.writeln("func svHash() *SV { return &SV{hv: make(map[string]*SV), flags: SVf_HOK} }")
	g.writeln("")

	// Converters
	g.writeln(`func (sv *SV) AsInt() int64 {
	if sv == nil { return 0 }
	if sv.flags&SVf_IOK != 0 { return sv.iv }
	if sv.flags&SVf_NOK != 0 { return int64(sv.nv) }
	if sv.flags&SVf_POK != 0 { 
		var i int64
		fmt.Sscanf(sv.pv, "%d", &i)
		return i
	}
	return 0
}`)
	g.writeln("")

	g.writeln(`func (sv *SV) AsFloat() float64 {
	if sv == nil { return 0 }
	if sv.flags&SVf_NOK != 0 { return sv.nv }
	if sv.flags&SVf_IOK != 0 { return float64(sv.iv) }
	if sv.flags&SVf_POK != 0 {
		var f float64
		fmt.Sscanf(sv.pv, "%f", &f)
		return f
	}
	return 0
}`)
	g.writeln("")

	g.writeln(`func (sv *SV) AsString() string {
	if sv == nil { return "" }
	if sv.flags&SVf_POK != 0 { return sv.pv }
	if sv.flags&SVf_IOK != 0 { return fmt.Sprintf("%d", sv.iv) }
	if sv.flags&SVf_NOK != 0 { 
		if sv.nv == float64(int64(sv.nv)) {
			return fmt.Sprintf("%d", int64(sv.nv))
		}
		return fmt.Sprintf("%g", sv.nv)
	}
	return ""
}`)
	g.writeln("")

	g.writeln(`func (sv *SV) IsTrue() bool {
	if sv == nil { return false }
	if sv.flags&SVf_IOK != 0 { return sv.iv != 0 }
	if sv.flags&SVf_NOK != 0 { return sv.nv != 0 }
	if sv.flags&SVf_POK != 0 { return sv.pv != "" && sv.pv != "0" }
	if sv.flags&SVf_AOK != 0 { return len(sv.av) > 0 }
	if sv.flags&SVf_HOK != 0 { return len(sv.hv) > 0 }
	return false
}`)
	g.writeln("")

	// Operations
	g.writeln(`func svAdd(a, b *SV) *SV { 
	if a.flags&SVf_IOK != 0 && b.flags&SVf_IOK != 0 {
		return svInt(a.iv + b.iv)
	}
	return svFloat(a.AsFloat() + b.AsFloat()) 
}`)

	g.writeln(`func svSub(a, b *SV) *SV {
	if a.flags&SVf_IOK != 0 && b.flags&SVf_IOK != 0 {
		return svInt(a.iv - b.iv)
	}
	return svFloat(a.AsFloat() - b.AsFloat())
}`)

	g.writeln(`func svMul(a, b *SV) *SV {
	if a.flags&SVf_IOK != 0 && b.flags&SVf_IOK != 0 {
		return svInt(a.iv * b.iv)
	}
	return svFloat(a.AsFloat() * b.AsFloat())
}`)

	g.writeln("func svDiv(a, b *SV) *SV { return svFloat(a.AsFloat() / b.AsFloat()) }")
	g.writeln("func svMod(a, b *SV) *SV { return svInt(a.AsInt() % b.AsInt()) }")
	g.writeln("func svPow(a, b *SV) *SV { return svFloat(math.Pow(a.AsFloat(), b.AsFloat())) }")
	g.writeln("func svConcat(a, b *SV) *SV { return svStr(a.AsString() + b.AsString()) }")
	g.writeln("func svRepeat(s, n *SV) *SV { return svStr(strings.Repeat(s.AsString(), int(n.AsInt()))) }")
	g.writeln("func svNeg(a *SV) *SV { return svFloat(-a.AsFloat()) }")
	g.writeln("func svNot(a *SV) *SV { if a.IsTrue() { return svInt(0) }; return svInt(1) }")
	g.writeln("")

	// Comparisons
	g.writeln("func svNumEq(a, b *SV) *SV { if a.AsFloat() == b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svNumNe(a, b *SV) *SV { if a.AsFloat() != b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svNumLt(a, b *SV) *SV { if a.AsFloat() < b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svNumLe(a, b *SV) *SV { if a.AsFloat() <= b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svNumGt(a, b *SV) *SV { if a.AsFloat() > b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svNumGe(a, b *SV) *SV { if a.AsFloat() >= b.AsFloat() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrEq(a, b *SV) *SV { if a.AsString() == b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrNe(a, b *SV) *SV { if a.AsString() != b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrLt(a, b *SV) *SV { if a.AsString() < b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrLe(a, b *SV) *SV { if a.AsString() <= b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrGt(a, b *SV) *SV { if a.AsString() > b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("func svStrGe(a, b *SV) *SV { if a.AsString() >= b.AsString() { return svInt(1) }; return svInt(0) }")
	g.writeln("")

	// Array ops
	g.writeln(`func svAGet(arr *SV, idx *SV) *SV {
	if arr == nil || arr.flags&SVf_AOK == 0 { return svUndef() }
	i := int(idx.AsInt())
	if i < 0 { i = len(arr.av) + i }
	if i < 0 || i >= len(arr.av) { return svUndef() }
	return arr.av[i]
}`)
	g.writeln("")

	g.writeln(`func svASet(arr *SV, idx *SV, val *SV) *SV {
	if arr == nil { return val }
	i := int(idx.AsInt())
	for len(arr.av) <= i { arr.av = append(arr.av, svUndef()) }
	arr.av[i] = val
	return val
}`)
	g.writeln("")

	g.writeln(`func svPush(arr *SV, vals ...*SV) *SV {
	arr.av = append(arr.av, vals...)
	return svInt(int64(len(arr.av)))
}`)
	g.writeln("")

	g.writeln(`func svPop(arr *SV) *SV {
	if len(arr.av) == 0 { return svUndef() }
	val := arr.av[len(arr.av)-1]
	arr.av = arr.av[:len(arr.av)-1]
	return val
}`)
	g.writeln("")

	g.writeln(`func svShift(arr *SV) *SV {
	if len(arr.av) == 0 { return svUndef() }
	val := arr.av[0]
	arr.av = arr.av[1:]
	return val
}`)
	g.writeln("")

	g.writeln(`func svUnshift(arr *SV, vals ...*SV) *SV {
	arr.av = append(vals, arr.av...)
	return svInt(int64(len(arr.av)))
}`)
	g.writeln("")

	// Hash ops
	g.writeln(`func svHGet(h *SV, key *SV) *SV {
	if h == nil || h.hv == nil { return svUndef() }
	if v, ok := h.hv[key.AsString()]; ok { return v }
	return svUndef()
}`)
	g.writeln("")

	g.writeln(`func svHSet(h *SV, key *SV, val *SV) *SV {
	if h.hv == nil { h.hv = make(map[string]*SV); h.flags |= SVf_HOK }
	h.hv[key.AsString()] = val
	return val
}`)
	g.writeln("")

	// Builtins
	g.writeln(`func perlPrint(args ...*SV) *SV {
	for _, a := range args { fmt.Print(a.AsString()) }
	return svInt(1)
}`)
	g.writeln("")

	g.writeln(`func perlSay(args ...*SV) *SV {
	for _, a := range args { fmt.Print(a.AsString()) }
	fmt.Println()
	return svInt(1)
}`)
	g.writeln("")

	g.writeln(`func perlLength(s *SV) *SV { return svInt(int64(len(s.AsString()))) }`)
	g.writeln(`func perlUc(s *SV) *SV { return svStr(strings.ToUpper(s.AsString())) }`)
	g.writeln(`func perlLc(s *SV) *SV { return svStr(strings.ToLower(s.AsString())) }`)
	g.writeln(`func perlAbs(n *SV) *SV { return svFloat(math.Abs(n.AsFloat())) }`)
	g.writeln(`func perlInt(n *SV) *SV { return svInt(n.AsInt()) }`)
	g.writeln(`func perlSqrt(n *SV) *SV { return svFloat(math.Sqrt(n.AsFloat())) }`)
	g.writeln(`func perlChr(n *SV) *SV { return svStr(string(rune(n.AsInt()))) }`)
	g.writeln(`func perlOrd(s *SV) *SV { r := []rune(s.AsString()); if len(r) > 0 { return svInt(int64(r[0])) }; return svUndef() }`)
	g.writeln("")

	g.writeln(`func perl_scalar(sv *SV) *SV {
		if sv == nil { return svInt(0) }
		if sv.flags&SVf_AOK != 0 { return svInt(int64(len(sv.av))) }
		if sv.flags&SVf_HOK != 0 { return svInt(int64(len(sv.hv))) }
		return sv
}`)
	g.writeln(`func perl_keys(h *SV) *SV {
		if h == nil || h.hv == nil { return svArray() }
		var keys []*SV
		for k := range h.hv { keys = append(keys, svStr(k)) }
		return svArray(keys...)
}`)
	g.writeln(`func perl_join(sep, arr *SV) *SV {
		if arr == nil { return svStr("") }
		var parts []string
		for _, el := range arr.av { parts = append(parts, el.AsString()) }
		return svStr(strings.Join(parts, sep.AsString()))
}`)
	g.writeln("")

	g.writeln(`// OOP Support
var _blessedPkg = make(map[*SV]string)
var _packageISA = make(map[string][]string)
var _methods = make(map[string]func(args ...*SV) *SV)

func perl_register_method(name string, fn func(args ...*SV) *SV) {
	_methods[name] = fn
}

func perl_bless(ref, class *SV) *SV {
	_blessedPkg[ref] = class.AsString()
	return ref
}

func perl_ref(sv *SV) *SV {
	if sv == nil { return svStr("") }
	if pkg, ok := _blessedPkg[sv]; ok { return svStr(pkg) }
	if sv.flags&0x80 != 0 { return svStr("SCALAR") }
	if sv.flags&SVf_AOK != 0 { return svStr("ARRAY") }
	if sv.flags&SVf_HOK != 0 { return svStr("HASH") }
	return svStr("")
}

func perl_set_isa(child *SV, parents ...*SV) *SV {
	childName := child.AsString()
	var parentNames []string
	for _, p := range parents {
		parentNames = append(parentNames, p.AsString())
	}
	_packageISA[childName] = parentNames
	return svInt(1)
}

func perl_method_call(obj *SV, method string, args ...*SV) *SV {
	var pkg string
	
	// Check if obj is a class name (string) or blessed reference
	if obj.flags&SVf_POK != 0 && _blessedPkg[obj] == "" {
		// Class method call: Point->new()
		pkg = obj.AsString()
	} else if p, ok := _blessedPkg[obj]; ok {
		// Instance method call: $obj->method()
		pkg = p
	} else {
		return svUndef()
	}
	
	// Search for method in class hierarchy
	fullArgs := append([]*SV{obj}, args...)
	return perl_find_and_call(pkg, method, fullArgs)
}

func perl_find_and_call(pkg, method string, args []*SV) *SV {
	// Try this package first
	key := pkg + "_" + method
	if fn, ok := _methods[key]; ok {
		return fn(args...)
	}
	
	// Try parent classes
	for _, parent := range _packageISA[pkg] {
		result := perl_find_and_call(parent, method, args)
		if result != nil {
			return result
		}
	}
	
	return svUndef()
}

func perl_isa(obj, class *SV) *SV {
	pkg, ok := _blessedPkg[obj]
	if !ok { return svInt(0) }
	target := class.AsString()
	if pkg == target { return svInt(1) }
	return perl_isa_check(pkg, target)
}

func perl_isa_check(pkg, target string) *SV {
	if pkg == target { return svInt(1) }
	for _, parent := range _packageISA[pkg] {
		if perl_isa_check(parent, target).IsTrue() { return svInt(1) }
	}
	return svInt(0)
}`)
	g.writeln("")
	// Regex captures
	g.writeln("var _captures []string")
	g.writeln("")
	g.writeln(`func _getCapture(n int) string {
	if n < 1 || n > len(_captures) { return "" }
	return _captures[n-1]
}`)

	g.writeln("")

	// File I/O
	// File I/O - добавь _filehandles ПЕРЕД perlOpen
	g.writeln("var _filehandles = make(map[string]*_FileHandle)")
	g.writeln("")
	g.writeln(`type _FileHandle struct {
	file    *os.File
	scanner *bufio.Scanner
	writer  *bufio.Writer
}`)
	g.writeln("")

	g.writeln(`func perlOpen(name, mode, filename string) *SV {
	var file *os.File
	var err error
	switch mode {
	case "<", "r":
		file, err = os.Open(filename)
	case ">", "w":
		file, err = os.Create(filename)
	case ">>", "a":
		file, err = os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	default:
		file, err = os.Open(filename)
	}
	if err != nil { return svInt(0) }
	fh := &_FileHandle{file: file}
	if mode == "<" || mode == "r" || mode == "" {
		fh.scanner = bufio.NewScanner(file)
	} else {
		fh.writer = bufio.NewWriter(file)
	}
	_filehandles[name] = fh
	return svInt(1)
}`)
	g.writeln("")
	g.writeln(`func perlClose(name string) *SV {
	if fh, ok := _filehandles[name]; ok {
		if fh.writer != nil { fh.writer.Flush() }
		fh.file.Close()
		delete(_filehandles, name)
		return svInt(1)
	}
	return svInt(0)
}`)
	g.writeln("")
	g.writeln(`func perlReadLine(name string) *SV {
	if name == "" {
		scanner := bufio.NewScanner(os.Stdin)
		if scanner.Scan() { return svStr(scanner.Text() + "\n") }
		return svUndef()
	}
	if fh, ok := _filehandles[name]; ok && fh.scanner != nil {
		if fh.scanner.Scan() { return svStr(fh.scanner.Text() + "\n") }
	}
	return svUndef()
}`)
	g.writeln("")

	g.writeln(`func perlPrintFH(fhName string, args ...*SV) *SV {
	if fh, ok := _filehandles[fhName]; ok && fh.writer != nil {
		for _, a := range args { fh.writer.WriteString(a.AsString()) }
		return svInt(1)
	}
	return svInt(0)
}`)
	g.writeln("")
	g.writeln(`func perlSayFH(fhName string, args ...*SV) *SV {
	if fh, ok := _filehandles[fhName]; ok && fh.writer != nil {
		for _, a := range args { fh.writer.WriteString(a.AsString()) }
		fh.writer.WriteString("\n")
		return svInt(1)
	}
	return svInt(0)
}`)
	g.writeln("")

	// === НАЧАЛО ПАТЧА - добавить в writeRuntime() ===

	// split
	g.writeln(`func perl_split(sep, str *SV) *SV {
	parts := strings.Split(str.AsString(), sep.AsString())
	var result []*SV
	for _, p := range parts {
		result = append(result, svStr(p))
	}
	return svArray(result...)
}`)
	g.writeln("")

	// reverse
	g.writeln(`func perl_reverse(arr *SV) *SV {
	if arr == nil || arr.flags&SVf_AOK == 0 { return svArray() }
	n := len(arr.av)
	result := make([]*SV, n)
	for i := 0; i < n; i++ {
		result[i] = arr.av[n-1-i]
	}
	return svArray(result...)
}`)
	g.writeln("")

	// sort
	g.writeln(`func perl_sort(arr *SV) *SV {
	if arr == nil || arr.flags&SVf_AOK == 0 { return svArray() }
	result := make([]*SV, len(arr.av))
	copy(result, arr.av)
	for i := 0; i < len(result)-1; i++ {
		for j := i+1; j < len(result); j++ {
			if result[i].AsString() > result[j].AsString() {
				result[i], result[j] = result[j], result[i]
			}
		}
	}
	return svArray(result...)
}`)
	g.writeln("")

	// values
	g.writeln(`func perl_values(h *SV) *SV {
	if h == nil || h.hv == nil { return svArray() }
	var vals []*SV
	for _, v := range h.hv { vals = append(vals, v) }
	return svArray(vals...)
}`)
	g.writeln("")

	// exists
	g.writeln(`func perl_exists(v *SV) *SV {
	if v == nil || v.flags == 0 { return svInt(0) }
	return svInt(1)
}`)
	g.writeln("")

	// delete (для хеша - нужно передавать хеш и ключ)
	g.writeln(`func perl_delete(v *SV) *SV {
	return svUndef()
}`)
	g.writeln("")

	// chomp
	g.writeln(`func perl_chomp(sv *SV) *SV {
	if sv == nil { return svInt(0) }
	s := sv.pv
	if len(s) > 0 && s[len(s)-1] == '\n' {
		sv.pv = s[:len(s)-1]
		return svInt(1)
	}
	return svInt(0)
}`)
	g.writeln("")

	// defined
	g.writeln(`func perl_defined(sv *SV) *SV {
	if sv == nil || sv.flags == 0 { return svInt(0) }
	return svInt(1)
}`)
	g.writeln("")

	g.writeln(`func svRef(sv *SV) *SV {
		return &SV{av: []*SV{sv}, flags: SVf_AOK | 0x80}
	}`)
	g.writeln("")

	g.writeln(`func svDeref(ref *SV) *SV {
		if ref != nil && len(ref.av) > 0 {
			return ref.av[0]
		}
		return svUndef()
	}`)
	g.writeln("")

	// === КОНЕЦ ПАТЧА ===

	g.writeln("// ============ End Runtime ============")
	g.writeln("")
}

func (g *Generator) write(s string) {
	g.output.WriteString(s)
}

func (g *Generator) writeln(s string) {
	for i := 0; i < g.indent; i++ {
		g.output.WriteString("\t")
	}
	g.output.WriteString(s)
	g.output.WriteString("\n")
}

func (g *Generator) generateStatement(stmt ast.Statement) {
	switch s := stmt.(type) {
	case *ast.ExprStmt:
		// Special handling for open() to declare filehandle variable
		if call, ok := s.Expression.(*ast.CallExpr); ok {
			if ident, ok := call.Function.(*ast.Identifier); ok && ident.Value == "open" {
				g.generateOpenStatement(call)
				return
			}
		}
		g.write(strings.Repeat("\t", g.indent))
		g.generateExpression(s.Expression)
		g.write("\n")
	case *ast.VarDecl:
		g.generateVarDecl(s)
	case *ast.IfStmt:
		g.generateIfStmt(s)
	case *ast.WhileStmt:
		g.generateWhileStmt(s)
	case *ast.ForStmt:
		g.generateForStmt(s)
	case *ast.ForeachStmt:
		g.generateForeachStmt(s)
	case *ast.BlockStmt:
		g.generateBlockStmt(s)
	case *ast.ReturnStmt:
		g.generateReturnStmt(s)
	case *ast.LastStmt:
		g.writeln("break")
	case *ast.NextStmt:
		g.writeln("continue")
	case *ast.SubDecl:
		// Already handled at top level
	case *ast.UseDecl:
		// Ignore for now
	case *ast.PackageDecl:
		// Ignore for now
	}
}

func (g *Generator) generateVarDecl(decl *ast.VarDecl) {
	// Handle list assignment: my ($a, $b) = @_
	if decl.IsList && decl.Value != nil {
		// Check if assigning from @_ (can be ArrayVar or SpecialVar)
		isArgsAssign := false
		if av, ok := decl.Value.(*ast.ArrayVar); ok && av.Name == "_" {
			isArgsAssign = true
		}
		if sv, ok := decl.Value.(*ast.SpecialVar); ok && sv.Name == "@_" {
			isArgsAssign = true
		}

		if isArgsAssign {
			// Unpack from args
			for i, v := range decl.Names {
				name := g.varName(v)
				g.declaredVars[name] = true
				g.write(strings.Repeat("\t", g.indent))
				g.write(fmt.Sprintf("%s := func() *SV { if %d < len(args) { return args[%d] }; return svUndef() }()\n", name, i, i))
				g.writeln("_ = " + name)
			}
			return
		}
		// Other list assignments - generate temp array and unpack
		g.tempCount++
		tmpVar := fmt.Sprintf("_tmp%d", g.tempCount)
		g.write(strings.Repeat("\t", g.indent))
		g.write(tmpVar + " := ")
		g.generateExpression(decl.Value)
		g.write("\n")
		for i, v := range decl.Names {
			name := g.varName(v)
			g.declaredVars[name] = true
			g.write(strings.Repeat("\t", g.indent))
			g.write(fmt.Sprintf("%s := svAGet(%s, svInt(%d))\n", name, tmpVar, i))
			g.writeln("_ = " + name)
		}
		return
	}

	if len(decl.Names) == 1 {
		name := g.varName(decl.Names[0])
		g.write(strings.Repeat("\t", g.indent))

		// Определяем оператор: := для нового, = для уже объявленного
		op := " := "
		if g.declaredVars[name] {
			op = " = "
		} else {
			g.declaredVars[name] = true
		}

		// Check variable type for proper initialization
		switch decl.Names[0].(type) {
		case *ast.ArrayVar:
			if decl.Value != nil {
				g.write(name + op)
				g.generateExpression(decl.Value)
			} else {
				g.write(name + op + "svArray()")
			}
		case *ast.HashVar:
			if decl.Value != nil {
				// Convert array to hash
				g.write(name + op + "func() *SV { _arr := ")
				g.generateExpression(decl.Value)
				g.write("; _h := svHash(); for _i := 0; _i+1 < len(_arr.av); _i += 2 { svHSet(_h, _arr.av[_i], _arr.av[_i+1]) }; return _h }()")
			} else {
				g.write(name + op + "svHash()")
			}
		default:
			if decl.Value != nil {
				g.write(name + op)
				g.generateExpression(decl.Value)
			} else {
				g.write(name + op + "svUndef()")
			}
		}
		g.write("\n")
		// _ = name только для новых переменных
		if op == " := " {
			g.writeln("_ = " + name)
		}
		return
	}

	for _, v := range decl.Names {
		name := g.varName(v)
		g.declaredVars[name] = true
		g.write(strings.Repeat("\t", g.indent))
		g.write(name + " := svUndef()")
		g.write("\n")
		g.writeln("_ = " + name)
	}
}

func (g *Generator) generateSubDecl(sub *ast.SubDecl) {
	// Очищаем declaredVars для нового scope функции
	g.declaredVars = make(map[string]bool)

	g.write("func perl_" + strings.ReplaceAll(sub.Name, "::", "_") + "(args ...*SV) *SV {\n")
	g.indent++
	g.writeln("_ = args")
	g.writeln("_args := svArray(args...)") // Создаём один массив для @_
	g.writeln("_ = _args")                 // Предотвращаем ошибку "declared and not used"

	// Generate body
	for _, stmt := range sub.Body.Statements {
		g.generateStatement(stmt)
	}

	g.writeln("return svUndef()")
	g.indent--
	g.writeln("}")
}

func (g *Generator) generateIfStmt(stmt *ast.IfStmt) {
	g.write(strings.Repeat("\t", g.indent))
	if stmt.Unless {
		g.write("if !(")
	} else {
		g.write("if (")
	}
	g.generateExpression(stmt.Condition)
	g.write(").IsTrue() {\n")
	g.indent++
	for _, s := range stmt.Then.Statements {
		g.generateStatement(s)
	}
	g.indent--

	for _, elsif := range stmt.Elsif {
		g.write(strings.Repeat("\t", g.indent))
		g.write("} else if (")
		g.generateExpression(elsif.Condition)
		g.write(").IsTrue() {\n")
		g.indent++
		for _, s := range elsif.Body.Statements {
			g.generateStatement(s)
		}
		g.indent--
	}

	if stmt.Else != nil {
		g.writeln("} else {")
		g.indent++
		for _, s := range stmt.Else.Statements {
			g.generateStatement(s)
		}
		g.indent--
	}
	g.writeln("}")
}

func (g *Generator) generateWhileStmt(stmt *ast.WhileStmt) {
	g.write(strings.Repeat("\t", g.indent))
	if stmt.Until {
		// until = пока НЕ выполняется условие
		g.write("for !(")
		g.generateExpression(stmt.Condition)
		g.write(").IsTrue() {\n")
	} else {
		// while = пока выполняется условие
		g.write("for (")
		g.generateExpression(stmt.Condition)
		g.write(").IsTrue() {\n")
	}
	g.indent++
	for _, s := range stmt.Body.Statements {
		g.generateStatement(s)
	}
	g.indent--
	g.writeln("}")
}

func (g *Generator) generateForStmt(stmt *ast.ForStmt) {
	g.write(strings.Repeat("\t", g.indent))
	g.write("for ")

	// Init
	if stmt.Init != nil {
		if decl, ok := stmt.Init.(*ast.VarDecl); ok && len(decl.Names) > 0 {
			name := g.varName(decl.Names[0])
			g.write(name + " := ")
			if decl.Value != nil {
				g.generateExpression(decl.Value)
			} else {
				g.write("svUndef()")
			}
		}
	}
	g.write("; ")

	// Condition
	if stmt.Condition != nil {
		g.write("(")
		g.generateExpression(stmt.Condition)
		g.write(").IsTrue()")
	}
	g.write("; ")

	// Post
	if stmt.Post != nil {
		g.generateExpression(stmt.Post)
	}

	g.write(" {\n")
	g.indent++
	for _, s := range stmt.Body.Statements {
		g.generateStatement(s)
	}
	g.indent--
	g.writeln("}")
}
func (g *Generator) generateForeachStmt(stmt *ast.ForeachStmt) {
	iterVar := g.varName(stmt.Variable)
	g.tempCount++
	listVar := fmt.Sprintf("_list%d", g.tempCount)
	idxVar := fmt.Sprintf("_i%d", g.tempCount)

	g.write(strings.Repeat("\t", g.indent))
	g.write(listVar + " := ")
	g.generateExpression(stmt.List)
	g.write("\n")

	g.writeln(fmt.Sprintf("for %s := 0; %s < len(%s.av); %s++ {", idxVar, idxVar, listVar, idxVar))
	g.indent++
	g.writeln(fmt.Sprintf("%s := %s.av[%s]", iterVar, listVar, idxVar))
	g.writeln("_ = " + iterVar)
	for _, s := range stmt.Body.Statements {
		g.generateStatement(s)
	}
	g.indent--
	g.writeln("}")
}

func (g *Generator) generateBlockStmt(stmt *ast.BlockStmt) {
	g.writeln("{")
	g.indent++
	for _, s := range stmt.Statements {
		g.generateStatement(s)
	}
	g.indent--
	g.writeln("}")
}

func (g *Generator) generateReturnStmt(stmt *ast.ReturnStmt) {
	g.write(strings.Repeat("\t", g.indent))
	g.write("return ")
	if stmt.Value != nil {
		g.generateExpression(stmt.Value)
	} else {
		g.write("svUndef()")
	}
	g.write("\n")
}

func (g *Generator) generateExpression(expr ast.Expression) {
	switch e := expr.(type) {
	case *ast.IntegerLiteral:
		g.write(fmt.Sprintf("svInt(%d)", e.Value))
	case *ast.FloatLiteral:
		g.write(fmt.Sprintf("svFloat(%f)", e.Value))
	case *ast.StringLiteral:
		if e.Interpolated {
			g.generateInterpolatedString(e.Value)
		} else {
			g.write(fmt.Sprintf("svStr(%q)", e.Value))
		}
	case *ast.ScalarVar:
		g.write(g.scalarName(e.Name))
	case *ast.ArrayVar:
		g.write(g.arrayName(e.Name))
	case *ast.HashVar:
		g.write(g.hashName(e.Name))
	case *ast.SpecialVar:
		if e.Name == "@_" {
			g.write("svArray(args...)")
		} else if e.Name == "$_" {
			g.write("v__") // default variable
		} else if len(e.Name) >= 2 && e.Name[0] == '$' && e.Name[1] >= '1' && e.Name[1] <= '9' {
			// Capture group $1, $2, ..., $99, etc.
			g.write(fmt.Sprintf("svStr(_getCapture(%s))", e.Name[1:]))
		} else {
			g.write("svUndef()")
		}
	case *ast.PrefixExpr:
		g.generatePrefixExpr(e)
	case *ast.PostfixExpr:
		g.generatePostfixExpr(e)
	case *ast.InfixExpr:
		g.generateInfixExpr(e)
	case *ast.AssignExpr:
		g.generateAssignExpr(e)
	case *ast.TernaryExpr:
		g.write("func() *SV { if (")
		g.generateExpression(e.Condition)
		g.write(").IsTrue() { return ")
		g.generateExpression(e.Then)
		g.write(" } else { return ")
		g.generateExpression(e.Else)
		g.write(" } }()")
	case *ast.CallExpr:
		g.generateCallExpr(e)
	case *ast.ArrayExpr:
		g.write("svArray(")
		for i, el := range e.Elements {
			if i > 0 {
				g.write(", ")
			}
			g.generateExpression(el)
		}
		g.write(")")
	case *ast.HashExpr:
		g.tempCount++
		hvar := fmt.Sprintf("_h%d", g.tempCount)
		g.write("func() *SV { " + hvar + " := svHash(); ")
		for _, p := range e.Pairs {
			g.write("svHSet(" + hvar + ", ")
			g.generateExpression(p.Key)
			g.write(", ")
			g.generateExpression(p.Value)
			g.write("); ")
		}
		g.write("return " + hvar + " }()")
	case *ast.ArrayAccess:
		g.write("svAGet(")
		// $arr[0] means access to @arr element
		if sv, ok := e.Array.(*ast.ScalarVar); ok {
			g.write(g.arrayName(sv.Name))
		} else {
			g.generateExpression(e.Array)
		}
		g.write(", ")
		g.generateExpression(e.Index)
		g.write(")")
	case *ast.HashAccess:
		g.write("svHGet(")
		// $h{key} means access to %h element
		if sv, ok := e.Hash.(*ast.ScalarVar); ok {
			g.write(g.hashName(sv.Name))
		} else {
			g.generateExpression(e.Hash)
		}
		g.write(", ")
		g.generateExpression(e.Key)
		g.write(")")
	case *ast.ArrowAccess:
		g.generateArrowAccess(e)
	case *ast.MethodCall:
		g.generateMethodCall(e)
	case *ast.Identifier:
		g.write(fmt.Sprintf("svStr(%q)", e.Value))
	case *ast.RangeExpr:
		g.generateRangeExpr(e)
	case *ast.UndefLiteral:
		g.write("svUndef()")
	case *ast.MatchExpr:
		g.generateMatchExpr(e)
	case *ast.SubstExpr:
		g.generateSubstExpr(e)
	case *ast.ReadLineExpr:
		g.generateReadLineExpr(e)
	case *ast.RefExpr:
		g.generateRefExpr(e)
	case *ast.DerefExpr:
		g.generateDerefExpr(e)
	default:
		g.write("svUndef()")
	}
}

func (g *Generator) generatePrefixExpr(expr *ast.PrefixExpr) {
	switch expr.Operator {
	case "-":
		g.write("svNeg(")
		g.generateExpression(expr.Right)
		g.write(")")
	case "!":
		g.write("svNot(")
		g.generateExpression(expr.Right)
		g.write(")")
	case "not":
		g.write("svNot(")
		g.generateExpression(expr.Right)
		g.write(")")
	case "++":
		// Pre-increment
		if v, ok := expr.Right.(*ast.ScalarVar); ok {
			name := g.scalarName(v.Name)
			g.write("func() *SV { " + name + " = svAdd(" + name + ", svInt(1)); return " + name + " }()")
		}
	case "--":
		if v, ok := expr.Right.(*ast.ScalarVar); ok {
			name := g.scalarName(v.Name)
			g.write("func() *SV { " + name + " = svSub(" + name + ", svInt(1)); return " + name + " }()")
		}
	default:
		g.generateExpression(expr.Right)
	}
}

func (g *Generator) generatePostfixExpr(expr *ast.PostfixExpr) {
	switch expr.Operator {
	case "++":
		if v, ok := expr.Left.(*ast.ScalarVar); ok {
			name := g.scalarName(v.Name)
			g.write("func() *SV { _t := " + name + "; " + name + " = svAdd(" + name + ", svInt(1)); return _t }()")
		}
	case "--":
		if v, ok := expr.Left.(*ast.ScalarVar); ok {
			name := g.scalarName(v.Name)
			g.write("func() *SV { _t := " + name + "; " + name + " = svSub(" + name + ", svInt(1)); return _t }()")
		}
	}
}

func (g *Generator) generateMethodCall(e *ast.MethodCall) {
	g.write("perl_method_call(")
	g.generateExpression(e.Object)
	g.write(fmt.Sprintf(", %q", e.Method))
	for _, arg := range e.Args {
		g.write(", ")
		g.generateExpression(arg)
	}
	g.write(")")
}

func (g *Generator) GenerateMethodCall_test(e *ast.MethodCall) {
	// Get the class/object
	// For Class->method(): Object is Identifier with class name
	// For $obj->method(): Object is ScalarVar

	var className string
	var isClassMethod bool

	switch obj := e.Object.(type) {
	case *ast.Identifier:
		// Class->method() - class method call
		className = obj.Value
		isClassMethod = true
	case *ast.ScalarVar:
		// $obj->method() - instance method call
		isClassMethod = false
	}

	// Generate function call
	methodName := strings.ReplaceAll(e.Method, "::", "_")

	if isClassMethod {
		// Class->new() becomes perl_Class_new(svStr("Class"), args...)
		g.write("perl_" + strings.ReplaceAll(className, "::", "_") + "_" + methodName + "(")
		g.write(fmt.Sprintf("svStr(%q)", className))
		for _, arg := range e.Args {
			g.write(", ")
			g.generateExpression(arg)
		}
		g.write(")")
	} else {
		// $obj->method() - need to look up method based on blessed package
		// For simplicity, we'll need runtime method dispatch
		// For now, generate direct call if we know the type
		g.write("perl_method_call(")
		g.generateExpression(e.Object)
		g.write(fmt.Sprintf(", %q", e.Method))
		for _, arg := range e.Args {
			g.write(", ")
			g.generateExpression(arg)
		}
		g.write(")")
	}
}

func (g *Generator) generateInfixExpr(expr *ast.InfixExpr) {
	op := expr.Operator
	switch op {
	case "+":
		g.write("svAdd(")
	case "-":
		g.write("svSub(")
	case "*":
		g.write("svMul(")
	case "/":
		g.write("svDiv(")
	case "%":
		g.write("svMod(")
	case "**":
		g.write("svPow(")
	case ".":
		g.write("svConcat(")
	case "x":
		g.write("svRepeat(")
	case "==":
		g.write("svNumEq(")
	case "!=":
		g.write("svNumNe(")
	case "<":
		g.write("svNumLt(")
	case "<=":
		g.write("svNumLe(")
	case ">":
		g.write("svNumGt(")
	case ">=":
		g.write("svNumGe(")
	case "eq":
		g.write("svStrEq(")
	case "ne":
		g.write("svStrNe(")
	case "lt":
		g.write("svStrLt(")
	case "le":
		g.write("svStrLe(")
	case "gt":
		g.write("svStrGt(")
	case "ge":
		g.write("svStrGe(")
	case "&&", "and":
		g.write("func() *SV { if (")
		g.generateExpression(expr.Left)
		g.write(").IsTrue() { return ")
		g.generateExpression(expr.Right)
		g.write(" }; return svInt(0) }()")
		return
	case "||", "or":
		g.write("func() *SV { if _v := ")
		g.generateExpression(expr.Left)
		g.write("; _v.IsTrue() { return _v }; return ")
		g.generateExpression(expr.Right)
		g.write(" }()")
		return
	case "//":
		g.write("func() *SV { if _v := ")
		g.generateExpression(expr.Left)
		g.write("; _v != nil && _v.flags != 0 { return _v }; return ")
		g.generateExpression(expr.Right)
		g.write(" }()")
		return
	default:
		g.write("svUndef(")
	}
	g.generateExpression(expr.Left)
	g.write(", ")
	g.generateExpression(expr.Right)
	g.write(")")
}

func (g *Generator) generateAssignExpr(expr *ast.AssignExpr) {
	switch left := expr.Left.(type) {
	case *ast.ScalarVar:
		name := g.scalarName(left.Name)
		switch expr.Operator {
		case "=":
			g.write(name + " = ")
			g.generateExpression(expr.Right)
		case "+=":
			g.write(name + " = svAdd(" + name + ", ")
			g.generateExpression(expr.Right)
			g.write(")")
		case "-=":
			g.write(name + " = svSub(" + name + ", ")
			g.generateExpression(expr.Right)
			g.write(")")
		case "*=":
			g.write(name + " = svMul(" + name + ", ")
			g.generateExpression(expr.Right)
			g.write(")")
		case "/=":
			g.write(name + " = svDiv(" + name + ", ")
			g.generateExpression(expr.Right)
			g.write(")")
		case ".=":
			g.write(name + " = svConcat(" + name + ", ")
			g.generateExpression(expr.Right)
			g.write(")")
		}
	case *ast.ArrayAccess:
		g.write("svASet(")
		if sv, ok := left.Array.(*ast.ScalarVar); ok {
			g.write(g.arrayName(sv.Name))
		} else {
			g.generateExpression(left.Array)
		}
		g.write(", ")
		g.generateExpression(left.Index)
		g.write(", ")
		g.generateExpression(expr.Right)
		g.write(")")
	case *ast.HashAccess:
		g.write("svHSet(")
		if sv, ok := left.Hash.(*ast.ScalarVar); ok {
			g.write(g.hashName(sv.Name))
		} else {
			g.generateExpression(left.Hash)
		}
		g.write(", ")
		g.generateExpression(left.Key)
		g.write(", ")
		g.generateExpression(expr.Right)
		g.write(")")
	case *ast.ArrowAccess:
		// $ref->{"key"} = value or $ref->[idx] = value
		switch acc := left.Right.(type) {
		case *ast.HashAccess:
			g.write("svHSet(")
			g.generateExpression(left.Left)
			g.write(", ")
			g.generateExpression(acc.Key)
			g.write(", ")
			g.generateExpression(expr.Right)
			g.write(")")
		case *ast.ArrayAccess:
			g.write("svASet(")
			g.generateExpression(left.Left)
			g.write(", ")
			g.generateExpression(acc.Index)
			g.write(", ")
			g.generateExpression(expr.Right)
			g.write(")")
		}
	case *ast.DerefExpr:
		// $$ref = value - присваивание через разыменование скаляра
		if left.Sigil == "$" {
			g.write("func() *SV { ")
			g.write("_ref := ")
			g.generateExpression(left.Value)
			g.write("; ")
			g.write("_val := ")
			g.generateExpression(expr.Right)
			g.write("; ")
			g.write("if _ref != nil && len(_ref.av) > 0 { ")
			g.write("_ref.av[0].iv = _val.iv; ")
			g.write("_ref.av[0].nv = _val.nv; ")
			g.write("_ref.av[0].pv = _val.pv; ")
			g.write("_ref.av[0].flags = _val.flags; ")
			g.write("}; return _val }()")
			return
		}
		g.generateExpression(expr.Right)
	}
}

func (g *Generator) generateCallExpr(expr *ast.CallExpr) {
	if ident, ok := expr.Function.(*ast.Identifier); ok {
		name := ident.Value
		switch name {
		case "print":
			// Check if first arg is filehandle
			if len(expr.Args) >= 2 {
				if _, ok := expr.Args[0].(*ast.ScalarVar); ok {
					// print $fh "text" form
					g.write("perlPrintFH(")
					g.generateExpression(expr.Args[0])
					g.write(".AsString()")
					for _, a := range expr.Args[1:] {
						g.write(", ")
						g.generateExpression(a)
					}
					g.write(")")
					return
				}
			}
			g.write("perlPrint(")
			for i, a := range expr.Args {
				if i > 0 {
					g.write(", ")
				}
				g.generateExpression(a)
			}
			g.write(")")
		case "say":
			// Check if first arg is filehandle
			if len(expr.Args) >= 2 {
				if _, ok := expr.Args[0].(*ast.ScalarVar); ok {
					// say $fh "text" form
					g.write("perlSayFH(")
					g.generateExpression(expr.Args[0])
					g.write(".AsString()")
					for _, a := range expr.Args[1:] {
						g.write(", ")
						g.generateExpression(a)
					}
					g.write(")")
					return
				}
			}
			g.write("perlSay(")
			for i, a := range expr.Args {
				if i > 0 {
					g.write(", ")
				}
				g.generateExpression(a)
			}
			g.write(")")
		case "push":
			if len(expr.Args) >= 1 {
				if av, ok := expr.Args[0].(*ast.ArrayVar); ok {
					g.write("svPush(" + g.arrayName(av.Name))
					for _, a := range expr.Args[1:] {
						g.write(", ")
						g.generateExpression(a)
					}
					g.write(")")
					return
				}
			}
			g.write("svUndef()")
		case "pop":
			if len(expr.Args) >= 1 {
				if av, ok := expr.Args[0].(*ast.ArrayVar); ok {
					g.write("svPop(" + g.arrayName(av.Name) + ")")
					return
				}
			}
			g.write("svUndef()")
		case "shift":
			if len(expr.Args) >= 1 {
				if av, ok := expr.Args[0].(*ast.ArrayVar); ok {
					g.write("svShift(" + g.arrayName(av.Name) + ")")
					return
				}
			}
			g.write("svShift(_args)")
		case "unshift":
			if len(expr.Args) >= 1 {
				if av, ok := expr.Args[0].(*ast.ArrayVar); ok {
					g.write("svUnshift(" + g.arrayName(av.Name))
					for _, a := range expr.Args[1:] {
						g.write(", ")
						g.generateExpression(a)
					}
					g.write(")")
					return
				}
			}
			g.write("svUndef()")
		case "length":
			if len(expr.Args) >= 1 {
				g.write("perlLength(")
				g.generateExpression(expr.Args[0])
				g.write(")")
			} else {
				g.write("svInt(0)")
			}
		case "uc":
			g.write("perlUc(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "lc":
			g.write("perlLc(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "abs":
			g.write("perlAbs(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "int":
			g.write("perlInt(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "sqrt":
			g.write("perlSqrt(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "chr":
			g.write("perlChr(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "ord":
			g.write("perlOrd(")
			g.generateExpression(expr.Args[0])
			g.write(")")
		case "scalar":
			if len(expr.Args) >= 1 {
				g.write("perl_scalar(")
				g.generateExpression(expr.Args[0])
				g.write(")")
			} else {
				g.write("svUndef()")
			}
		case "keys":
			if len(expr.Args) >= 1 {
				g.write("perl_keys(")
				g.generateExpression(expr.Args[0])
				g.write(")")
			} else {
				g.write("svArray()")
			}
		case "join":
			if len(expr.Args) >= 2 {
				g.write("perl_join(")
				g.generateExpression(expr.Args[0])
				g.write(", ")
				g.generateExpression(expr.Args[1])
				g.write(")")
			} else {
				g.write("svStr(\"\")")
			}
		case "ref":
			if len(expr.Args) >= 1 {
				g.write("perl_ref(")
				g.generateExpression(expr.Args[0])
				g.write(")")
			} else {
				g.write("svStr(\"\")")
			}
		case "open":
			if len(expr.Args) >= 2 {
				g.write("perlOpen(")
				g.generateExpression(expr.Args[0])
				g.write(".AsString(), ")
				g.generateExpression(expr.Args[1])
				g.write(".AsString(), ")
				if len(expr.Args) >= 3 && expr.Args[2] != nil {
					g.generateExpression(expr.Args[2])
					g.write(".AsString()")
				} else {
					g.write("\"\"")
				}
				g.write(")")
			}
		case "close":
			if len(expr.Args) >= 1 {
				g.write("perlClose(")
				g.generateExpression(expr.Args[0])
				g.write(".AsString())")
			}
		case "delete":
			// delete $h{key} - нужно получить хеш и ключ
			if len(expr.Args) >= 1 {
				if ha, ok := expr.Args[0].(*ast.HashAccess); ok {
					g.write("func() *SV { ")
					// Получаем хеш
					hashName := ""
					if sv, ok := ha.Hash.(*ast.ScalarVar); ok {
						hashName = g.hashName(sv.Name)
					} else {
						g.tempCount++
						hashName = fmt.Sprintf("_htmp%d", g.tempCount)
						g.write(hashName + " := ")
						g.generateExpression(ha.Hash)
						g.write("; ")
					}
					// Получаем ключ
					g.write("_k := ")
					g.generateExpression(ha.Key)
					g.write(".AsString(); ")
					// Сохраняем старое значение
					g.write("_v := " + hashName + ".hv[_k]; ")
					// Удаляем
					g.write("delete(" + hashName + ".hv, _k); ")
					// Возвращаем старое значение
					g.write("return _v }()")
					return
				}
			}
			g.write("svUndef()")
		default:
			// User-defined function
			//g.write("perl_" + name + "(")
			g.write("perl_" + strings.ReplaceAll(name, "::", "_") + "(")
			for i, a := range expr.Args {
				if i > 0 {
					g.write(", ")
				}
				g.generateExpression(a)
			}
			g.write(")")
		}
	}
}

func (g *Generator) generateArrowAccess(expr *ast.ArrowAccess) {
	switch right := expr.Right.(type) {
	case *ast.ArrayAccess:
		g.write("svAGet(")
		g.generateExpression(expr.Left)
		g.write(", ")
		g.generateExpression(right.Index)
		g.write(")")
	case *ast.HashAccess:
		g.write("svHGet(")
		g.generateExpression(expr.Left)
		g.write(", ")
		g.generateExpression(right.Key)
		g.write(")")
	default:
		g.generateExpression(expr.Left)
	}
}

func (g *Generator) generateRangeExpr(expr *ast.RangeExpr) {
	g.write("func() *SV { var _r []*SV; for _i := int(")
	g.generateExpression(expr.Start)
	g.write(".AsInt()); _i <= int(")
	g.generateExpression(expr.End)
	g.write(".AsInt()); _i++ { _r = append(_r, svInt(int64(_i))) }; return svArray(_r...) }()")
}

func (g *Generator) generateInterpolatedString(s string) {
	// Build concatenation expression
	g.write("func() *SV { var _s string; ")

	i := 0
	for i < len(s) {
		if s[i] == '$' {
			// Find variable name
			j := i + 1
			if j < len(s) && s[j] == '{' {
				// ${var}
				k := j + 1
				for k < len(s) && s[k] != '}' {
					k++
				}
				varName := s[j+1 : k]
				g.write("_s += " + g.scalarName(varName) + ".AsString(); ")
				i = k + 1
			} else {
				// $var
				for j < len(s) && (isAlnum(s[j]) || s[j] == '_') {
					j++
				}
				varName := s[i+1 : j]
				if varName != "" {
					// Check if it's a capture group $1, $2, etc.
					if len(varName) > 0 && varName[0] >= '1' && varName[0] <= '9' {
						g.write("_s += _getCapture(" + varName + "); ")
					} else {
						g.write("_s += " + g.scalarName(varName) + ".AsString(); ")
					}
				}
				i = j
			}
		} else {
			// Literal text
			j := i
			for j < len(s) && s[j] != '$' {
				j++
			}
			g.write(fmt.Sprintf("_s += %q; ", s[i:j]))
			i = j
		}
	}

	g.write("return svStr(_s) }()")
}

func (g *Generator) generateMatchExpr(expr *ast.MatchExpr) {
	pattern := expr.Pattern.Pattern
	flags := expr.Pattern.Flags

	// Add case-insensitive flag if needed
	rePattern := pattern
	if strings.Contains(flags, "i") {
		rePattern = "(?i)" + rePattern
	}

	if expr.Negate {
		g.write("func() *SV { re := regexp.MustCompile(`" + rePattern + "`); _m := re.FindStringSubmatch(")
		g.generateExpression(expr.Target)
		g.write(".AsString()); if _m != nil { _captures = _m[1:]; return svInt(0) }; return svInt(1) }()")
	} else {
		g.write("func() *SV { re := regexp.MustCompile(`" + rePattern + "`); _m := re.FindStringSubmatch(")
		g.generateExpression(expr.Target)
		g.write(".AsString()); if _m != nil { _captures = _m[1:]; return svInt(1) }; return svInt(0) }()")
	}
}

func (g *Generator) varName(expr ast.Expression) string {
	switch v := expr.(type) {
	case *ast.ScalarVar:
		return "v_" + v.Name
	case *ast.ArrayVar:
		return "a_" + v.Name
	case *ast.HashVar:
		return "h_" + v.Name
	}
	return "_"
}

func (g *Generator) scalarName(name string) string {
	return "v_" + name
}

func (g *Generator) arrayName(name string) string {
	return "a_" + name
}

func (g *Generator) hashName(name string) string {
	return "h_" + name
}

func (g *Generator) generateSubstExpr(expr *ast.SubstExpr) {
	pattern := expr.Pattern
	replacement := expr.Replacement
	flags := expr.Flags

	rePattern := pattern
	if strings.Contains(flags, "i") {
		rePattern = "(?i)" + rePattern
	}

	// Get variable name
	varName := ""
	if v, ok := expr.Target.(*ast.ScalarVar); ok {
		varName = g.scalarName(v.Name)
	}

	if strings.Contains(flags, "g") {
		// Global replace with capture support
		g.write("func() *SV { re := regexp.MustCompile(`" + rePattern + "`); ")
		g.write("_old := " + varName + ".AsString(); ")
		g.write("_new := re.ReplaceAllStringFunc(_old, func(_match string) string { ")
		g.write("_m := re.FindStringSubmatch(_match); _captures = _m[1:]; ")
		g.write("_r := `" + replacement + "`; ")
		// Replace $1, $2 etc in replacement
		g.write("for _i := len(_captures); _i >= 1; _i-- { _r = strings.ReplaceAll(_r, fmt.Sprintf(\"$%d\", _i), _getCapture(_i)) }; ")
		g.write("return _r }); ")
		g.write(varName + " = svStr(_new); ")
		g.write("if _old != _new { return svInt(1) }; return svInt(0) }()")
	} else {
		// Single replace with capture support
		g.write("func() *SV { re := regexp.MustCompile(`" + rePattern + "`); ")
		g.write("_old := " + varName + ".AsString(); ")
		g.write("_m := re.FindStringSubmatch(_old); ")
		g.write("if _m != nil { _captures = _m[1:]; ")
		g.write("_loc := re.FindStringIndex(_old); ")
		g.write("_r := `" + replacement + "`; ")
		g.write("for _i := len(_captures); _i >= 1; _i-- { _r = strings.ReplaceAll(_r, fmt.Sprintf(\"$%d\", _i), _getCapture(_i)) }; ")
		g.write(varName + " = svStr(_old[:_loc[0]] + _r + _old[_loc[1]:]); return svInt(1) }; ")
		g.write("return svInt(0) }()")
	}
}

func (g *Generator) generateReadLineExpr(expr *ast.ReadLineExpr) {
	var name string
	if expr.Filehandle != nil {
		switch fh := expr.Filehandle.(type) {
		case *ast.Identifier:
			name = fh.Value
		case *ast.ScalarVar:
			name = fh.Name // НЕ добавляем "v_" prefix!
		}
	}

	if name == "" {
		g.write("perlReadLine(\"\")")
	} else {
		g.write("perlReadLine(\"" + name + "\")")
	}
}

func (g *Generator) generateOpenStatement(expr *ast.CallExpr) {
	if len(expr.Args) < 2 {
		return
	}

	// Declare or assign filehandle variable
	if sv, ok := expr.Args[0].(*ast.ScalarVar); ok {
		name := g.scalarName(sv.Name)
		if !g.declaredVars[name] {
			g.writeln(name + " := svStr(\"" + sv.Name + "\")")
			g.writeln("_ = " + name)
			g.declaredVars[name] = true
		} else {
			g.writeln(name + " = svStr(\"" + sv.Name + "\")")
		}
	}

	// Call perlOpen
	g.write(strings.Repeat("\t", g.indent))
	g.write("perlOpen(")
	g.generateExpression(expr.Args[0])
	g.write(".AsString(), ")
	g.generateExpression(expr.Args[1])
	g.write(".AsString(), ")
	if len(expr.Args) >= 3 && expr.Args[2] != nil {
		g.generateExpression(expr.Args[2])
		g.write(".AsString()")
	} else {
		g.write("\"\"")
	}
	g.write(")\n")
}

func (g *Generator) generateRefExpr(expr *ast.RefExpr) {
	// \$scalar - ссылка на скаляр
	if sv, ok := expr.Value.(*ast.ScalarVar); ok {
		g.write("svRef(" + g.scalarName(sv.Name) + ")")
		return
	}

	// \@array - ссылка на массив
	if av, ok := expr.Value.(*ast.ArrayVar); ok {
		g.write(g.arrayName(av.Name))
		return
	}

	// \%hash - ссылка на хеш
	if hv, ok := expr.Value.(*ast.HashVar); ok {
		g.write(g.hashName(hv.Name))
		return
	}

	// Для других выражений
	g.write("svUndef()")
}

func (g *Generator) generateDerefExpr(expr *ast.DerefExpr) {
	switch expr.Sigil {
	case "$":
		// $$ref - разыменование скаляра
		g.write("svDeref(")
		g.generateExpression(expr.Value)
		g.write(")")
	case "@":
		// @$ref - разыменование массива
		g.generateExpression(expr.Value)
	case "%":
		// %$ref - разыменование хеша
		g.generateExpression(expr.Value)
	default:
		g.write("svUndef()")
	}
}

func isAlnum(c byte) bool {
	return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')
}
```

## File: ./pkg/compiler/compiler.go
```go
// pkg/compiler/compiler.go
package compiler

import (
	"fmt"
	"os"
	"strings"

	"perlc/pkg/ast"
	"perlc/pkg/codegen"
	"perlc/pkg/deps"
	"perlc/pkg/lexer"
	"perlc/pkg/parser"
	"perlc/pkg/xs2go"
)

// Cache для скомпилированных модулей
var moduleCache = make(map[string]string)

// Compile компилирует Perl файл в Go код
func Compile(perlFile string) (string, error) {
	content, err := os.ReadFile(perlFile)
	if err != nil {
		return "", err
	}

	// Используем наш парсер
	l := lexer.New(string(content))
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		return "", fmt.Errorf("parse errors: %v", p.Errors())
	}

	// Собираем все use
	modules := collectModules(program)

	// Обрабатываем каждый модуль
	var moduleCode strings.Builder
	for _, mod := range modules {
		code, err := processModule(mod)
		if err != nil {
			// Предупреждаем, но продолжаем
			fmt.Fprintf(os.Stderr, "Warning: could not process module %s: %v\n", mod, err)
			continue
		}
		moduleCode.WriteString(code)
	}

	// Генерируем основной код
	gen := codegen.New()
	mainCode := gen.Generate(program)

	// Собираем всё вместе
	return combineCode(moduleCode.String(), mainCode), nil
}

// collectModules собирает все use декларации из программы
func collectModules(program *ast.Program) []string {
	var modules []string

	for _, stmt := range program.Statements {
		if use, ok := stmt.(*ast.UseDecl); ok {
			modules = append(modules, use.Module)
		}
	}

	return modules
}

// processModule обрабатывает один модуль
func processModule(moduleName string) (string, error) {
	// Проверяем кэш
	if cached, ok := moduleCache[moduleName]; ok {
		return cached, nil
	}

	// Стандартные модули пропускаем
	if isStandardModule(moduleName) {
		return "", nil
	}

	// Проверяем кэш на диске
	if cached, ok := deps.GetCachedModule(moduleName, "latest"); ok {
		moduleCache[moduleName] = cached
		return cached, nil
	}

	// Ищем и анализируем модуль
	info, err := deps.AnalyzeModule(moduleName)
	if err != nil {
		return "", err
	}

	var code strings.Builder

	// Транслируем XS → Go если есть
	if info.HasXS {
		translator := xs2go.New()
		for _, xsFile := range info.XSFiles {
			part, err := translator.Translate(xsFile)
			if err != nil {
				return "", fmt.Errorf("XS translation failed for %s: %w", xsFile, err)
			}
			code.WriteString(part)
			code.WriteString("\n")
		}
	}

	// Транслируем Pure Perl части
	for _, pmFile := range info.PurePerl {
		part, err := compilePerl(pmFile)
		if err != nil {
			return "", fmt.Errorf("Perl compilation failed for %s: %w", pmFile, err)
		}
		code.WriteString(part)
		code.WriteString("\n")
	}

	// Рекурсивно обрабатываем зависимости
	for _, dep := range info.Dependencies {
		depCode, err := processModule(dep)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Warning: could not process dependency %s: %v\n", dep, err)
			continue
		}
		code.WriteString(depCode)
	}

	result := code.String()

	// Сохраняем в кэш
	moduleCache[moduleName] = result
	deps.CacheModule(moduleName, "latest", result)

	return result, nil
}

// compilePerl компилирует .pm файл в Go код
func compilePerl(pmFile string) (string, error) {
	content, err := os.ReadFile(pmFile)
	if err != nil {
		return "", err
	}

	l := lexer.New(string(content))
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		return "", fmt.Errorf("parse errors: %v", p.Errors())
	}

	gen := codegen.New()
	return gen.Generate(program), nil
}

// isStandardModule проверяет, является ли модуль стандартным
func isStandardModule(name string) bool {
	standard := map[string]bool{
		"strict":         true,
		"warnings":       true,
		"feature":        true,
		"utf8":           true,
		"vars":           true,
		"constant":       true,
		"Exporter":       true,
		"Carp":           true,
		"Data::Dumper":   true,
		"File::Spec":     true,
		"File::Path":     true,
		"File::Basename": true,
		"Getopt::Long":   true,
		"Pod::Usage":     true,
	}
	return standard[name]
}

// combineCode объединяет код модулей и основной код
func combineCode(moduleCode, mainCode string) string {
	if moduleCode == "" {
		return mainCode
	}

	var result strings.Builder

	// Модули идут первыми (без package main и import)
	result.WriteString("// === Compiled Modules ===\n")
	result.WriteString(moduleCode)
	result.WriteString("\n// === Main Program ===\n")
	result.WriteString(mainCode)

	return result.String()
}
```

## File: ./pkg/context/context.go
```go
// Package context implements Perl's runtime context and interpreter state.
// Paket context, Perl'in çalışma zamanı bağlamını ve yorumlayıcı durumunu uygular.
//
// This includes call stack, dynamic scoping, special variables, and error handling.
// Bu, çağrı yığını, dinamik kapsam, özel değişkenler ve hata işlemeyi içerir.
package context

import (
	"fmt"
	"os"
	"sync"

	"perlc/pkg/cv"
	"perlc/pkg/stash"
	"perlc/pkg/sv"
)

// Runtime represents the Perl interpreter state.
// Runtime, Perl yorumlayıcı durumunu temsil eder.
type Runtime struct {
	mu sync.RWMutex

	// Call stack for caller() and stack traces
	// caller() ve yığın izleri için çağrı yığını
	callStack []*StackFrame

	// Dynamic scope stack for local() variables
	// local() değişkenleri için dinamik kapsam yığını
	localStack []*LocalFrame

	// Current package
	// Geçerli paket
	curPackage string

	// Special variables (most are per-interpreter)
	// Özel değişkenler (çoğu yorumlayıcı başına)
	specials *SpecialVars

	// Hints and warnings state
	// İpuçları ve uyarı durumu
	hints *Hints

	// Error handling state
	// Hata işleme durumu
	evalError *sv.SV // $@
	osError   *sv.SV // $!
	childErr  *sv.SV // $?

	// Eval depth (for nested eval detection)
	// Eval derinliği (iç içe eval tespiti için)
	evalDepth int

	// Die/warn handlers
	// Die/warn işleyicileri
	dieHandler  *sv.SV // $SIG{__DIE__}
	warnHandler *sv.SV // $SIG{__WARN__}
}

// StackFrame represents a single call stack entry.
// StackFrame, tek bir çağrı yığını girdisini temsil eder.
type StackFrame struct {
	CV        *cv.CV   // The subroutine being called / Çağrılan altyordam
	Package   string   // Package context / Paket bağlamı
	File      string   // Source file / Kaynak dosya
	Line      int      // Source line / Kaynak satır
	Sub       string   // Subroutine name / Altyordam adı
	Args      []*sv.SV // @_ for this call / Bu çağrı için @_
	WantArray int      // Context: -1=void, 0=scalar, 1=list / Bağlam
	HasArgs   bool     // Whether @_ is available / @_ mevcut mu
	IsEval    bool     // Is this an eval frame? / Bu bir eval çerçevesi mi?
	EvalText  string   // For eval STRING / eval STRING için
}

// LocalFrame holds local() variable saves for one scope.
// LocalFrame, bir kapsam için local() değişken kayıtlarını tutar.
type LocalFrame struct {
	Saves []LocalSave
}

// LocalSave represents one local() save.
// LocalSave, bir local() kaydını temsil eder.
type LocalSave struct {
	GlobName string // Full glob name (Pkg::name) / Tam glob adı
	Slot     string // "SCALAR", "ARRAY", "HASH", "CODE" / Slot türü
	Value    *sv.SV // Saved value / Kaydedilen değer
}

// SpecialVars holds Perl's special variables.
// SpecialVars, Perl'in özel değişkenlerini tutar.
type SpecialVars struct {
	mu sync.RWMutex

	// Input/Output
	underscore *sv.SV // $_
	inputRS    *sv.SV // $/ (input record separator)
	outputRS   *sv.SV // $\ (output record separator)
	outputFS   *sv.SV // $, (output field separator)
	listSep    *sv.SV // $" (list separator)

	// Regex match results
	// Regex eşleşme sonuçları
	match     *sv.SV   // $& (entire match)
	preMath   *sv.SV   // $` (before match)
	postMatch *sv.SV   // $' (after match)
	lastParen *sv.SV   // $+ (last bracket)
	captures  []*sv.SV // $1, $2, $3... (capture groups)

	// Process info
	// Süreç bilgisi
	pid      *sv.SV // $$
	uid      *sv.SV // $
	euid     *sv.SV // $>
	gid      *sv.SV // $(
	egid     *sv.SV // $)
	progName *sv.SV // $0

	// Misc
	// Çeşitli
	subsep      *sv.SV // $; (subscript separator)
	format      *sv.SV // $~ (format name)
	accumulator *sv.SV // $^A (format accumulator)
}

// Hints holds pragma/hints state.
// Hints, pragma/ipucu durumunu tutar.
type Hints struct {
	Strict   StrictFlags
	Warnings WarningFlags
	Features FeatureFlags
	HintBits uint32
}

// StrictFlags for 'use strict'.
// 'use strict' için StrictFlags.
type StrictFlags uint8

const (
	StrictRefs StrictFlags = 1 << iota // strict 'refs'
	StrictVars                         // strict 'vars'
	StrictSubs                         // strict 'subs'
)

// WarningFlags for 'use warnings'.
// 'use warnings' için WarningFlags.
type WarningFlags uint32

const (
	WarnAll WarningFlags = 1 << iota
	WarnClosure
	WarnDeprecated
	WarnExiting
	WarnGlob
	WarnIO
	WarnMisc
	WarnNumeric
	WarnOnce
	WarnOverflow
	WarnPack
	WarnPortable
	WarnRecursion
	WarnRedefine
	WarnRegexp
	WarnSevere
	WarnSignal
	WarnSubstr
	WarnSyntax
	WarnTaint
	WarnUninitialized
	WarnUnpack
	WarnUntie
	WarnUtf8
	WarnVoid
)

// FeatureFlags for 'use feature'.
// 'use feature' için FeatureFlags.
type FeatureFlags uint32

const (
	FeatureSay FeatureFlags = 1 << iota
	FeatureState
	FeatureSwitch
	FeatureUnicode
	FeatureFC
	FeatureSignatures
)

// ============================================================
// Global Runtime Instance
// Global Runtime Örneği
// ============================================================

var (
	globalRuntime *Runtime
	runtimeOnce   sync.Once
)

// GetRuntime returns the global runtime instance.
// GetRuntime, global runtime örneğini döndürür.
func GetRuntime() *Runtime {
	runtimeOnce.Do(func() {
		globalRuntime = NewRuntime()
	})
	return globalRuntime
}

// NewRuntime creates a new runtime instance.
// NewRuntime, yeni bir runtime örneği oluşturur.
func NewRuntime() *Runtime {
	rt := &Runtime{
		curPackage: "main",
		specials:   newSpecialVars(),
		hints:      &Hints{},
		evalError:  sv.NewUndef(),
		osError:    sv.NewUndef(),
		childErr:   sv.NewUndef(),
	}
	return rt
}

func newSpecialVars() *SpecialVars {
	sp := &SpecialVars{
		underscore: sv.NewUndef(),
		inputRS:    sv.NewString("\n"),
		outputRS:   sv.NewString(""),
		outputFS:   sv.NewString(""),
		listSep:    sv.NewString(" "),
		subsep:     sv.NewString("\034"),
		pid:        sv.NewInt(int64(os.Getpid())),
		progName:   sv.NewString(os.Args[0]),
		captures:   make([]*sv.SV, 0),
	}
	return sp
}

// ============================================================
// Call Stack Management
// Çağrı Yığını Yönetimi
// ============================================================

// PushCall pushes a new call frame onto the stack.
// PushCall, yığına yeni bir çağrı çerçevesi ekler.
func (rt *Runtime) PushCall(frame *StackFrame) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.callStack = append(rt.callStack, frame)
}

// PopCall removes and returns the top call frame.
// PopCall, en üstteki çağrı çerçevesini kaldırır ve döndürür.
func (rt *Runtime) PopCall() *StackFrame {
	rt.mu.Lock()
	defer rt.mu.Unlock()

	if len(rt.callStack) == 0 {
		return nil
	}

	frame := rt.callStack[len(rt.callStack)-1]
	rt.callStack = rt.callStack[:len(rt.callStack)-1]
	return frame
}

// CurrentFrame returns the current (top) call frame.
// CurrentFrame, geçerli (en üst) çağrı çerçevesini döndürür.
func (rt *Runtime) CurrentFrame() *StackFrame {
	rt.mu.RLock()
	defer rt.mu.RUnlock()

	if len(rt.callStack) == 0 {
		return nil
	}
	return rt.callStack[len(rt.callStack)-1]
}

// Caller returns call frame N levels up (0 = current).
// Perl's caller() function.
//
// Caller, N seviye üstteki çağrı çerçevesini döndürür (0 = geçerli).
// Perl'in caller() fonksiyonu.
func (rt *Runtime) Caller(level int) *StackFrame {
	rt.mu.RLock()
	defer rt.mu.RUnlock()

	idx := len(rt.callStack) - 1 - level
	if idx < 0 || idx >= len(rt.callStack) {
		return nil
	}
	return rt.callStack[idx]
}

// CallDepth returns current call stack depth.
// CallDepth, geçerli çağrı yığını derinliğini döndürür.
func (rt *Runtime) CallDepth() int {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return len(rt.callStack)
}

// StackTrace returns full stack trace as string.
// StackTrace, tam yığın izini string olarak döndürür.
func (rt *Runtime) StackTrace() string {
	rt.mu.RLock()
	defer rt.mu.RUnlock()

	result := ""
	for i := len(rt.callStack) - 1; i >= 0; i-- {
		f := rt.callStack[i]
		result += fmt.Sprintf("  %s::%s at %s line %d\n",
			f.Package, f.Sub, f.File, f.Line)
	}
	return result
}

// ============================================================
// Dynamic Scope (local)
// Dinamik Kapsam (local)
// ============================================================

// PushLocal creates a new local scope.
// PushLocal, yeni bir local kapsamı oluşturur.
func (rt *Runtime) PushLocal() {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.localStack = append(rt.localStack, &LocalFrame{})
}

// PopLocal restores all local() variables for current scope.
// PopLocal, geçerli kapsam için tüm local() değişkenlerini geri yükler.
func (rt *Runtime) PopLocal() {
	rt.mu.Lock()
	defer rt.mu.Unlock()

	if len(rt.localStack) == 0 {
		return
	}

	frame := rt.localStack[len(rt.localStack)-1]
	rt.localStack = rt.localStack[:len(rt.localStack)-1]

	// Restore saved values in reverse order
	// Kaydedilen değerleri ters sırada geri yükle
	for i := len(frame.Saves) - 1; i >= 0; i-- {
		save := frame.Saves[i]
		rt.restoreLocal(save)
	}
}

// LocalScalar implements local($var) - saves current value.
// LocalScalar, local($var) uygular - geçerli değeri kaydeder.
func (rt *Runtime) LocalScalar(fullName string) {
	rt.mu.Lock()
	defer rt.mu.Unlock()

	if len(rt.localStack) == 0 {
		rt.localStack = append(rt.localStack, &LocalFrame{})
	}

	frame := rt.localStack[len(rt.localStack)-1]
	gv := stash.Resolve(fullName)

	save := LocalSave{
		GlobName: fullName,
		Slot:     "SCALAR",
		Value:    gv.Scalar().Copy(),
	}
	frame.Saves = append(frame.Saves, save)

	// Set to undef for local
	// local için undef'e ayarla
	gv.SetScalar(sv.NewUndef())
}

// LocalArray implements local(@var).
// LocalArray, local(@var) uygular.
func (rt *Runtime) LocalArray(fullName string) {
	rt.mu.Lock()
	defer rt.mu.Unlock()

	if len(rt.localStack) == 0 {
		rt.localStack = append(rt.localStack, &LocalFrame{})
	}

	frame := rt.localStack[len(rt.localStack)-1]
	gv := stash.Resolve(fullName)

	save := LocalSave{
		GlobName: fullName,
		Slot:     "ARRAY",
		Value:    gv.Array(),
	}
	if save.Value != nil {
		save.Value.IncRef()
	}
	frame.Saves = append(frame.Saves, save)

	// Set to empty array
	// Boş diziye ayarla
	gv.SetArray(sv.NewArrayRef().Deref())
}

// LocalHash implements local(%var).
// LocalHash, local(%var) uygular.
func (rt *Runtime) LocalHash(fullName string) {
	rt.mu.Lock()
	defer rt.mu.Unlock()

	if len(rt.localStack) == 0 {
		rt.localStack = append(rt.localStack, &LocalFrame{})
	}

	frame := rt.localStack[len(rt.localStack)-1]
	gv := stash.Resolve(fullName)

	save := LocalSave{
		GlobName: fullName,
		Slot:     "HASH",
		Value:    gv.Hash(),
	}
	if save.Value != nil {
		save.Value.IncRef()
	}
	frame.Saves = append(frame.Saves, save)

	// Set to empty hash
	// Boş hash'e ayarla
	gv.SetHash(sv.NewHashRef().Deref())
}

func (rt *Runtime) restoreLocal(save LocalSave) {
	gv := stash.Resolve(save.GlobName)

	switch save.Slot {
	case "SCALAR":
		gv.SetScalar(save.Value)
	case "ARRAY":
		gv.SetArray(save.Value)
	case "HASH":
		gv.SetHash(save.Value)
	case "CODE":
		gv.SetCode(save.Value)
	}
}

// ============================================================
// Special Variables Access
// Özel Değişken Erişimi
// ============================================================

// Underscore returns $_.
// Underscore, $_ döndürür.
func (rt *Runtime) Underscore() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.underscore
}

// SetUnderscore sets $_.
// SetUnderscore, $_ ayarlar.
func (rt *Runtime) SetUnderscore(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.underscore = v
}

// InputRS returns $/ (input record separator).
// InputRS, $/ (girdi kayıt ayırıcı) döndürür.
func (rt *Runtime) InputRS() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.inputRS
}

// SetInputRS sets $/.
// SetInputRS, $/ ayarlar.
func (rt *Runtime) SetInputRS(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.inputRS = v
}

// OutputRS returns $\ (output record separator).
// OutputRS, $\ (çıktı kayıt ayırıcı) döndürür.
func (rt *Runtime) OutputRS() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.outputRS
}

// SetOutputRS sets $\.
// SetOutputRS, $\ ayarlar.
func (rt *Runtime) SetOutputRS(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.outputRS = v
}

// OutputFS returns $, (output field separator).
// OutputFS, $, (çıktı alan ayırıcı) döndürür.
func (rt *Runtime) OutputFS() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.outputFS
}

// ListSep returns $" (list separator for interpolation).
// ListSep, $" (interpolasyon için liste ayırıcı) döndürür.
func (rt *Runtime) ListSep() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.listSep
}

// PID returns $$.
// PID, $$ döndürür.
func (rt *Runtime) PID() *sv.SV {
	return rt.specials.pid
}

// ProgName returns $0.
// ProgName, $0 döndürür.
func (rt *Runtime) ProgName() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	return rt.specials.progName
}

// SetProgName sets $0.
// SetProgName, $0 ayarlar.
func (rt *Runtime) SetProgName(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.progName = v
}

// ============================================================
// Regex Match Variables
// Regex Eşleşme Değişkenleri
// ============================================================

// SetMatchVars sets regex match result variables.
// SetMatchVars, regex eşleşme sonuç değişkenlerini ayarlar.
func (rt *Runtime) SetMatchVars(match, preMath, postMatch string, captures []string) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()

	rt.specials.match = sv.NewString(match)
	rt.specials.preMath = sv.NewString(preMath)
	rt.specials.postMatch = sv.NewString(postMatch)

	rt.specials.captures = make([]*sv.SV, len(captures))
	for i, c := range captures {
		rt.specials.captures[i] = sv.NewString(c)
	}

	if len(captures) > 0 {
		rt.specials.lastParen = sv.NewString(captures[len(captures)-1])
	} else {
		rt.specials.lastParen = sv.NewUndef()
	}
}

// Match returns $& (entire match).
// Match, $& (tüm eşleşme) döndürür.
func (rt *Runtime) Match() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.match == nil {
		return sv.NewUndef()
	}
	return rt.specials.match
}

// PreMatch returns $` (before match).
// PreMatch, $` (eşleşmeden önce) döndürür.
func (rt *Runtime) PreMatch() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.preMath == nil {
		return sv.NewUndef()
	}
	return rt.specials.preMath
}

// PostMatch returns $' (after match).
// PostMatch, $' (eşleşmeden sonra) döndürür.
func (rt *Runtime) PostMatch() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.postMatch == nil {
		return sv.NewUndef()
	}
	return rt.specials.postMatch
}

// LastParen returns $+ (last captured group).
// LastParen, $+ (son yakalanan grup) döndürür.
func (rt *Runtime) LastParen() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.lastParen == nil {
		return sv.NewUndef()
	}
	return rt.specials.lastParen
}

// Capture returns $N (Nth capture group, 1-indexed).
// Capture, $N (N. yakalama grubu, 1-indeksli) döndürür.
func (rt *Runtime) Capture(n int) *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()

	idx := n - 1 // Convert to 0-indexed
	if idx < 0 || idx >= len(rt.specials.captures) {
		return sv.NewUndef()
	}
	return rt.specials.captures[idx]
}

// ============================================================
// Error Handling
// Hata İşleme
// ============================================================

// EvalError returns $@.
// EvalError, $@ döndürür.
func (rt *Runtime) EvalError() *sv.SV {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.evalError
}

// SetEvalError sets $@.
// SetEvalError, $@ ayarlar.
func (rt *Runtime) SetEvalError(v *sv.SV) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.evalError = v
}

// ClearEvalError clears $@ (sets to empty string).
// ClearEvalError, $@ temizler (boş string'e ayarlar).
func (rt *Runtime) ClearEvalError() {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.evalError = sv.NewString("")
}

// OSError returns $!.
// OSError, $! döndürür.
func (rt *Runtime) OSError() *sv.SV {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.osError
}

// SetOSError sets $!.
// SetOSError, $! ayarlar.
func (rt *Runtime) SetOSError(err error) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	if err != nil {
		rt.osError = sv.NewString(err.Error())
	} else {
		rt.osError = sv.NewString("")
	}
}

// ChildError returns $?.
// ChildError, $? döndürür.
func (rt *Runtime) ChildError() *sv.SV {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.childErr
}

// SetChildError sets $? (child exit status).
// SetChildError, $? ayarlar (çocuk çıkış durumu).
func (rt *Runtime) SetChildError(code int) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.childErr = sv.NewInt(int64(code))
}

// Die implements die() - throws an exception.
// Die, die() uygular - bir istisna fırlatır.
func (rt *Runtime) Die(msg string) {
	rt.mu.Lock()
	rt.evalError = sv.NewString(msg)
	handler := rt.dieHandler
	rt.mu.Unlock()

	// Call $SIG{__DIE__} if set
	// Ayarlandıysa $SIG{__DIE__} çağır
	if handler != nil && !handler.IsUndef() {
		// TODO: Call the handler CV
	}

	// If in eval, just set $@ and return
	// eval içindeyse, sadece $@ ayarla ve dön
	if rt.evalDepth > 0 {
		return
	}

	// Otherwise, panic (will be caught by top-level)
	// Aksi halde, panic (üst seviyede yakalanacak)
	panic(PerlDie{Message: msg})
}

// Warn implements warn() - prints a warning.
// Warn, warn() uygular - bir uyarı yazdırır.
func (rt *Runtime) Warn(msg string) {
	rt.mu.RLock()
	handler := rt.warnHandler
	rt.mu.RUnlock()

	// Call $SIG{__WARN__} if set
	// Ayarlandıysa $SIG{__WARN__} çağır
	if handler != nil && !handler.IsUndef() {
		// TODO: Call the handler CV
		return
	}

	// Default: print to STDERR
	// Varsayılan: STDERR'e yazdır
	fmt.Fprintln(os.Stderr, msg)
}

// PerlDie is the panic type for die().
// PerlDie, die() için panic türüdür.
type PerlDie struct {
	Message string
}

func (e PerlDie) Error() string {
	return e.Message
}

// ============================================================
// Eval Support
// Eval Desteği
// ============================================================

// EnterEval marks entry into an eval block.
// EnterEval, bir eval bloğuna girişi işaretler.
func (rt *Runtime) EnterEval() {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.evalDepth++
	rt.evalError = sv.NewString("")
}

// LeaveEval marks exit from an eval block.
// LeaveEval, bir eval bloğundan çıkışı işaretler.
func (rt *Runtime) LeaveEval() {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	if rt.evalDepth > 0 {
		rt.evalDepth--
	}
}

// InEval returns true if currently inside an eval.
// InEval, şu anda eval içindeyse true döndürür.
func (rt *Runtime) InEval() bool {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.evalDepth > 0
}

// TryEval executes a function with eval semantics.
// Returns true if successful, false if died.
//
// TryEval, eval semantiği ile bir fonksiyon çalıştırır.
// Başarılıysa true, die olduysa false döndürür.
func (rt *Runtime) TryEval(fn func()) bool {
	rt.EnterEval()
	defer rt.LeaveEval()

	defer func() {
		if r := recover(); r != nil {
			if die, ok := r.(PerlDie); ok {
				rt.SetEvalError(sv.NewString(die.Message))
			} else {
				rt.SetEvalError(sv.NewString(fmt.Sprintf("%v", r)))
			}
		}
	}()

	fn()
	return rt.EvalError().AsString() == ""
}

// ============================================================
// Package Context
// Paket Bağlamı
// ============================================================

// Package returns the current package name.
// Package, geçerli paket adını döndürür.
func (rt *Runtime) Package() string {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.curPackage
}

// SetPackage sets the current package.
// SetPackage, geçerli paketi ayarlar.
func (rt *Runtime) SetPackage(pkg string) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.curPackage = pkg
}

// ============================================================
// Hints and Pragmas
// İpuçları ve Pragmalar
// ============================================================

// UseStrict enables 'use strict' with given flags.
// UseStrict, verilen bayraklarla 'use strict' etkinleştirir.
func (rt *Runtime) UseStrict(flags StrictFlags) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.hints.Strict |= flags
}

// NoStrict disables strict flags.
// NoStrict, strict bayraklarını devre dışı bırakır.
func (rt *Runtime) NoStrict(flags StrictFlags) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.hints.Strict &^= flags
}

// IsStrict returns true if strict flag is set.
// IsStrict, strict bayrağı ayarlıysa true döndürür.
func (rt *Runtime) IsStrict(flag StrictFlags) bool {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.hints.Strict&flag != 0
}

// UseWarnings enables warnings with given flags.
// UseWarnings, verilen bayraklarla uyarıları etkinleştirir.
func (rt *Runtime) UseWarnings(flags WarningFlags) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.hints.Warnings |= flags
}

// NoWarnings disables warning flags.
// NoWarnings, uyarı bayraklarını devre dışı bırakır.
func (rt *Runtime) NoWarnings(flags WarningFlags) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.hints.Warnings &^= flags
}

// IsWarning returns true if warning flag is set.
// IsWarning, uyarı bayrağı ayarlıysa true döndürür.
func (rt *Runtime) IsWarning(flag WarningFlags) bool {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.hints.Warnings&flag != 0
}

// UseFeature enables feature flags.
// UseFeature, özellik bayraklarını etkinleştirir.
func (rt *Runtime) UseFeature(flags FeatureFlags) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.hints.Features |= flags
}

// HasFeature returns true if feature is enabled.
// HasFeature, özellik etkinse true döndürür.
func (rt *Runtime) HasFeature(flag FeatureFlags) bool {
	rt.mu.RLock()
	defer rt.mu.RUnlock()
	return rt.hints.Features&flag != 0
}

// ============================================================
// Signal Handlers
// Sinyal İşleyicileri
// ============================================================

// SetDieHandler sets $SIG{__DIE__}.
// SetDieHandler, $SIG{__DIE__} ayarlar.
func (rt *Runtime) SetDieHandler(handler *sv.SV) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.dieHandler = handler
}

// SetWarnHandler sets $SIG{__WARN__}.
// SetWarnHandler, $SIG{__WARN__} ayarlar.
func (rt *Runtime) SetWarnHandler(handler *sv.SV) {
	rt.mu.Lock()
	defer rt.mu.Unlock()
	rt.warnHandler = handler
}

// ============================================================
// Process Info Variables
// Süreç Bilgisi Değişkenleri
// ============================================================

// UID returns $< (real uid).
// UID, $< (gerçek uid) döndürür.
func (rt *Runtime) UID() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.uid == nil {
		return sv.NewInt(int64(os.Getuid()))
	}
	return rt.specials.uid
}

// EUID returns $> (effective uid).
// EUID, $> (etkin uid) döndürür.
func (rt *Runtime) EUID() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.euid == nil {
		return sv.NewInt(int64(os.Geteuid()))
	}
	return rt.specials.euid
}

// GID returns $( (real gid).
// GID, $( (gerçek gid) döndürür.
func (rt *Runtime) GID() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.gid == nil {
		return sv.NewInt(int64(os.Getgid()))
	}
	return rt.specials.gid
}

// EGID returns $) (effective gid).
// EGID, $) (etkin gid) döndürür.
func (rt *Runtime) EGID() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.egid == nil {
		return sv.NewInt(int64(os.Getegid()))
	}
	return rt.specials.egid
}

// ============================================================
// Format Variables
// Format Değişkenleri
// ============================================================

// Format returns $~ (current format name).
// Format, $~ (geçerli format adı) döndürür.
func (rt *Runtime) Format() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.format == nil {
		return sv.NewUndef()
	}
	return rt.specials.format
}

// SetFormat sets $~.
// SetFormat, $~ ayarlar.
func (rt *Runtime) SetFormat(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.format = v
}

// Accumulator returns $^A (format accumulator).
// Accumulator, $^A (format akümülatör) döndürür.
func (rt *Runtime) Accumulator() *sv.SV {
	rt.specials.mu.RLock()
	defer rt.specials.mu.RUnlock()
	if rt.specials.accumulator == nil {
		return sv.NewString("")
	}
	return rt.specials.accumulator
}

// SetAccumulator sets $^A.
// SetAccumulator, $^A ayarlar.
func (rt *Runtime) SetAccumulator(v *sv.SV) {
	rt.specials.mu.Lock()
	defer rt.specials.mu.Unlock()
	rt.specials.accumulator = v
}
```

## File: ./pkg/context/context_test.go
```go
package context

import (
	"fmt"
	"runtime"
	"testing"

	"perlc/pkg/cv"
	"perlc/pkg/stash"
	"perlc/pkg/sv"
)

// ============================================================
// Runtime Creation Tests
// Runtime Oluşturma Testleri
// ============================================================

// TestNewRuntime tests runtime initialization.
// TestNewRuntime, runtime başlatmayı test eder.
func TestNewRuntime(t *testing.T) {
	rt := NewRuntime()

	if rt == nil {
		t.Fatal("NewRuntime should not return nil")
	}

	if rt.Package() != "main" {
		t.Errorf("Default package should be 'main', got '%s'", rt.Package())
	}

	if rt.CallDepth() != 0 {
		t.Errorf("Initial call depth should be 0, got %d", rt.CallDepth())
	}
}

// TestGetRuntime tests global runtime singleton.
// TestGetRuntime, global runtime singleton'ı test eder.
func TestGetRuntime(t *testing.T) {
	rt1 := GetRuntime()
	rt2 := GetRuntime()

	if rt1 != rt2 {
		t.Error("GetRuntime should return same instance")
	}
}

// ============================================================
// Call Stack Tests
// Çağrı Yığını Testleri
// ============================================================

// TestPushPopCall tests basic call stack operations.
// TestPushPopCall, temel çağrı yığını işlemlerini test eder.
func TestPushPopCall(t *testing.T) {
	rt := NewRuntime()

	frame := &StackFrame{
		Package: "TestPkg",
		File:    "test.pl",
		Line:    10,
		Sub:     "test_sub",
	}

	rt.PushCall(frame)

	if rt.CallDepth() != 1 {
		t.Errorf("Call depth should be 1, got %d", rt.CallDepth())
	}

	popped := rt.PopCall()
	if popped != frame {
		t.Error("PopCall should return pushed frame")
	}

	if rt.CallDepth() != 0 {
		t.Errorf("Call depth should be 0 after pop, got %d", rt.CallDepth())
	}
}

// TestCurrentFrame tests getting current frame.
// TestCurrentFrame, geçerli çerçeveyi almayı test eder.
func TestCurrentFrame(t *testing.T) {
	rt := NewRuntime()

	if rt.CurrentFrame() != nil {
		t.Error("CurrentFrame should be nil when stack empty")
	}

	frame1 := &StackFrame{Sub: "sub1"}
	frame2 := &StackFrame{Sub: "sub2"}

	rt.PushCall(frame1)
	rt.PushCall(frame2)

	current := rt.CurrentFrame()
	if current.Sub != "sub2" {
		t.Error("CurrentFrame should return top frame")
	}
}

// TestCaller tests caller() functionality.
// TestCaller, caller() işlevselliğini test eder.
func TestCaller(t *testing.T) {
	rt := NewRuntime()

	frames := []*StackFrame{
		{Package: "main", File: "test.pl", Line: 1, Sub: "main"},
		{Package: "Foo", File: "Foo.pm", Line: 10, Sub: "foo"},
		{Package: "Bar", File: "Bar.pm", Line: 20, Sub: "bar"},
	}

	for _, f := range frames {
		rt.PushCall(f)
	}

	// caller(0) = current = bar
	c0 := rt.Caller(0)
	if c0.Sub != "bar" {
		t.Errorf("caller(0) should be 'bar', got '%s'", c0.Sub)
	}

	// caller(1) = foo
	c1 := rt.Caller(1)
	if c1.Sub != "foo" {
		t.Errorf("caller(1) should be 'foo', got '%s'", c1.Sub)
	}

	// caller(2) = main
	c2 := rt.Caller(2)
	if c2.Sub != "main" {
		t.Errorf("caller(2) should be 'main', got '%s'", c2.Sub)
	}

	// caller(3) = nil (out of bounds)
	c3 := rt.Caller(3)
	if c3 != nil {
		t.Error("caller(3) should be nil")
	}
}

// TestCallerNegative tests caller with negative level.
// TestCallerNegative, negatif seviye ile caller'ı test eder.
func TestCallerNegative(t *testing.T) {
	rt := NewRuntime()
	rt.PushCall(&StackFrame{Sub: "test"})

	if rt.Caller(-1) != nil {
		t.Error("Negative caller level should return nil")
	}
}

// TestDeepCallStack tests deep call stack.
// TestDeepCallStack, derin çağrı yığınını test eder.
func TestDeepCallStack(t *testing.T) {
	rt := NewRuntime()

	depth := 100
	for i := 0; i < depth; i++ {
		rt.PushCall(&StackFrame{Line: i})
	}

	if rt.CallDepth() != depth {
		t.Errorf("Call depth should be %d, got %d", depth, rt.CallDepth())
	}

	// Verify order
	for i := 0; i < depth; i++ {
		frame := rt.Caller(i)
		expectedLine := depth - 1 - i
		if frame.Line != expectedLine {
			t.Errorf("caller(%d) line should be %d, got %d", i, expectedLine, frame.Line)
		}
	}
}

// TestStackTrace tests stack trace generation.
// TestStackTrace, yığın izi oluşturmayı test eder.
func TestStackTrace(t *testing.T) {
	rt := NewRuntime()

	rt.PushCall(&StackFrame{Package: "main", Sub: "main", File: "test.pl", Line: 1})
	rt.PushCall(&StackFrame{Package: "Foo", Sub: "bar", File: "Foo.pm", Line: 42})

	trace := rt.StackTrace()

	if trace == "" {
		t.Error("StackTrace should not be empty")
	}

	// Should contain both frames
	if len(trace) < 20 {
		t.Error("StackTrace seems too short")
	}
}

// TestPopEmptyStack tests popping from empty stack.
// TestPopEmptyStack, boş yığından pop'u test eder.
func TestPopEmptyStack(t *testing.T) {
	rt := NewRuntime()

	frame := rt.PopCall()
	if frame != nil {
		t.Error("PopCall on empty stack should return nil")
	}
}

// ============================================================
// Dynamic Scope (local) Tests
// Dinamik Kapsam (local) Testleri
// ============================================================

// TestLocalScalar tests local($var).
// TestLocalScalar, local($var) test eder.
func TestLocalScalar(t *testing.T) {
	rt := NewRuntime()

	// Set initial value
	stash.Get("main").SetScalar("x", sv.NewInt(42))

	// Enter scope and localize
	rt.PushLocal()
	rt.LocalScalar("main::x")

	// Value should be undef now
	val := stash.Get("main").Scalar("x")
	if !val.IsUndef() {
		t.Error("local($x) should set to undef")
	}

	// Set new value
	stash.Get("main").SetScalar("x", sv.NewInt(100))

	// Leave scope - should restore
	rt.PopLocal()

	restored := stash.Get("main").Scalar("x")
	if restored.AsInt() != 42 {
		t.Errorf("After PopLocal, $x should be 42, got %d", restored.AsInt())
	}
}

// TestLocalArray tests local(@var).
// TestLocalArray, local(@var) test eder.
func TestLocalArray(t *testing.T) {
	rt := NewRuntime()

	// Set initial array
	arr := stash.Get("main").Array("arr")
	arr.SetArrayData([]*sv.SV{sv.NewInt(1), sv.NewInt(2), sv.NewInt(3)})

	rt.PushLocal()
	rt.LocalArray("main::arr")

	// Should be empty array now
	localArr := stash.Get("main").Array("arr")
	if len(localArr.ArrayData()) != 0 {
		t.Error("local(@arr) should be empty")
	}

	rt.PopLocal()
}

// TestLocalHash tests local(%var).
// TestLocalHash, local(%var) test eder.
func TestLocalHash(t *testing.T) {
	rt := NewRuntime()

	hash := stash.Get("main").Hash("hash")
	hash.HashData()["key"] = sv.NewString("value")

	rt.PushLocal()
	rt.LocalHash("main::hash")

	localHash := stash.Get("main").Hash("hash")
	if len(localHash.HashData()) != 0 {
		t.Error("local(hash) should be empty")
	}

	rt.PopLocal()
}

// TestNestedLocal tests nested local scopes.
// TestNestedLocal, iç içe local kapsamlarını test eder.
func TestNestedLocal(t *testing.T) {
	rt := NewRuntime()

	stash.Get("main").SetScalar("n", sv.NewInt(1))

	rt.PushLocal()
	rt.LocalScalar("main::n")
	stash.Get("main").SetScalar("n", sv.NewInt(2))

	rt.PushLocal()
	rt.LocalScalar("main::n")
	stash.Get("main").SetScalar("n", sv.NewInt(3))

	if stash.Get("main").Scalar("n").AsInt() != 3 {
		t.Error("Innermost value should be 3")
	}

	rt.PopLocal()
	if stash.Get("main").Scalar("n").AsInt() != 2 {
		t.Error("After first pop, value should be 2")
	}

	rt.PopLocal()
	if stash.Get("main").Scalar("n").AsInt() != 1 {
		t.Error("After second pop, value should be 1")
	}
}

// TestLocalWithoutPush tests local without explicit PushLocal.
// TestLocalWithoutPush, açık PushLocal olmadan local'i test eder.
func TestLocalWithoutPush(t *testing.T) {
	rt := NewRuntime()

	stash.Get("main").SetScalar("auto", sv.NewInt(99))

	// Should auto-create frame
	rt.LocalScalar("main::auto")

	// Cleanup
	rt.PopLocal()
}

// ============================================================
// Special Variables Tests
// Özel Değişken Testleri
// ============================================================

// TestUnderscore tests $_.
// TestUnderscore, $_ test eder.
func TestUnderscore(t *testing.T) {
	rt := NewRuntime()

	rt.SetUnderscore(sv.NewString("test value"))

	val := rt.Underscore()
	if val.AsString() != "test value" {
		t.Errorf("$_ should be 'test value', got '%s'", val.AsString())
	}
}

// TestInputRS tests $/ (input record separator).
// TestInputRS, $/ (girdi kayıt ayırıcı) test eder.
func TestInputRS(t *testing.T) {
	rt := NewRuntime()

	// Default is newline
	if rt.InputRS().AsString() != "\n" {
		t.Error("Default $/ should be newline")
	}

	rt.SetInputRS(sv.NewString("\r\n"))
	if rt.InputRS().AsString() != "\r\n" {
		t.Error("$/ should be CRLF after set")
	}
}

// TestOutputRS tests $\ (output record separator).
// TestOutputRS, $\ (çıktı kayıt ayırıcı) test eder.
func TestOutputRS(t *testing.T) {
	rt := NewRuntime()

	// Default is empty
	if rt.OutputRS().AsString() != "" {
		t.Error("Default $\\ should be empty")
	}

	rt.SetOutputRS(sv.NewString("\n"))
	if rt.OutputRS().AsString() != "\n" {
		t.Error("$\\ should be newline after set")
	}
}

// TestPID tests $$.
// TestPID, $$ test eder.
func TestPID(t *testing.T) {
	rt := NewRuntime()

	pid := rt.PID().AsInt()
	if pid <= 0 {
		t.Errorf("$$ should be positive, got %d", pid)
	}
}

// TestProgName tests $0.
// TestProgName, $0 test eder.
func TestProgName(t *testing.T) {
	rt := NewRuntime()

	// Should have some value
	name := rt.ProgName().AsString()
	if name == "" {
		t.Error("$0 should not be empty")
	}

	rt.SetProgName(sv.NewString("custom_name"))
	if rt.ProgName().AsString() != "custom_name" {
		t.Error("$0 should be 'custom_name' after set")
	}
}

// TestListSep tests $" (list separator).
// TestListSep, $" (liste ayırıcı) test eder.
func TestListSep(t *testing.T) {
	rt := NewRuntime()

	// Default is space
	if rt.ListSep().AsString() != " " {
		t.Error("Default $\" should be space")
	}
}

// TestProcessInfo tests uid/gid variables.
// TestProcessInfo, uid/gid değişkenlerini test eder.
func TestProcessInfo(t *testing.T) {
	rt := NewRuntime()

	// These should return integers (may be -1 on Windows)
	// Bunlar tamsayı döndürmeli (Windows'ta -1 olabilir)
	uid := rt.UID().AsInt()
	euid := rt.EUID().AsInt()
	gid := rt.GID().AsInt()
	egid := rt.EGID().AsInt()

	// Just verify they return something (not undef)
	// Sadece bir şey döndürdüklerini doğrula (undef değil)
	if rt.UID().IsUndef() {
		t.Error("UID should not be undef")
	}
	if rt.EUID().IsUndef() {
		t.Error("EUID should not be undef")
	}
	if rt.GID().IsUndef() {
		t.Error("GID should not be undef")
	}
	if rt.EGID().IsUndef() {
		t.Error("EGID should not be undef")
	}

	// Use variables to avoid "unused" warning
	// "unused" uyarısından kaçınmak için değişkenleri kullan
	_ = uid
	_ = euid
	_ = gid
	_ = egid
}

// TestProcessInfo tests uid/gid variables.
// TestProcessInfo, uid/gid değişkenlerini test eder.
func TestProcessInfoWithPlatform(t *testing.T) {
	rt := NewRuntime()

	uid := rt.UID().AsInt()
	euid := rt.EUID().AsInt()
	gid := rt.GID().AsInt()
	egid := rt.EGID().AsInt()

	// On Unix these are >= 0, on Windows they are -1
	// Unix'te bunlar >= 0, Windows'ta -1
	if runtime.GOOS != "windows" {
		if uid < 0 || euid < 0 || gid < 0 || egid < 0 {
			t.Error("Process IDs should be non-negative on Unix")
		}
	} else {
		// Windows returns -1 for these
		// Windows bunlar için -1 döndürür
		if uid != -1 || euid != -1 || gid != -1 || egid != -1 {
			t.Error("Process IDs should be -1 on Windows")
		}
	}
}

// ============================================================
// Regex Match Variables Tests
// Regex Eşleşme Değişkenleri Testleri
// ============================================================

// TestMatchVars tests regex match result variables.
// TestMatchVars, regex eşleşme sonuç değişkenlerini test eder.
func TestMatchVars(t *testing.T) {
	rt := NewRuntime()

	rt.SetMatchVars("hello", "say ", " world", []string{"hel", "lo"})

	// $& (entire match)
	if rt.Match().AsString() != "hello" {
		t.Errorf("$& should be 'hello', got '%s'", rt.Match().AsString())
	}

	// $` (prematch)
	if rt.PreMatch().AsString() != "say " {
		t.Errorf("$` should be 'say ', got '%s'", rt.PreMatch().AsString())
	}

	// $' (postmatch)
	if rt.PostMatch().AsString() != " world" {
		t.Errorf("$' should be ' world', got '%s'", rt.PostMatch().AsString())
	}

	// $+ (last paren)
	if rt.LastParen().AsString() != "lo" {
		t.Errorf("$+ should be 'lo', got '%s'", rt.LastParen().AsString())
	}
}

// TestCaptures tests $1, $2, etc.
// TestCaptures, $1, $2, vb. test eder.
func TestCaptures(t *testing.T) {
	rt := NewRuntime()

	rt.SetMatchVars("match", "", "", []string{"first", "second", "third"})

	// $1
	if rt.Capture(1).AsString() != "first" {
		t.Errorf("$1 should be 'first', got '%s'", rt.Capture(1).AsString())
	}

	// $2
	if rt.Capture(2).AsString() != "second" {
		t.Errorf("$2 should be 'second', got '%s'", rt.Capture(2).AsString())
	}

	// $3
	if rt.Capture(3).AsString() != "third" {
		t.Errorf("$3 should be 'third', got '%s'", rt.Capture(3).AsString())
	}

	// $4 (doesn't exist)
	if !rt.Capture(4).IsUndef() {
		t.Error("$4 should be undef")
	}

	// $0 (invalid)
	if !rt.Capture(0).IsUndef() {
		t.Error("$0 capture should be undef")
	}
}

// TestEmptyCaptures tests when no captures.
// TestEmptyCaptures, yakalama olmadığında test eder.
func TestEmptyCaptures(t *testing.T) {
	rt := NewRuntime()

	rt.SetMatchVars("match", "pre", "post", []string{})

	if !rt.LastParen().IsUndef() {
		t.Error("$+ should be undef with no captures")
	}
}

// TestMatchVarsDefault tests default match var values.
// TestMatchVarsDefault, varsayılan eşleşme değişken değerlerini test eder.
func TestMatchVarsDefault(t *testing.T) {
	rt := NewRuntime()

	// Before any match
	if !rt.Match().IsUndef() {
		t.Error("$& should be undef before match")
	}
	if !rt.PreMatch().IsUndef() {
		t.Error("$` should be undef before match")
	}
	if !rt.PostMatch().IsUndef() {
		t.Error("$' should be undef before match")
	}
}

// ============================================================
// Error Handling Tests
// Hata İşleme Testleri
// ============================================================

// TestEvalError tests $@.
// TestEvalError, $@ test eder.
func TestEvalError(t *testing.T) {
	rt := NewRuntime()

	rt.SetEvalError(sv.NewString("Something went wrong"))

	if rt.EvalError().AsString() != "Something went wrong" {
		t.Error("$@ not set correctly")
	}

	rt.ClearEvalError()
	if rt.EvalError().AsString() != "" {
		t.Error("$@ should be empty after clear")
	}
}

// TestOSError tests $!.
// TestOSError, $! test eder.
func TestOSError(t *testing.T) {
	rt := NewRuntime()

	rt.SetOSError(nil)
	if rt.OSError().AsString() != "" {
		t.Error("$! should be empty for nil error")
	}

	rt.SetOSError(fmt.Errorf("file not found"))
	if rt.OSError().AsString() != "file not found" {
		t.Error("$! should be 'file not found'")
	}
}

// TestChildError tests $?.
// TestChildError, $? test eder.
func TestChildError(t *testing.T) {
	rt := NewRuntime()

	rt.SetChildError(256) // Exit code 1 in shell
	if rt.ChildError().AsInt() != 256 {
		t.Errorf("$? should be 256, got %d", rt.ChildError().AsInt())
	}
}

// TestDie tests die() function.
// TestDie, die() fonksiyonunu test eder.
func TestDie(t *testing.T) {
	rt := NewRuntime()

	// Die outside eval should panic
	defer func() {
		r := recover()
		if r == nil {
			t.Error("Die should panic outside eval")
		}
		die, ok := r.(PerlDie)
		if !ok {
			t.Error("Should panic with PerlDie type")
		}
		if die.Message != "test error" {
			t.Errorf("Die message should be 'test error', got '%s'", die.Message)
		}
	}()

	rt.Die("test error")
}

// TestDieInEval tests die() inside eval.
// TestDieInEval, eval içinde die() test eder.
func TestDieInEval(t *testing.T) {
	rt := NewRuntime()

	rt.EnterEval()
	rt.Die("eval error")
	rt.LeaveEval()

	// Should not panic, just set $@
	if rt.EvalError().AsString() != "eval error" {
		t.Errorf("$@ should be 'eval error', got '%s'", rt.EvalError().AsString())
	}
}

// TestTryEval tests TryEval helper.
// TestTryEval, TryEval yardımcısını test eder.
func TestTryEval(t *testing.T) {
	rt := NewRuntime()

	// Successful eval
	success := rt.TryEval(func() {
		// Do nothing, no error
	})

	if !success {
		t.Error("TryEval should return true on success")
	}

	// Failed eval
	success = rt.TryEval(func() {
		rt.Die("failure")
	})

	if success {
		t.Error("TryEval should return false on die")
	}
	if rt.EvalError().AsString() != "failure" {
		t.Error("$@ should be set after failed eval")
	}
}

// TestTryEvalPanic tests TryEval with Go panic.
// TestTryEvalPanic, Go panic ile TryEval'i test eder.
func TestTryEvalPanic(t *testing.T) {
	rt := NewRuntime()

	success := rt.TryEval(func() {
		panic("go panic")
	})

	if success {
		t.Error("TryEval should catch Go panics")
	}
	if rt.EvalError().AsString() != "go panic" {
		t.Errorf("$@ should contain panic message, got '%s'", rt.EvalError().AsString())
	}
}

// TestNestedEval tests nested eval blocks.
// TestNestedEval, iç içe eval bloklarını test eder.
func TestNestedEval(t *testing.T) {
	rt := NewRuntime()

	if rt.InEval() {
		t.Error("Should not be in eval initially")
	}

	rt.EnterEval()
	if !rt.InEval() {
		t.Error("Should be in eval after EnterEval")
	}

	rt.EnterEval()
	rt.LeaveEval()

	if !rt.InEval() {
		t.Error("Should still be in outer eval")
	}

	rt.LeaveEval()
	if rt.InEval() {
		t.Error("Should not be in eval after all LeaveEval")
	}
}

// ============================================================
// Package Context Tests
// Paket Bağlamı Testleri
// ============================================================

// TestPackage tests current package.
// TestPackage, geçerli paketi test eder.
func TestPackage(t *testing.T) {
	rt := NewRuntime()

	if rt.Package() != "main" {
		t.Error("Default package should be 'main'")
	}

	rt.SetPackage("Foo::Bar")
	if rt.Package() != "Foo::Bar" {
		t.Errorf("Package should be 'Foo::Bar', got '%s'", rt.Package())
	}
}

// ============================================================
// Strict/Warnings Tests
// Strict/Warnings Testleri
// ============================================================

// TestUseStrict tests 'use strict'.
// TestUseStrict, 'use strict' test eder.
func TestUseStrict(t *testing.T) {
	rt := NewRuntime()

	if rt.IsStrict(StrictRefs) {
		t.Error("strict refs should be off initially")
	}

	rt.UseStrict(StrictRefs | StrictVars)

	if !rt.IsStrict(StrictRefs) {
		t.Error("strict refs should be on")
	}
	if !rt.IsStrict(StrictVars) {
		t.Error("strict vars should be on")
	}
	if rt.IsStrict(StrictSubs) {
		t.Error("strict subs should still be off")
	}

	rt.NoStrict(StrictRefs)
	if rt.IsStrict(StrictRefs) {
		t.Error("strict refs should be off after NoStrict")
	}
}

// TestUseWarnings tests 'use warnings'.
// TestUseWarnings, 'use warnings' test eder.
func TestUseWarnings(t *testing.T) {
	rt := NewRuntime()

	rt.UseWarnings(WarnUninitialized | WarnNumeric)

	if !rt.IsWarning(WarnUninitialized) {
		t.Error("uninitialized warning should be on")
	}
	if !rt.IsWarning(WarnNumeric) {
		t.Error("numeric warning should be on")
	}
	if rt.IsWarning(WarnIO) {
		t.Error("IO warning should be off")
	}

	rt.NoWarnings(WarnUninitialized)
	if rt.IsWarning(WarnUninitialized) {
		t.Error("uninitialized warning should be off")
	}
}

// TestUseFeature tests 'use feature'.
// TestUseFeature, 'use feature' test eder.
func TestUseFeature(t *testing.T) {
	rt := NewRuntime()

	rt.UseFeature(FeatureSay | FeatureState)

	if !rt.HasFeature(FeatureSay) {
		t.Error("say feature should be enabled")
	}
	if !rt.HasFeature(FeatureState) {
		t.Error("state feature should be enabled")
	}
	if rt.HasFeature(FeatureSignatures) {
		t.Error("signatures feature should be disabled")
	}
}

// ============================================================
// Signal Handler Tests
// Sinyal İşleyici Testleri
// ============================================================

// TestSetDieHandler tests $SIG{__DIE__}.
// TestSetDieHandler, $SIG{__DIE__} test eder.
func TestSetDieHandler(t *testing.T) {
	rt := NewRuntime()

	handler := sv.NewInt(1) // Placeholder CV
	rt.SetDieHandler(handler)

	// Handler is set (actual invocation tested elsewhere)
	// İşleyici ayarlandı (gerçek çağrı başka yerde test edilir)
}

// TestSetWarnHandler tests $SIG{__WARN__}.
// TestSetWarnHandler, $SIG{__WARN__} test eder.
func TestSetWarnHandler(t *testing.T) {
	rt := NewRuntime()

	handler := sv.NewInt(1)
	rt.SetWarnHandler(handler)
}

// ============================================================
// Format Variables Tests
// Format Değişkenleri Testleri
// ============================================================

// TestFormat tests $~ (format name).
// TestFormat, $~ (format adı) test eder.
func TestFormat(t *testing.T) {
	rt := NewRuntime()

	if !rt.Format().IsUndef() {
		t.Error("Default format should be undef")
	}

	rt.SetFormat(sv.NewString("STDOUT"))
	if rt.Format().AsString() != "STDOUT" {
		t.Error("Format should be 'STDOUT'")
	}
}

// TestAccumulator tests $^A (format accumulator).
// TestAccumulator, $^A (format akümülatör) test eder.
func TestAccumulator(t *testing.T) {
	rt := NewRuntime()

	if rt.Accumulator().AsString() != "" {
		t.Error("Default accumulator should be empty")
	}

	rt.SetAccumulator(sv.NewString("accumulated"))
	if rt.Accumulator().AsString() != "accumulated" {
		t.Error("Accumulator should be 'accumulated'")
	}
}

// ============================================================
// Stack Frame Tests
// Yığın Çerçevesi Testleri
// ============================================================

// TestStackFrameFields tests StackFrame field access.
// TestStackFrameFields, StackFrame alan erişimini test eder.
func TestStackFrameFields(t *testing.T) {
	cvObj := cv.New("Test", "method", nil)

	frame := &StackFrame{
		CV:        cvObj,
		Package:   "Test",
		File:      "test.pl",
		Line:      42,
		Sub:       "method",
		Args:      []*sv.SV{sv.NewInt(1), sv.NewInt(2)},
		WantArray: 1,
		HasArgs:   true,
		IsEval:    false,
		EvalText:  "",
	}

	if frame.CV != cvObj {
		t.Error("CV field wrong")
	}
	if frame.Package != "Test" {
		t.Error("Package field wrong")
	}
	if frame.File != "test.pl" {
		t.Error("File field wrong")
	}
	if frame.Line != 42 {
		t.Error("Line field wrong")
	}
	if frame.Sub != "method" {
		t.Error("Sub field wrong")
	}
	if len(frame.Args) != 2 {
		t.Error("Args field wrong")
	}
	if frame.WantArray != 1 {
		t.Error("WantArray field wrong")
	}
	if !frame.HasArgs {
		t.Error("HasArgs field wrong")
	}
	if frame.IsEval {
		t.Error("IsEval field wrong")
	}
	if frame.EvalText != "" {
		t.Error("EvalText field wrong")
	}

}

// TestEvalFrame tests eval stack frame.
// TestEvalFrame, eval yığın çerçevesini test eder.
func TestEvalFrame(t *testing.T) {
	frame := &StackFrame{
		Package:  "main",
		IsEval:   true,
		EvalText: "print 'hello'",
	}

	if frame.Package != "main" {
		t.Error("Package should be 'main'")
	}
	if !frame.IsEval {
		t.Error("Should be eval frame")
	}
	if frame.EvalText != "print 'hello'" {
		t.Error("EvalText wrong")
	}
}

// ============================================================
// Concurrency Tests
// Eşzamanlılık Testleri
// ============================================================

// TestConcurrentSpecialVars tests thread-safe special var access.
// TestConcurrentSpecialVars, iş parçacığı güvenli özel değişken erişimini test eder.
func TestConcurrentSpecialVars(t *testing.T) {
	rt := NewRuntime()
	done := make(chan bool)

	for i := 0; i < 10; i++ {
		go func(n int) {
			rt.SetUnderscore(sv.NewInt(int64(n)))
			_ = rt.Underscore()
			done <- true
		}(i)
	}

	for i := 0; i < 10; i++ {
		<-done
	}
}

// TestConcurrentCallStack tests thread-safe call stack.
// TestConcurrentCallStack, iş parçacığı güvenli çağrı yığınını test eder.
func TestConcurrentCallStack(t *testing.T) {
	rt := NewRuntime()
	done := make(chan bool)

	for i := 0; i < 10; i++ {
		go func(n int) {
			rt.PushCall(&StackFrame{Line: n})
			_ = rt.CallDepth()
			rt.PopCall()
			done <- true
		}(i)
	}

	for i := 0; i < 10; i++ {
		<-done
	}
}
```

## File: ./pkg/context/interp.go
```go
// Interpreter context for eval package
package context

import (
	"bufio"
	"os"
	"perlc/pkg/ast"
	"perlc/pkg/sv"
)

// Context holds interpreter state for a single execution.
type Context struct {
	runtime *Runtime

	// Variable scopes (lexical)
	scopes []map[string]*sv.SV

	// Subroutines
	subs map[string]*ast.BlockStmt

	// Package @ISA arrays (для наследования)
	packageISA map[string][]string
	// Arguments @_
	args *sv.SV

	// Control flow
	returnValue *sv.SV
	hasReturn   bool
	lastLabel   string
	hasLast     bool
	nextLabel   string
	hasNext     bool
	filehandles map[string]*FileHandle
}

type FileHandle struct {
	File    *os.File
	Scanner *bufio.Scanner
	Writer  *bufio.Writer
	Mode    string
}

// // В NewContext() добавь инициализацию:
// func NewContext(rt *Runtime) *Context {
// 	return &Context{
// 		// ... существующие поля
// 		filehandles: make(map[string]*FileHandle),
// 	}
// }

// New creates a new interpreter context.
func New() *Context {
	return &Context{
		runtime:     GetRuntime(),
		scopes:      []map[string]*sv.SV{make(map[string]*sv.SV)},
		subs:        make(map[string]*ast.BlockStmt),
		packageISA:  make(map[string][]string),
		filehandles: make(map[string]*FileHandle),
	}
}

// ============================================================
// Variable Management
// ============================================================

// DeclareVar declares a variable in current scope.
func (c *Context) DeclareVar(name string, value *sv.SV, kind string) {
	if len(c.scopes) == 0 {
		c.scopes = append(c.scopes, make(map[string]*sv.SV))
	}
	c.scopes[len(c.scopes)-1][name] = value
}

// SetVar sets a variable value (searches scopes).
func (c *Context) SetVar(name string, value *sv.SV) {
	// Search from innermost to outermost
	for i := len(c.scopes) - 1; i >= 0; i-- {
		if _, ok := c.scopes[i][name]; ok {
			c.scopes[i][name] = value
			return
		}
	}
	// Not found - create in current scope
	if len(c.scopes) == 0 {
		c.scopes = append(c.scopes, make(map[string]*sv.SV))
	}
	c.scopes[len(c.scopes)-1][name] = value
}

// GetVar gets a variable value.
func (c *Context) GetVar(name string) *sv.SV {
	// Search from innermost to outermost
	for i := len(c.scopes) - 1; i >= 0; i-- {
		if v, ok := c.scopes[i][name]; ok {
			return v
		}
	}
	return sv.NewUndef()
}

// PushScope creates a new scope.
func (c *Context) PushScope() {
	c.scopes = append(c.scopes, make(map[string]*sv.SV))
}

// PopScope removes the current scope.
func (c *Context) PopScope() {
	if len(c.scopes) > 1 {
		c.scopes = c.scopes[:len(c.scopes)-1]
	}
}

// ============================================================
// Inheritance Management
// ============================================================

// SetPackageISA sets the @ISA for a package.
func (c *Context) SetPackageISA(pkg string, parents []string) {
	c.packageISA[pkg] = parents
}

// GetPackageISA returns the @ISA for a package.
func (c *Context) GetPackageISA(pkg string) []string {
	return c.packageISA[pkg]
}

// FindMethod searches for a method in the class hierarchy.
// Returns the full method name (Package::method) if found.
func (c *Context) FindMethod(pkg, method string) string {
	return c.findMethodRecursive(pkg, method, make(map[string]bool))
}

func (c *Context) findMethodRecursive(pkg, method string, visited map[string]bool) string {
	// Prevent infinite loops in circular @ISA
	if visited[pkg] {
		return ""
	}
	visited[pkg] = true

	// Try direct method
	fullName := pkg + "::" + method
	if c.subs[fullName] != nil {
		return fullName
	}

	// Search in parent classes (@ISA)
	for _, parent := range c.packageISA[pkg] {
		if found := c.findMethodRecursive(parent, method, visited); found != "" {
			return found
		}
	}

	return ""
}

// ============================================================
// Subroutine Management
// ============================================================

// DeclareSub declares a subroutine.
func (c *Context) DeclareSub(name string, body *ast.BlockStmt) {
	c.subs[name] = body
}

// GetSub gets a subroutine body.
func (c *Context) GetSub(name string) *ast.BlockStmt {
	return c.subs[name]
}

// ============================================================
// Arguments @_
// ============================================================

// SetArgs sets @_ for current call.
func (c *Context) SetArgs(args []*sv.SV) {
	ref := sv.NewArrayRef(args...)
	deref := ref.Deref()
	c.args = deref
}

// GetArgs returns @_ array.
func (c *Context) GetArgs() *sv.SV {
	if c.args == nil {
		c.args = sv.NewArrayRef()
	}
	return c.args
}

// ============================================================
// Return Control
// ============================================================

// SetReturn sets return value and flag.
func (c *Context) SetReturn(value *sv.SV) {
	c.returnValue = value
	c.hasReturn = true
}

// HasReturn checks if return was called.
func (c *Context) HasReturn() bool {
	return c.hasReturn
}

// ReturnValue gets the return value.
func (c *Context) ReturnValue() *sv.SV {
	if c.returnValue == nil {
		return sv.NewUndef()
	}
	return c.returnValue
}

// ClearReturn clears return flag.
func (c *Context) ClearReturn() {
	c.hasReturn = false
	c.returnValue = nil
}

// ============================================================
// Last Control
// ============================================================

// SetLast sets last flag.
func (c *Context) SetLast(label string) {
	c.lastLabel = label
	c.hasLast = true
}

// HasLast checks if last was called.
func (c *Context) HasLast() bool {
	return c.hasLast
}

// ClearLast clears last flag.
func (c *Context) ClearLast() {
	c.hasLast = false
	c.lastLabel = ""
}

// ============================================================
// Next Control
// ============================================================

// SetNext sets next flag.
func (c *Context) SetNext(label string) {
	c.nextLabel = label
	c.hasNext = true
}

// HasNext checks if next was called.
func (c *Context) HasNext() bool {
	return c.hasNext
}

// ClearNext clears next flag.
func (c *Context) ClearNext() {
	c.hasNext = false
	c.nextLabel = ""
}

// ============================================================
// Special Variables
// ============================================================

// GetSpecialVar gets a special variable by name.
func (c *Context) GetSpecialVar(name string) *sv.SV {
	switch name {
	case "$_":
		return c.runtime.Underscore()
	case "$/":
		return c.runtime.InputRS()
	case "$\\":
		return c.runtime.OutputRS()
	case "$,":
		return c.runtime.OutputFS()
	case "$\"":
		return c.runtime.ListSep()
	case "$$":
		return c.runtime.PID()
	case "$0":
		return c.runtime.ProgName()
	case "$@":
		return c.runtime.EvalError()
	case "$!":
		return c.runtime.OSError()
	case "$?":
		return c.runtime.ChildError()
	case "$&":
		return c.runtime.Match()
	case "$`":
		return c.runtime.PreMatch()
	case "$'":
		return c.runtime.PostMatch()
	case "$+":
		return c.runtime.LastParen()
	case "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9":
		n := int(name[1] - '0')
		return c.runtime.Capture(n)
	default:
		return sv.NewUndef()
	}
}

// ============================================================
// File Handle Management
// ============================================================

// Добавь методы:
func (c *Context) OpenFile(name, mode, filename string) error {
	var file *os.File
	var err error

	switch mode {
	case "<", "r":
		file, err = os.Open(filename)
	case ">", "w":
		file, err = os.Create(filename)
	case ">>", "a":
		file, err = os.OpenFile(filename, os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
	default:
		file, err = os.Open(filename)
	}

	if err != nil {
		return err
	}

	fh := &FileHandle{File: file, Mode: mode}
	if mode == "<" || mode == "r" {
		fh.Scanner = bufio.NewScanner(file)
	} else {
		fh.Writer = bufio.NewWriter(file)
	}

	c.filehandles[name] = fh
	return nil
}

func (c *Context) CloseFile(name string) error {
	if fh, ok := c.filehandles[name]; ok {
		if fh.Writer != nil {
			fh.Writer.Flush()
		}
		err := fh.File.Close()
		delete(c.filehandles, name)
		return err
	}
	return nil
}

func (c *Context) ReadLine(name string) (string, bool) {
	// Empty name means STDIN
	if name == "" {
		scanner := bufio.NewScanner(os.Stdin)
		if scanner.Scan() {
			return scanner.Text() + "\n", true
		}
		return "", false
	}

	if fh, ok := c.filehandles[name]; ok && fh.Scanner != nil {
		if fh.Scanner.Scan() {
			return fh.Scanner.Text() + "\n", true
		}
	}
	return "", false
}

func (c *Context) GetFileHandle(name string) *FileHandle {
	return c.filehandles[name]
}

// SetMatchVars sets regex match result variables via runtime.
func (c *Context) SetMatchVars(match, preMath, postMatch string, captures []string) {
	c.runtime.SetMatchVars(match, preMath, postMatch, captures)
}
```

## File: ./pkg/cv/cv.go
```go
// Package cv implements Perl's code values (subroutines).
// Paket cv, Perl'in kod değerlerini (altyordamları) uygular.
//
// A CV represents a subroutine - named or anonymous, with optional closure.
// CV bir altyordamı temsil eder - isimli veya anonim, opsiyonel closure ile.
package cv

import (
	"perlc/pkg/sv"
)

// CV represents a code value (subroutine).
// CV, bir kod değerini (altyordam) temsil eder.
type CV struct {
	name  string // Subroutine name (empty for anonymous) / Altyordam adı (anonim için boş)
	pkg   string // Package where defined / Tanımlandığı paket
	proto string // Prototype e.g. "$$@" / Prototip örn. "$$@"

	// The actual code - one of these will be set
	// Gerçek kod - bunlardan biri ayarlanacak
	native func(*CallContext) *sv.SV // Native Go implementation / Native Go implementasyonu
	ops    []Op                      // Compiled opcodes (for eval'd code) / Derlenmiş opcode'lar (eval'd kod için)

	// Closure support
	// Closure desteği
	outer    *CV      // Enclosing subroutine (for closures) / Kapsayan altyordam (closure'lar için)
	padnames []string // Names of lexical variables / Leksikal değişken isimleri
	pad      []*sv.SV // Captured lexical values (closure) / Yakalanan leksikal değerler (closure)

	// Attributes
	// Özellikler
	flags CVFlags
	attrs map[string]string // :lvalue, :method, etc. / :lvalue, :method, vb.

	// For XS/external code
	// XS/harici kod için
	//xsub interface{} // External function pointer / Harici fonksiyon işaretçisi
}

// CVFlags represents subroutine flags.
// CVFlags, altyordam bayraklarını temsil eder.
type CVFlags uint32

const (
	CVAnon    CVFlags = 1 << iota // Anonymous sub / Anonim altyordam
	CVClone                       // Cloned for closure / Closure için klonlanmış
	CVLvalue                      // :lvalue attribute / :lvalue özelliği
	CVMethod                      // :method attribute / :method özelliği
	CVLocked                      // :locked attribute / :locked özelliği
	CVConst                       // Constant subroutine / Sabit altyordam
	CVIsXSUB                      // Is XSUB (external) / XSUB'dur (harici)
	CVNodebug                     // Skip in debugger / Debugger'da atla
	CVProto                       // Has prototype / Prototipi var
)

// Op represents a compiled operation (for eval).
// Op, derlenmiş bir işlemi temsil eder (eval için).
type Op interface {
	Execute(ctx *CallContext) *sv.SV
}

// CallContext holds the runtime context for a subroutine call.
// CallContext, bir altyordam çağrısı için çalışma zamanı bağlamını tutar.
type CallContext struct {
	Args      []*sv.SV     // @_ arguments / @_ argümanlar
	Pad       []*sv.SV     // Lexical variables / Leksikal değişkenler
	WantArray int          // Context: -1=void, 0=scalar, 1=list / Bağlam: -1=void, 0=skaler, 1=liste
	Package   string       // Current package / Geçerli paket
	File      string       // Source file / Kaynak dosya
	Line      int          // Source line / Kaynak satır
	Caller    *CallContext // Caller's context / Çağıranın bağlamı
	CV        *CV          // Current CV / Geçerli CV
	Error     *sv.SV       // $@ error / $@ hata
}

// ============================================================
// Constructors
// Yapıcılar
// ============================================================

// New creates a new CV with a native Go function.
// New, native Go fonksiyonu ile yeni bir CV oluşturur.
func New(pkg, name string, fn func(*CallContext) *sv.SV) *CV {
	return &CV{
		name:   name,
		pkg:    pkg,
		native: fn,
	}
}

// NewAnon creates an anonymous subroutine.
// NewAnon, anonim bir altyordam oluşturur.
func NewAnon(pkg string, fn func(*CallContext) *sv.SV) *CV {
	return &CV{
		pkg:    pkg,
		native: fn,
		flags:  CVAnon,
	}
}

// NewWithProto creates a CV with prototype.
// NewWithProto, prototip ile bir CV oluşturur.
func NewWithProto(pkg, name, proto string, fn func(*CallContext) *sv.SV) *CV {
	return &CV{
		name:   name,
		pkg:    pkg,
		proto:  proto,
		native: fn,
		flags:  CVProto,
	}
}

// NewClosure creates a closure that captures lexical variables.
// NewClosure, leksikal değişkenleri yakalayan bir closure oluşturur.
func NewClosure(outer *CV, pad []*sv.SV) *CV {
	// Clone pad values with incref
	// Pad değerlerini incref ile klonla
	clonedPad := make([]*sv.SV, len(pad))
	for i, v := range pad {
		if v != nil {
			v.IncRef()
		}
		clonedPad[i] = v
	}

	return &CV{
		pkg:      outer.pkg,
		native:   outer.native,
		ops:      outer.ops,
		outer:    outer,
		padnames: outer.padnames,
		pad:      clonedPad,
		flags:    outer.flags | CVClone,
	}
}

// ============================================================
// Execution
// Çalıştırma
// ============================================================

// Call executes the subroutine with given arguments.
// Call, altyordamı verilen argümanlarla çalıştırır.
func (cv *CV) Call(ctx *CallContext) *sv.SV {
	if ctx == nil {
		ctx = &CallContext{}
	}
	ctx.CV = cv
	ctx.Package = cv.pkg

	// Merge closure pad with call pad
	// Closure pad'i çağrı pad'i ile birleştir
	if len(cv.pad) > 0 {
		if ctx.Pad == nil {
			ctx.Pad = make([]*sv.SV, len(cv.pad))
		}
		for i, v := range cv.pad {
			if v != nil && (i >= len(ctx.Pad) || ctx.Pad[i] == nil) {
				if i >= len(ctx.Pad) {
					newPad := make([]*sv.SV, i+1)
					copy(newPad, ctx.Pad)
					ctx.Pad = newPad
				}
				ctx.Pad[i] = v
			}
		}
	}

	// Execute native function
	// Native fonksiyonu çalıştır
	if cv.native != nil {
		return cv.native(ctx)
	}

	// Execute compiled ops (for eval)
	// Derlenmiş op'ları çalıştır (eval için)
	if cv.ops != nil {
		var result *sv.SV
		for _, op := range cv.ops {
			result = op.Execute(ctx)
		}
		return result
	}

	return sv.NewUndef()
}

// CallList calls subroutine in list context, returns multiple values.
// CallList, altyordamı liste bağlamında çağırır, birden fazla değer döndürür.
func (cv *CV) CallList(ctx *CallContext) []*sv.SV {
	if ctx == nil {
		ctx = &CallContext{}
	}
	ctx.WantArray = 1

	result := cv.Call(ctx)

	// If result is an array, return its elements
	// Sonuç dizi ise, öğelerini döndür
	if result != nil && result.IsRef() {
		deref := result.Deref()
		if deref != nil && deref.IsArray() {
			return deref.ArrayData()
		}
	}

	if result == nil {
		return []*sv.SV{}
	}
	return []*sv.SV{result}
}

// ============================================================
// Properties
// Özellikler
// ============================================================

// Name returns the subroutine name.
// Name, altyordam adını döndürür.
func (cv *CV) Name() string {
	return cv.name
}

// Package returns the package name.
// Package, paket adını döndürür.
func (cv *CV) Package() string {
	return cv.pkg
}

// FullName returns "Package::name".
// FullName, "Package::name" döndürür.
func (cv *CV) FullName() string {
	if cv.name == "" {
		return cv.pkg + "::__ANON__"
	}
	if cv.pkg == "" || cv.pkg == "main" {
		return cv.name
	}
	return cv.pkg + "::" + cv.name
}

// Prototype returns the prototype string.
// Prototype, prototip dizesini döndürür.
func (cv *CV) Prototype() string {
	return cv.proto
}

// SetPrototype sets the prototype.
// SetPrototype, prototipi ayarlar.
func (cv *CV) SetPrototype(proto string) {
	cv.proto = proto
	if proto != "" {
		cv.flags |= CVProto
	}
}

// IsAnon returns true if anonymous sub.
// IsAnon, anonim altyordam ise true döndürür.
func (cv *CV) IsAnon() bool {
	return cv.flags&CVAnon != 0
}

// IsClosure returns true if this is a closure clone.
// IsClosure, bu bir closure klonu ise true döndürür.
func (cv *CV) IsClosure() bool {
	return cv.flags&CVClone != 0
}

// HasProto returns true if has prototype.
// HasProto, prototipi varsa true döndürür.
func (cv *CV) HasProto() bool {
	return cv.flags&CVProto != 0
}

// ============================================================
// Attributes
// Özellikler
// ============================================================

// SetAttr sets a subroutine attribute.
// SetAttr, bir altyordam özelliği ayarlar.
func (cv *CV) SetAttr(name, value string) {
	if cv.attrs == nil {
		cv.attrs = make(map[string]string)
	}
	cv.attrs[name] = value

	// Set corresponding flags
	// İlgili bayrakları ayarla
	switch name {
	case "lvalue":
		cv.flags |= CVLvalue
	case "method":
		cv.flags |= CVMethod
	case "locked":
		cv.flags |= CVLocked
	}
}

// GetAttr returns an attribute value.
// GetAttr, bir özellik değeri döndürür.
func (cv *CV) GetAttr(name string) (string, bool) {
	if cv.attrs == nil {
		return "", false
	}
	v, ok := cv.attrs[name]
	return v, ok
}

// IsLvalue returns true if :lvalue attribute set.
// IsLvalue, :lvalue özelliği ayarlıysa true döndürür.
func (cv *CV) IsLvalue() bool {
	return cv.flags&CVLvalue != 0
}

// IsMethod returns true if :method attribute set.
// IsMethod, :method özelliği ayarlıysa true döndürür.
func (cv *CV) IsMethod() bool {
	return cv.flags&CVMethod != 0
}

// ============================================================
// Lexical Pad
// Leksikal Pad
// ============================================================

// PadNames returns the names of lexical variables.
// PadNames, leksikal değişken isimlerini döndürür.
func (cv *CV) PadNames() []string {
	return cv.padnames
}

// SetPadNames sets the lexical variable names.
// SetPadNames, leksikal değişken isimlerini ayarlar.
func (cv *CV) SetPadNames(names []string) {
	cv.padnames = names
}

// AddPadName adds a lexical variable name, returns its index.
// AddPadName, bir leksikal değişken adı ekler, indeksini döndürür.
func (cv *CV) AddPadName(name string) int {
	idx := len(cv.padnames)
	cv.padnames = append(cv.padnames, name)
	return idx
}

// PadIndex returns the index of a lexical variable by name (-1 if not found).
// PadIndex, isme göre leksikal değişkenin indeksini döndürür (bulunamazsa -1).
func (cv *CV) PadIndex(name string) int {
	for i, n := range cv.padnames {
		if n == name {
			return i
		}
	}
	return -1
}

// ============================================================
// Constant Subroutines
// Sabit Altyordamlar
// ============================================================

// NewConst creates a constant subroutine that always returns the same value.
// Used for: use constant FOO => 42;
//
// NewConst, her zaman aynı değeri döndüren sabit bir altyordam oluşturur.
// Kullanım: use constant FOO => 42;
func NewConst(pkg, name string, value *sv.SV) *CV {
	if value != nil {
		value.IncRef()
	}
	return &CV{
		name:  name,
		pkg:   pkg,
		flags: CVConst,
		native: func(ctx *CallContext) *sv.SV {
			return value
		},
	}
}

// IsConst returns true if this is a constant subroutine.
// IsConst, bu sabit bir altyordam ise true döndürür.
func (cv *CV) IsConst() bool {
	return cv.flags&CVConst != 0
}

// ============================================================
// XSUB support (for built-in functions)
// XSUB desteği (yerleşik fonksiyonlar için)
// ============================================================

// NewXSUB creates a CV for an external/built-in function.
// NewXSUB, harici/yerleşik bir fonksiyon için CV oluşturur.
func NewXSUB(pkg, name string, fn func(*CallContext) *sv.SV) *CV {
	return &CV{
		name:   name,
		pkg:    pkg,
		native: fn,
		flags:  CVIsXSUB,
	}
}

// IsXSUB returns true if this is an XSUB.
// IsXSUB, bu bir XSUB ise true döndürür.
func (cv *CV) IsXSUB() bool {
	return cv.flags&CVIsXSUB != 0
}

// ============================================================
// Cleanup
// Temizlik
// ============================================================

// Free releases all resources.
// Free, tüm kaynakları serbest bırakır.
func (cv *CV) Free() {
	for _, v := range cv.pad {
		if v != nil {
			v.DecRef()
		}
	}
	cv.pad = nil
	cv.outer = nil
	cv.ops = nil
	cv.native = nil
}

// ============================================================
// Context Helpers
// Bağlam Yardımcıları
// ============================================================

// WantArray returns context from CallContext (-1=void, 0=scalar, 1=list).
// WantArray, CallContext'ten bağlamı döndürür (-1=void, 0=skaler, 1=liste).
func (ctx *CallContext) WantArrayVal() int {
	if ctx == nil {
		return 0
	}
	return ctx.WantArray
}

// Arg returns argument at index, or undef if out of bounds.
// Arg, indeksteki argümanı döndürür, sınır dışıysa undef.
func (ctx *CallContext) Arg(i int) *sv.SV {
	if ctx == nil || i < 0 || i >= len(ctx.Args) {
		return sv.NewUndef()
	}
	return ctx.Args[i]
}

// NumArgs returns number of arguments.
// NumArgs, argüman sayısını döndürür.
func (ctx *CallContext) NumArgs() int {
	if ctx == nil {
		return 0
	}
	return len(ctx.Args)
}

// SetPad sets a lexical variable value.
// SetPad, bir leksikal değişken değeri ayarlar.
func (ctx *CallContext) SetPad(idx int, val *sv.SV) {
	if ctx == nil {
		return
	}
	if idx >= len(ctx.Pad) {
		newPad := make([]*sv.SV, idx+1)
		copy(newPad, ctx.Pad)
		ctx.Pad = newPad
	}
	if ctx.Pad[idx] != nil {
		ctx.Pad[idx].DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	ctx.Pad[idx] = val
}

// GetPad returns a lexical variable value.
// GetPad, bir leksikal değişken değeri döndürür.
func (ctx *CallContext) GetPad(idx int) *sv.SV {
	if ctx == nil || idx < 0 || idx >= len(ctx.Pad) {
		return sv.NewUndef()
	}
	if ctx.Pad[idx] == nil {
		return sv.NewUndef()
	}
	return ctx.Pad[idx]
}

// CallerInfo returns (package, file, line) of caller.
// CallerInfo, çağıranın (paket, dosya, satır) bilgisini döndürür.
func (ctx *CallContext) CallerInfo() (string, string, int) {
	if ctx == nil || ctx.Caller == nil {
		return "", "", 0
	}
	return ctx.Caller.Package, ctx.Caller.File, ctx.Caller.Line
}
```

## File: ./pkg/cv/cv_test.go
```go
package cv

import (
	"testing"

	"perlc/pkg/sv"
)

// ============================================================
// Basic Call Tests
// Temel Çağrı Testleri
// ============================================================

// TestBasicCall tests simple subroutine call.
// TestBasicCall, basit altyordam çağrısını test eder.
func TestBasicCall(t *testing.T) {
	add := New("main", "add", func(ctx *CallContext) *sv.SV {
		a := ctx.Arg(0).AsInt()
		b := ctx.Arg(1).AsInt()
		return sv.NewInt(a + b)
	})

	ctx := &CallContext{
		Args: []*sv.SV{sv.NewInt(2), sv.NewInt(3)},
	}

	result := add.Call(ctx)
	if result.AsInt() != 5 {
		t.Errorf("2 + 3 should be 5, got %d", result.AsInt())
	}
}

// TestCallNoArgs tests call without arguments.
// TestCallNoArgs, argümansız çağrıyı test eder.
func TestCallNoArgs(t *testing.T) {
	cv := New("main", "noargs", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(int64(ctx.NumArgs()))
	})

	result := cv.Call(&CallContext{})
	if result.AsInt() != 0 {
		t.Errorf("NumArgs should be 0, got %d", result.AsInt())
	}
}

// TestCallNilContext tests call with nil context.
// TestCallNilContext, nil bağlam ile çağrıyı test eder.
func TestCallNilContext(t *testing.T) {
	cv := New("main", "nilctx", func(ctx *CallContext) *sv.SV {
		if ctx == nil {
			return sv.NewString("nil")
		}
		return sv.NewString("ok")
	})

	result := cv.Call(nil)
	if result.AsString() != "ok" {
		t.Error("Context should be created if nil")
	}
}

// TestCallManyArgs tests call with many arguments.
// TestCallManyArgs, çok argümanla çağrıyı test eder.
func TestCallManyArgs(t *testing.T) {
	sum := New("main", "sum", func(ctx *CallContext) *sv.SV {
		total := int64(0)
		for i := 0; i < ctx.NumArgs(); i++ {
			total += ctx.Arg(i).AsInt()
		}
		return sv.NewInt(total)
	})

	args := make([]*sv.SV, 100)
	for i := range args {
		args[i] = sv.NewInt(int64(i + 1))
	}

	result := sum.Call(&CallContext{Args: args})
	// Sum of 1..100 = 5050
	if result.AsInt() != 5050 {
		t.Errorf("Sum of 1..100 should be 5050, got %d", result.AsInt())
	}
}

// TestArgOutOfBounds tests accessing non-existent argument.
// TestArgOutOfBounds, var olmayan argümana erişimi test eder.
func TestArgOutOfBounds(t *testing.T) {
	cv := New("main", "oob", func(ctx *CallContext) *sv.SV {
		return ctx.Arg(999) // Out of bounds
	})

	result := cv.Call(&CallContext{Args: []*sv.SV{sv.NewInt(1)}})
	if !result.IsUndef() {
		t.Error("Out of bounds arg should return undef")
	}

	// Negative index
	cv2 := New("main", "neg", func(ctx *CallContext) *sv.SV {
		return ctx.Arg(-1)
	})
	result2 := cv2.Call(&CallContext{Args: []*sv.SV{sv.NewInt(1)}})
	if !result2.IsUndef() {
		t.Error("Negative index should return undef")
	}
}

// ============================================================
// Anonymous Subroutine Tests
// Anonim Altyordam Testleri
// ============================================================

// TestAnonymousSub tests anonymous subroutine.
// TestAnonymousSub, anonim altyordamı test eder.
func TestAnonymousSub(t *testing.T) {
	anon := NewAnon("main", func(ctx *CallContext) *sv.SV {
		return sv.NewString("anonymous")
	})

	if !anon.IsAnon() {
		t.Error("Should be anonymous")
	}
	if anon.Name() != "" {
		t.Error("Anonymous sub should have empty name")
	}

	result := anon.Call(nil)
	if result.AsString() != "anonymous" {
		t.Error("Should return 'anonymous'")
	}
}

// TestMultipleAnonymous tests multiple anonymous subs don't interfere.
// TestMultipleAnonymous, birden fazla anonim alt yordamın karışmadığını test eder.
func TestMultipleAnonymous(t *testing.T) {
	anon1 := NewAnon("main", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(1)
	})
	anon2 := NewAnon("main", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(2)
	})

	if anon1.Call(nil).AsInt() != 1 {
		t.Error("anon1 should return 1")
	}
	if anon2.Call(nil).AsInt() != 2 {
		t.Error("anon2 should return 2")
	}
}

// ============================================================
// Closure Tests
// Closure Testleri
// ============================================================

// TestClosure tests closure capturing variables.
// TestClosure, değişken yakalayan closure'ı test eder.
func TestClosure(t *testing.T) {
	outer := New("main", "make_counter", func(ctx *CallContext) *sv.SV {
		val := ctx.GetPad(0).AsInt()
		val++
		ctx.SetPad(0, sv.NewInt(val))
		return sv.NewInt(val)
	})
	outer.SetPadNames([]string{"counter"})

	pad := []*sv.SV{sv.NewInt(0)}
	closure := NewClosure(outer, pad)

	if !closure.IsClosure() {
		t.Error("Should be closure")
	}

	ctx := &CallContext{Pad: make([]*sv.SV, 1)}
	ctx.Pad[0] = sv.NewInt(0)

	r1 := closure.Call(ctx)
	r2 := closure.Call(ctx)
	r3 := closure.Call(ctx)

	if r1.AsInt() != 1 || r2.AsInt() != 2 || r3.AsInt() != 3 {
		t.Errorf("Counter should be 1,2,3 got %d,%d,%d", r1.AsInt(), r2.AsInt(), r3.AsInt())
	}
}

// TestIndependentClosures tests that closures don't share state.
// TestIndependentClosures, closure'ların durumu paylaşmadığını test eder.
func TestIndependentClosures(t *testing.T) {
	makeCounter := func(start int64) *CV {
		outer := New("main", "counter", func(ctx *CallContext) *sv.SV {
			val := ctx.GetPad(0).AsInt()
			val++
			ctx.SetPad(0, sv.NewInt(val))
			return sv.NewInt(val)
		})
		outer.SetPadNames([]string{"n"})
		return NewClosure(outer, []*sv.SV{sv.NewInt(start)})
	}

	counter1 := makeCounter(0)
	counter2 := makeCounter(100)

	ctx1 := &CallContext{Pad: []*sv.SV{sv.NewInt(0)}}
	ctx2 := &CallContext{Pad: []*sv.SV{sv.NewInt(100)}}

	// Each closure should have independent state
	// Her closure bağımsız duruma sahip olmalı
	if counter1.Call(ctx1).AsInt() != 1 {
		t.Error("counter1 first call should be 1")
	}
	if counter2.Call(ctx2).AsInt() != 101 {
		t.Error("counter2 first call should be 101")
	}
	if counter1.Call(ctx1).AsInt() != 2 {
		t.Error("counter1 second call should be 2")
	}
}

// TestNestedClosures tests closures inside closures.
// TestNestedClosures, iç içe closure'ları test eder.
func TestNestedClosures(t *testing.T) {
	outer := New("main", "outer", func(ctx *CallContext) *sv.SV {
		x := ctx.GetPad(0).AsInt()
		y := ctx.GetPad(1).AsInt()
		return sv.NewInt(x + y)
	})
	outer.SetPadNames([]string{"x", "y"})

	closure := NewClosure(outer, []*sv.SV{sv.NewInt(10), sv.NewInt(20)})

	ctx := &CallContext{Pad: []*sv.SV{sv.NewInt(10), sv.NewInt(20)}}
	result := closure.Call(ctx)

	if result.AsInt() != 30 {
		t.Errorf("10 + 20 should be 30, got %d", result.AsInt())
	}
}

// ============================================================
// Prototype Tests
// Prototip Testleri
// ============================================================

// TestPrototype tests subroutine prototype.
// TestPrototype, altyordam prototipini test eder.
func TestPrototype(t *testing.T) {
	cv := NewWithProto("main", "mysub", "$$@", func(ctx *CallContext) *sv.SV {
		return sv.NewUndef()
	})

	if cv.Prototype() != "$$@" {
		t.Errorf("Prototype should be '$$@', got '%s'", cv.Prototype())
	}
	if !cv.HasProto() {
		t.Error("Should have prototype flag")
	}
}

// TestSetPrototype tests setting prototype after creation.
// TestSetPrototype, oluşturulduktan sonra prototip ayarlamayı test eder.
func TestSetPrototype(t *testing.T) {
	cv := New("main", "mysub", nil)

	if cv.HasProto() {
		t.Error("Should not have prototype initially")
	}

	cv.SetPrototype(`\@`)
	if cv.Prototype() != `\@` {
		t.Errorf("Prototype should be '\\@', got '%s'", cv.Prototype())
	}
	if !cv.HasProto() {
		t.Error("Should have prototype after set")
	}
}

// TestEmptyPrototype tests empty prototype (no args).
// TestEmptyPrototype, boş prototipi (argümansız) test eder.
func TestEmptyPrototype(t *testing.T) {
	cv := NewWithProto("main", "noargs", "", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(42)
	})

	// Empty string is still a prototype
	// Boş string yine de bir prototiptir
	if cv.Prototype() != "" {
		t.Error("Prototype should be empty string")
	}
}

// ============================================================
// Constant Subroutine Tests
// Sabit Altyordam Testleri
// ============================================================

// TestConst tests constant subroutine.
// TestConst, sabit altyordamı test eder.
func TestConst(t *testing.T) {
	pi := NewConst("main", "PI", sv.NewFloat(3.14159))

	if !pi.IsConst() {
		t.Error("Should be constant")
	}

	result := pi.Call(nil)
	if result.AsFloat() != 3.14159 {
		t.Errorf("PI should be 3.14159, got %f", result.AsFloat())
	}

	// Calling multiple times should return same value
	// Birden fazla çağrı aynı değeri döndürmeli
	result2 := pi.Call(nil)
	if result2.AsFloat() != 3.14159 {
		t.Error("Constant should always return same value")
	}
}

// TestConstString tests string constant.
// TestConstString, string sabiti test eder.
func TestConstString(t *testing.T) {
	version := NewConst("main", "VERSION", sv.NewString("1.0.0"))

	if version.Call(nil).AsString() != "1.0.0" {
		t.Error("VERSION should be '1.0.0'")
	}
}

// TestConstUndef tests undef constant.
// TestConstUndef, undef sabitini test eder.
func TestConstUndef(t *testing.T) {
	undef := NewConst("main", "UNDEF", sv.NewUndef())

	if !undef.Call(nil).IsUndef() {
		t.Error("UNDEF constant should return undef")
	}
}

// ============================================================
// Attribute Tests
// Özellik Testleri
// ============================================================

// TestAttributes tests subroutine attributes.
// TestAttributes, altyordam özelliklerini test eder.
func TestAttributes(t *testing.T) {
	cv := New("main", "mysub", func(ctx *CallContext) *sv.SV {
		return sv.NewUndef()
	})

	cv.SetAttr("lvalue", "")
	cv.SetAttr("method", "")

	if !cv.IsLvalue() {
		t.Error("Should have lvalue attribute")
	}
	if !cv.IsMethod() {
		t.Error("Should have method attribute")
	}
}

// TestGetAttr tests getting attribute values.
// TestGetAttr, özellik değerlerini almayı test eder.
func TestGetAttr(t *testing.T) {
	cv := New("main", "mysub", nil)

	cv.SetAttr("custom", "myvalue")

	val, ok := cv.GetAttr("custom")
	if !ok {
		t.Error("Should find 'custom' attribute")
	}
	if val != "myvalue" {
		t.Errorf("Attribute value should be 'myvalue', got '%s'", val)
	}

	_, ok = cv.GetAttr("nonexistent")
	if ok {
		t.Error("Should not find 'nonexistent' attribute")
	}
}

// TestLockedAttribute tests :locked attribute.
// TestLockedAttribute, :locked özelliğini test eder.
func TestLockedAttribute(t *testing.T) {
	cv := New("main", "mysub", nil)
	cv.SetAttr("locked", "")

	if cv.flags&CVLocked == 0 {
		t.Error("Should have locked flag")
	}
}

// ============================================================
// Name and Package Tests
// İsim ve Paket Testleri
// ============================================================

// TestFullName tests name formatting.
// TestFullName, isim biçimlendirmesini test eder.
func TestFullName(t *testing.T) {
	tests := []struct {
		pkg    string
		name   string
		expect string
	}{
		{"MyPkg", "foo", "MyPkg::foo"},
		{"main", "bar", "bar"},
		{"", "baz", "baz"},
		{"A::B::C", "method", "A::B::C::method"},
	}

	for _, tt := range tests {
		cv := New(tt.pkg, tt.name, nil)
		if cv.FullName() != tt.expect {
			t.Errorf("FullName(%s, %s) = '%s', want '%s'",
				tt.pkg, tt.name, cv.FullName(), tt.expect)
		}
	}
}

// TestAnonFullName tests anonymous sub full name.
// TestAnonFullName, anonim altyordam tam adını test eder.
func TestAnonFullName(t *testing.T) {
	anon := NewAnon("MyPkg", nil)
	if anon.FullName() != "MyPkg::__ANON__" {
		t.Errorf("Expected 'MyPkg::__ANON__', got '%s'", anon.FullName())
	}
}

// ============================================================
// Context Tests
// Bağlam Testleri
// ============================================================

// TestWantArray tests context detection.
// TestWantArray, bağlam algılamayı test eder.
func TestWantArray(t *testing.T) {
	cv := New("main", "context_test", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(int64(ctx.WantArrayVal()))
	})

	tests := []struct {
		wantArray int
		expect    int64
	}{
		{-1, -1}, // void
		{0, 0},   // scalar
		{1, 1},   // list
	}

	for _, tt := range tests {
		ctx := &CallContext{WantArray: tt.wantArray}
		result := cv.Call(ctx)
		if result.AsInt() != tt.expect {
			t.Errorf("WantArray %d should return %d, got %d",
				tt.wantArray, tt.expect, result.AsInt())
		}
	}
}

// TestCallList tests list context call.
// TestCallList, liste bağlamı çağrısını test eder.
func TestCallList(t *testing.T) {
	cv := New("main", "list_return", func(ctx *CallContext) *sv.SV {
		arr := sv.NewArrayRef(
			sv.NewInt(1),
			sv.NewInt(2),
			sv.NewInt(3),
		)
		return arr
	})

	results := cv.CallList(nil)
	if len(results) != 3 {
		t.Errorf("Should return 3 elements, got %d", len(results))
	}
}

// TestCallListScalar tests CallList with scalar return.
// TestCallListScalar, skaler dönüşlü CallList'i test eder.
func TestCallListScalar(t *testing.T) {
	cv := New("main", "scalar_return", func(ctx *CallContext) *sv.SV {
		return sv.NewInt(42)
	})

	results := cv.CallList(nil)
	if len(results) != 1 {
		t.Errorf("Should return 1 element, got %d", len(results))
	}
	if results[0].AsInt() != 42 {
		t.Error("Element should be 42")
	}
}

// TestCallListNil tests CallList with nil return.
// TestCallListNil, nil dönüşlü CallList'i test eder.
func TestCallListNil(t *testing.T) {
	cv := New("main", "nil_return", func(ctx *CallContext) *sv.SV {
		return nil
	})

	results := cv.CallList(nil)
	if len(results) != 0 {
		t.Errorf("Should return 0 elements for nil, got %d", len(results))
	}
}

// ============================================================
// Pad (Lexical Variables) Tests
// Pad (Leksikal Değişkenler) Testleri
// ============================================================

// TestPadNames tests lexical variable name management.
// TestPadNames, leksikal değişken isim yönetimini test eder.
func TestPadNames(t *testing.T) {
	cv := New("main", "lexicals", nil)

	idx1 := cv.AddPadName("$x")
	idx2 := cv.AddPadName("$y")
	idx3 := cv.AddPadName("@arr")

	if idx1 != 0 || idx2 != 1 || idx3 != 2 {
		t.Error("Pad indices should be sequential")
	}

	names := cv.PadNames()
	if len(names) != 3 {
		t.Errorf("Should have 3 pad names, got %d", len(names))
	}
}

// TestPadIndex tests looking up pad index by name.
// TestPadIndex, isme göre pad indeksi aramayı test eder.
func TestPadIndex(t *testing.T) {
	cv := New("main", "lookup", nil)
	cv.SetPadNames([]string{"$a", "$b", "$c"})

	if cv.PadIndex("$a") != 0 {
		t.Error("$a should be at index 0")
	}
	if cv.PadIndex("$c") != 2 {
		t.Error("$c should be at index 2")
	}
	if cv.PadIndex("$missing") != -1 {
		t.Error("Missing name should return -1")
	}
}

// TestCtxPadOperations tests context pad get/set.
// TestCtxPadOperations, bağlam pad get/set işlemlerini test eder.
func TestCtxPadOperations(t *testing.T) {
	ctx := &CallContext{}

	// Set should auto-extend
	// Set otomatik genişletmeli
	ctx.SetPad(5, sv.NewInt(42))

	if len(ctx.Pad) < 6 {
		t.Error("Pad should auto-extend")
	}

	val := ctx.GetPad(5)
	if val.AsInt() != 42 {
		t.Errorf("Pad[5] should be 42, got %d", val.AsInt())
	}

	// Out of bounds should return undef
	// Sınır dışı undef döndürmeli
	if !ctx.GetPad(100).IsUndef() {
		t.Error("Out of bounds should return undef")
	}
}

// ============================================================
// Caller Info Tests
// Çağıran Bilgisi Testleri
// ============================================================

// TestCallerInfo tests caller information retrieval.
// TestCallerInfo, çağıran bilgisi almayı test eder.
func TestCallerInfo(t *testing.T) {
	callerCtx := &CallContext{
		Package: "CallerPkg",
		File:    "test.pl",
		Line:    42,
	}

	ctx := &CallContext{
		Caller: callerCtx,
	}

	pkg, file, line := ctx.CallerInfo()
	if pkg != "CallerPkg" {
		t.Errorf("Caller package should be 'CallerPkg', got '%s'", pkg)
	}
	if file != "test.pl" {
		t.Errorf("Caller file should be 'test.pl', got '%s'", file)
	}
	if line != 42 {
		t.Errorf("Caller line should be 42, got %d", line)
	}
}

// TestCallerInfoNil tests caller info with no caller.
// TestCallerInfoNil, çağıran olmadan çağıran bilgisini test eder.
func TestCallerInfoNil(t *testing.T) {
	ctx := &CallContext{}
	pkg, file, line := ctx.CallerInfo()

	if pkg != "" || file != "" || line != 0 {
		t.Error("No caller should return empty values")
	}

	// Nil context
	var nilCtx *CallContext
	pkg, file, line = nilCtx.CallerInfo()
	if pkg != "" || file != "" || line != 0 {
		t.Error("Nil context should return empty values")
	}
}

// ============================================================
// XSUB Tests
// XSUB Testleri
// ============================================================

// TestXSUB tests external subroutine flag.
// TestXSUB, harici altyordam bayrağını test eder.
func TestXSUB(t *testing.T) {
	xsub := NewXSUB("main", "builtin", func(ctx *CallContext) *sv.SV {
		return sv.NewString("builtin result")
	})

	if !xsub.IsXSUB() {
		t.Error("Should be XSUB")
	}

	result := xsub.Call(nil)
	if result.AsString() != "builtin result" {
		t.Error("XSUB should execute correctly")
	}
}

// ============================================================
// Free/Cleanup Tests
// Serbest Bırakma/Temizlik Testleri
// ============================================================

// TestFree tests resource cleanup.
// TestFree, kaynak temizliğini test eder.
func TestFree(t *testing.T) {
	pad := []*sv.SV{sv.NewInt(1), sv.NewInt(2)}
	for _, v := range pad {
		v.IncRef() // Simulate extra reference
	}

	outer := New("main", "test", nil)
	closure := NewClosure(outer, pad)

	// Free should not panic
	// Free panic yapmamalı
	closure.Free()

	if closure.pad != nil {
		t.Error("Pad should be nil after free")
	}
}

// ============================================================
// Edge Cases
// Sınır Durumları
// ============================================================

// TestNilNativeFunction tests CV with nil native function.
// TestNilNativeFunction, nil native fonksiyonlu CV'yi test eder.
func TestNilNativeFunction(t *testing.T) {
	cv := New("main", "nil_native", nil)

	result := cv.Call(nil)
	if !result.IsUndef() {
		t.Error("Nil native function should return undef")
	}
}

// TestEmptyOps tests CV with empty ops slice.
// TestEmptyOps, boş ops dilimli CV'yi test eder.
func TestEmptyOps(t *testing.T) {
	cv := &CV{
		name: "empty_ops",
		pkg:  "main",
		ops:  []Op{},
	}

	result := cv.Call(nil)
	if result != nil && !result.IsUndef() {
		t.Error("Empty ops should return nil or undef")
	}
}

// TestMixedTypeArgs tests arguments with mixed types.
// TestMixedTypeArgs, karışık türlü argümanları test eder.
func TestMixedTypeArgs(t *testing.T) {
	cv := New("main", "mixed", func(ctx *CallContext) *sv.SV {
		result := ""
		for i := 0; i < ctx.NumArgs(); i++ {
			result += ctx.Arg(i).AsString() + ","
		}
		return sv.NewString(result)
	})

	ctx := &CallContext{
		Args: []*sv.SV{
			sv.NewInt(42),
			sv.NewString("hello"),
			sv.NewFloat(3.14),
			sv.NewUndef(),
		},
	}

	result := cv.Call(ctx)
	if result.AsString() != "42,hello,3.14,," {
		t.Errorf("Mixed args should concat correctly, got '%s'", result.AsString())
	}
}
```

## File: ./pkg/deps/detector.go
```go
// pkg/deps/detector.go
package deps

import (
	"archive/tar"
	"compress/gzip"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

type ModuleInfo struct {
	Name         string
	Version      string
	HasXS        bool
	XSFiles      []string
	PurePerl     []string
	Dependencies []string
	LocalPath    string
}

// AnalyzeModule анализирует модуль и возвращает информацию о нём
func AnalyzeModule(moduleName string) (*ModuleInfo, error) {
	// Ищем локально
	if info := findLocal(moduleName); info != nil {
		return info, nil
	}

	// Скачиваем с CPAN
	path, err := downloadFromCPAN(moduleName)
	if err != nil {
		return nil, err
	}

	// Анализируем содержимое
	info := &ModuleInfo{Name: moduleName, LocalPath: path}

	err = filepath.Walk(path, func(p string, f os.FileInfo, err error) error {
		if err != nil {
			return nil
		}
		if f.IsDir() {
			return nil
		}

		switch filepath.Ext(p) {
		case ".xs":
			info.HasXS = true
			info.XSFiles = append(info.XSFiles, p)
		case ".pm":
			info.PurePerl = append(info.PurePerl, p)
		}
		return nil
	})

	if err != nil {
		return nil, err
	}

	// Парсим зависимости
	info.Dependencies = parseDependencies(path)

	return info, nil
}

// findLocal ищет модуль в локальных путях
func findLocal(moduleName string) *ModuleInfo {
	// Конвертируем Module::Name в путь Module/Name
	relPath := strings.ReplaceAll(moduleName, "::", "/")

	searchPaths := []string{
		".",
		"lib",
		"local/lib/perl5",
	}

	// Добавляем пути из PERL5LIB
	if perl5lib := os.Getenv("PERL5LIB"); perl5lib != "" {
		searchPaths = append(searchPaths, strings.Split(perl5lib, ":")...)
	}

	for _, base := range searchPaths {
		pmPath := filepath.Join(base, relPath+".pm")
		if _, err := os.Stat(pmPath); err == nil {
			info := &ModuleInfo{
				Name:      moduleName,
				LocalPath: base,
			}
			info.PurePerl = append(info.PurePerl, pmPath)

			// Проверяем наличие XS
			xsPath := filepath.Join(base, relPath+".xs")
			if _, err := os.Stat(xsPath); err == nil {
				info.HasXS = true
				info.XSFiles = append(info.XSFiles, xsPath)
			}

			return info
		}
	}

	return nil
}

// downloadFromCPAN скачивает модуль с CPAN
func downloadFromCPAN(moduleName string) (string, error) {
	// Получаем URL для скачивания через MetaCPAN API
	apiURL := fmt.Sprintf("https://fastapi.metacpan.org/v1/download_url/%s", moduleName)

	resp, err := http.Get(apiURL)
	if err != nil {
		return "", fmt.Errorf("failed to query MetaCPAN: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("module %s not found on CPAN", moduleName)
	}

	var result struct {
		DownloadURL string `json:"download_url"`
		Version     string `json:"version"`
	}

	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return "", fmt.Errorf("failed to parse MetaCPAN response: %w", err)
	}

	// Создаём директорию для кэша
	cacheDir := getCacheDir()
	moduleDir := filepath.Join(cacheDir, "modules", moduleName)
	if err := os.MkdirAll(moduleDir, 0755); err != nil {
		return "", err
	}

	// Скачиваем архив
	tarPath := filepath.Join(moduleDir, "module.tar.gz")
	if err := downloadFile(result.DownloadURL, tarPath); err != nil {
		return "", err
	}

	// Распаковываем
	extractDir := filepath.Join(moduleDir, "src")
	if err := extractTarGz(tarPath, extractDir); err != nil {
		return "", err
	}

	return extractDir, nil
}

// downloadFile скачивает файл по URL
func downloadFile(url, destPath string) error {
	resp, err := http.Get(url)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	out, err := os.Create(destPath)
	if err != nil {
		return err
	}
	defer out.Close()

	_, err = io.Copy(out, resp.Body)
	return err
}

// extractTarGz распаковывает tar.gz архив
func extractTarGz(tarPath, destDir string) error {
	if err := os.MkdirAll(destDir, 0755); err != nil {
		return err
	}

	// Открываем файл
	file, err := os.Open(tarPath)
	if err != nil {
		return err
	}
	defer file.Close()

	// Распаковываем gzip
	gzr, err := gzip.NewReader(file)
	if err != nil {
		return err
	}
	defer gzr.Close()

	// Читаем tar
	tr := tar.NewReader(gzr)

	for {
		header, err := tr.Next()
		if err == io.EOF {
			break
		}
		if err != nil {
			return err
		}

		// Целевой путь
		target := filepath.Join(destDir, header.Name)

		// Защита от path traversal
		if !strings.HasPrefix(target, filepath.Clean(destDir)+string(os.PathSeparator)) {
			return fmt.Errorf("invalid file path: %s", header.Name)
		}

		switch header.Typeflag {
		case tar.TypeDir:
			if err := os.MkdirAll(target, 0755); err != nil {
				return err
			}
		case tar.TypeReg:
			// Создаём директорию если нужно
			if err := os.MkdirAll(filepath.Dir(target), 0755); err != nil {
				return err
			}

			// Создаём файл
			outFile, err := os.Create(target)
			if err != nil {
				return err
			}

			// Копируем содержимое
			if _, err := io.Copy(outFile, tr); err != nil {
				outFile.Close()
				return err
			}
			outFile.Close()
		}
	}

	return nil
}

// parseDependencies парсит зависимости из META.json или Makefile.PL
func parseDependencies(modulePath string) []string {
	var deps []string

	// Пробуем META.json
	metaPath := filepath.Join(modulePath, "META.json")
	if data, err := os.ReadFile(metaPath); err == nil {
		deps = append(deps, parseMetaJSON(data)...)
		return deps
	}

	// Пробуем META.yml
	metaYmlPath := filepath.Join(modulePath, "META.yml")
	if data, err := os.ReadFile(metaYmlPath); err == nil {
		deps = append(deps, parseMetaYAML(data)...)
		return deps
	}

	// Пробуем MYMETA.json
	mymetaPath := filepath.Join(modulePath, "MYMETA.json")
	if data, err := os.ReadFile(mymetaPath); err == nil {
		deps = append(deps, parseMetaJSON(data)...)
		return deps
	}

	return deps
}

// parseMetaJSON парсит зависимости из META.json
func parseMetaJSON(data []byte) []string {
	var meta struct {
		Prereqs struct {
			Runtime struct {
				Requires map[string]string `json:"requires"`
			} `json:"runtime"`
			Build struct {
				Requires map[string]string `json:"requires"`
			} `json:"build"`
			Configure struct {
				Requires map[string]string `json:"requires"`
			} `json:"configure"`
		} `json:"prereqs"`
	}

	var deps []string

	if err := json.Unmarshal(data, &meta); err != nil {
		return deps
	}

	for dep := range meta.Prereqs.Runtime.Requires {
		if !isCoreMod(dep) {
			deps = append(deps, dep)
		}
	}

	return deps
}

// parseMetaYAML парсит зависимости из META.yml (упрощённо)
func parseMetaYAML(data []byte) []string {
	var deps []string

	lines := strings.Split(string(data), "\n")
	inRequires := false

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		if strings.HasPrefix(trimmed, "requires:") {
			inRequires = true
			continue
		}

		if inRequires {
			if !strings.HasPrefix(line, " ") && !strings.HasPrefix(line, "\t") {
				inRequires = false
				continue
			}

			// Формат: "  Module::Name: version"
			parts := strings.SplitN(trimmed, ":", 2)
			if len(parts) >= 1 {
				dep := strings.TrimSpace(parts[0])
				if dep != "" && !isCoreMod(dep) {
					deps = append(deps, dep)
				}
			}
		}
	}

	return deps
}

// isCoreMod проверяет, является ли модуль частью ядра Perl
func isCoreMod(name string) bool {
	coreMods := map[string]bool{
		"perl":                true,
		"strict":              true,
		"warnings":            true,
		"Exporter":            true,
		"Carp":                true,
		"File::Spec":          true,
		"File::Path":          true,
		"Data::Dumper":        true,
		"Storable":            true,
		"Getopt::Long":        true,
		"Pod::Usage":          true,
		"Test::More":          true,
		"Test::Simple":        true,
		"ExtUtils::MakeMaker": true,
	}
	return coreMods[name]
}

// getCacheDir возвращает директорию для кэша
func getCacheDir() string {
	// Сначала проверяем переменную окружения
	if cacheDir := os.Getenv("PERLC_CACHE"); cacheDir != "" {
		return cacheDir
	}

	// Используем домашнюю директорию
	home, err := os.UserHomeDir()
	if err != nil {
		home = "."
	}

	return filepath.Join(home, ".perlc", "cache")
}

// GetCachedModule возвращает закэшированный Go код модуля
func GetCachedModule(moduleName, version string) (string, bool) {
	cacheDir := getCacheDir()
	cachedFile := filepath.Join(cacheDir, "compiled", moduleName, version+".go")

	data, err := os.ReadFile(cachedFile)
	if err != nil {
		return "", false
	}

	return string(data), true
}

// CacheModule сохраняет скомпилированный модуль в кэш
func CacheModule(moduleName, version, goCode string) error {
	cacheDir := getCacheDir()
	dir := filepath.Join(cacheDir, "compiled", moduleName)

	if err := os.MkdirAll(dir, 0755); err != nil {
		return err
	}

	cachedFile := filepath.Join(dir, version+".go")
	return os.WriteFile(cachedFile, []byte(goCode), 0644)
}
```

## File: ./pkg/eval/builtins.go
```go
// Package eval - builtin functions
package eval

import (
	"fmt"
	"math"
	"os"
	"strings"

	"perlc/pkg/ast"
	"perlc/pkg/av"
	"perlc/pkg/hv"
	"perlc/pkg/sv"
)

func (i *Interpreter) builtinPrint(expr *ast.CallExpr) *sv.SV {
	// Check if first arg is filehandle
	if len(expr.Args) >= 2 {
		if fhVar, ok := expr.Args[0].(*ast.ScalarVar); ok {
			fhName := i.ctx.GetVar(fhVar.Name)
			if fhName != nil {
				fh := i.ctx.GetFileHandle(fhName.AsString())
				if fh != nil && fh.Writer != nil {
					for _, arg := range expr.Args[1:] {
						val := i.evalExpression(arg)
						fh.Writer.WriteString(val.AsString())
					}
					return sv.NewInt(1)
				}
			}
		}
	}
	// Normal print to stdout
	for _, arg := range expr.Args {
		val := i.evalExpression(arg)
		fmt.Fprint(i.stdout, val.AsString())
	}
	return sv.NewInt(1)
}

func (i *Interpreter) builtinSay(expr *ast.CallExpr) *sv.SV {
	// Check if first arg is filehandle
	if len(expr.Args) >= 2 {
		if fhVar, ok := expr.Args[0].(*ast.ScalarVar); ok {
			fhName := i.ctx.GetVar(fhVar.Name)
			if fhName != nil {
				fh := i.ctx.GetFileHandle(fhName.AsString())
				if fh != nil && fh.Writer != nil {
					for _, arg := range expr.Args[1:] {
						val := i.evalExpression(arg)
						fh.Writer.WriteString(val.AsString())
					}
					fh.Writer.WriteString("\n")
					return sv.NewInt(1)
				}
			}
		}
	}
	// Normal say to stdout
	for _, arg := range expr.Args {
		val := i.evalExpression(arg)
		fmt.Fprint(i.stdout, val.AsString())
	}
	fmt.Fprintln(i.stdout)
	return sv.NewInt(1)
}

func (i *Interpreter) builtinOpen(expr *ast.CallExpr) *sv.SV {
	if len(expr.Args) < 2 {
		return sv.NewInt(0)
	}

	var fhName string
	switch fh := expr.Args[0].(type) {
	case *ast.ScalarVar:
		fhName = fh.Name
	case *ast.Identifier:
		fhName = fh.Value
	}

	mode := i.evalExpression(expr.Args[1]).AsString()
	var filename string

	if len(expr.Args) >= 3 && expr.Args[2] != nil {
		filename = i.evalExpression(expr.Args[2]).AsString()
	} else {
		// 2-arg form: extract filename from mode
		if len(mode) > 0 {
			switch mode[0] {
			case '<':
				filename = strings.TrimSpace(mode[1:])
				mode = "<"
			case '>':
				if len(mode) > 1 && mode[1] == '>' {
					filename = strings.TrimSpace(mode[2:])
					mode = ">>"
				} else {
					filename = strings.TrimSpace(mode[1:])
					mode = ">"
				}
			}
		}
	}

	err := i.ctx.OpenFile(fhName, mode, filename)
	if err != nil {
		return sv.NewInt(0)
	}
	i.ctx.SetVar(fhName, sv.NewString(fhName))
	return sv.NewInt(1)
}

func (i *Interpreter) builtinClose(expr *ast.CallExpr) *sv.SV {
	if len(expr.Args) < 1 {
		return sv.NewInt(0)
	}

	var fhName string
	switch fh := expr.Args[0].(type) {
	case *ast.ScalarVar:
		fhName = fh.Name
	case *ast.Identifier:
		fhName = fh.Value
	default:
		fhName = i.evalExpression(expr.Args[0]).AsString()
	}

	err := i.ctx.CloseFile(fhName)
	if err != nil {
		return sv.NewInt(0)
	}
	return sv.NewInt(1)
}

func (i *Interpreter) builtinPush(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	if len(exprs) < 2 {
		return sv.NewInt(0)
	}

	// Get the array variable
	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		for _, val := range args[1:] {
			av.Push(arrSV, val)
		}
		return av.Len(arrSV)
	}
	return sv.NewInt(0)
}

func (i *Interpreter) builtinPop(exprs []ast.Expression) *sv.SV {
	if len(exprs) == 0 {
		return sv.NewUndef()
	}

	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		return av.Pop(arrSV)
	}
	return sv.NewUndef()
}

func (i *Interpreter) builtinShift(exprs []ast.Expression) *sv.SV {
	if len(exprs) == 0 {
		// shift without args shifts @_
		args := i.ctx.GetArgs()
		return av.Shift(args)
	}

	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		return av.Shift(arrSV)
	}
	return sv.NewUndef()
}

func (i *Interpreter) builtinUnshift(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	if len(exprs) < 2 {
		return sv.NewInt(0)
	}

	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		return av.Unshift(arrSV, args[1:]...)
	}
	return sv.NewInt(0)
}

func (i *Interpreter) builtinKeys(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewArrayRef()
	}
	keys := hv.Keys(args[0])
	return sv.NewArrayRef(keys...)
}

func (i *Interpreter) builtinValues(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewArrayRef()
	}
	vals := hv.Values(args[0])
	return sv.NewArrayRef(vals...)
}

func (i *Interpreter) builtinJoin(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewString("")
	}
	return av.Join(args[0], args[1])
}

func (i *Interpreter) builtinSplit(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewArrayRef()
	}
	pattern := args[0].AsString()
	str := args[1].AsString()
	parts := strings.Split(str, pattern)
	elements := make([]*sv.SV, len(parts))
	for idx, p := range parts {
		elements[idx] = sv.NewString(p)
	}
	return sv.NewArrayRef(elements...)
}

func (i *Interpreter) builtinSubstr(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewUndef()
	}
	var length *sv.SV
	if len(args) >= 3 {
		length = args[2]
	}
	return sv.Substr(args[0], args[1], length)
}

func (i *Interpreter) builtinAbs(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewFloat(0)
	}
	return sv.NewFloat(math.Abs(args[0].AsFloat()))
}

func (i *Interpreter) builtinSqrt(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewFloat(0)
	}
	return sv.NewFloat(math.Sqrt(args[0].AsFloat()))
}

func (i *Interpreter) builtinChr(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewString("")
	}
	return sv.NewString(string(rune(args[0].AsInt())))
}

func (i *Interpreter) builtinOrd(args []*sv.SV) *sv.SV {
	if len(args) == 0 {
		return sv.NewUndef()
	}
	s := args[0].AsString()
	if len(s) == 0 {
		return sv.NewUndef()
	}
	return sv.NewInt(int64([]rune(s)[0]))
}

func (i *Interpreter) builtinChomp(exprs []ast.Expression) *sv.SV {
	if len(exprs) == 0 {
		return sv.NewInt(0)
	}

	count := int64(0)
	for _, expr := range exprs {
		if v, ok := expr.(*ast.ScalarVar); ok {
			val := i.ctx.GetVar(v.Name)
			s := val.AsString()
			if strings.HasSuffix(s, "\n") {
				s = strings.TrimSuffix(s, "\n")
				i.ctx.SetVar(v.Name, sv.NewString(s))
				count++
			}
		}
	}
	return sv.NewInt(count)
}

func (i *Interpreter) builtinDie(args []*sv.SV) *sv.SV {
	msg := ""
	for _, arg := range args {
		msg += arg.AsString()
	}
	if msg == "" {
		msg = "Died"
	}
	if !strings.HasSuffix(msg, "\n") {
		msg += "\n"
	}
	fmt.Fprint(i.stderr, msg)
	os.Exit(1)
	return sv.NewUndef()
}

func (i *Interpreter) builtinWarn(args []*sv.SV) *sv.SV {
	msg := ""
	for _, arg := range args {
		msg += arg.AsString()
	}
	if !strings.HasSuffix(msg, "\n") {
		msg += "\n"
	}
	fmt.Fprint(i.stderr, msg)
	return sv.NewInt(1)
}

func (i *Interpreter) builtinExit(args []*sv.SV) *sv.SV {
	code := 0
	if len(args) > 0 {
		code = int(args[0].AsInt())
	}
	os.Exit(code)
	return sv.NewUndef()
}

func (i *Interpreter) builtinScalar(args []*sv.SV) *sv.SV {

	if len(args) == 0 {
		return sv.NewUndef()
	}
	// If array ref, return length
	if args[0].IsRef() {
		target := args[0].Deref()
		if target != nil && target.IsArray() {
			return sv.NewInt(int64(len(target.ArrayData())))
		}
	}
	if args[0].IsArray() {
		return sv.NewInt(int64(len(args[0].ArrayData())))
	}
	return args[0]
}

// ============================================================
// OOP Built-ins
// ============================================================

// builtinBless implements bless($ref, $class)
// Returns the blessed reference
func (i *Interpreter) builtinBless(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	_ = exprs
	if len(args) == 0 {
		return sv.NewUndef()
	}

	ref := args[0]
	if !ref.IsRef() {
		// Can only bless references
		return sv.NewUndef()
	}

	// Get package name - default to current package or caller's package
	pkgName := "main"
	if len(args) >= 2 {
		pkgName = args[1].AsString()
	}

	// Bless the reference into the package
	ref.Bless(pkgName)
	return ref
}

// builtinIsa implements $obj->isa('ClassName') or UNIVERSAL::isa($obj, 'ClassName')
// Returns true if $obj is a member of ClassName
func (i *Interpreter) builtinIsa(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewInt(0)
	}

	obj := args[0]
	className := args[1].AsString()

	// Check if object is blessed
	if !obj.IsRef() || !obj.IsBlessed() {
		return sv.NewInt(0)
	}

	// Direct class check
	if obj.Package() == className {
		return sv.NewInt(1)
	}

	// TODO: Check @ISA inheritance chain
	return sv.NewInt(0)
}

// builtinCan implements $obj->can('method') or UNIVERSAL::can($obj, 'method')
// Returns coderef if $obj can do method, undef otherwise
func (i *Interpreter) builtinCan(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewUndef()
	}

	obj := args[0]
	methodName := args[1].AsString()

	var pkgName string
	if obj.IsRef() && obj.IsBlessed() {
		pkgName = obj.Package()
	} else {
		// Assume it's a class name
		pkgName = obj.AsString()
	}

	// Try to find the method using FindMethod (includes @ISA)
	if found := i.ctx.FindMethod(pkgName, methodName); found != "" {
		return sv.NewInt(1)
	}

	// Try just the method name
	if i.ctx.GetSub(methodName) != nil {
		return sv.NewInt(1)
	}

	return sv.NewUndef()
}

// builtinSetIsa sets the @ISA for a package
// set_isa('Child', 'Parent1', 'Parent2', ...)
func (i *Interpreter) builtinSetIsa(args []*sv.SV) *sv.SV {
	if len(args) < 2 {
		return sv.NewInt(0)
	}

	pkg := args[0].AsString()
	parents := make([]string, len(args)-1)
	for idx, arg := range args[1:] {
		parents[idx] = arg.AsString()
	}

	i.ctx.SetPackageISA(pkg, parents)
	return sv.NewInt(1)
}
```

## File: ./pkg/eval/builtins_additions.go
```go
// Дополнения для pkg/eval/builtins.go
// Добавить в switch в evalCallExpr после case "scalar":

/*
Добавь в evalCallExpr (pkg/eval/eval.go) в switch funcName эти case:

	case "reverse":
		return i.builtinReverse(expr.Args, args)
	case "sort":
		return i.builtinSort(expr.Args, args)
	case "exists":
		return i.builtinExists(expr)
	case "delete":
		return i.builtinDelete(expr)
*/

// Добавить эти функции в pkg/eval/builtins.go:

package eval

import (
	"perlc/pkg/ast"
	"perlc/pkg/av"
	"perlc/pkg/hv"
	"perlc/pkg/sv"
	"sort"
)

func (i *Interpreter) builtinReverse(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	if len(exprs) == 0 {
		return sv.NewArrayRef()
	}

	// Проверяем, если аргумент - переменная массива
	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		if arrSV == nil || (!arrSV.IsArray() && !arrSV.IsRef()) {
			return sv.NewArrayRef()
		}

		// Получаем данные
		var elements []*sv.SV
		if arrSV.IsRef() {
			deref := arrSV.Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if arrSV.IsArray() {
			elements = arrSV.ArrayData()
		}

		if elements == nil {
			return sv.NewArrayRef()
		}

		// Создаём новый массив с элементами в обратном порядке
		reversed := make([]*sv.SV, len(elements))
		for i, j := 0, len(elements)-1; j >= 0; i, j = i+1, j-1 {
			reversed[i] = elements[j]
		}
		return sv.NewArrayRef(reversed...)
	}

	// Если передан первый аргумент как значение
	if len(args) > 0 && args[0] != nil {
		var elements []*sv.SV
		if args[0].IsRef() {
			deref := args[0].Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if args[0].IsArray() {
			elements = args[0].ArrayData()
		}

		if elements != nil {
			reversed := make([]*sv.SV, len(elements))
			for i, j := 0, len(elements)-1; j >= 0; i, j = i+1, j-1 {
				reversed[i] = elements[j]
			}
			return sv.NewArrayRef(reversed...)
		}
	}

	return sv.NewArrayRef()
}

func (i *Interpreter) BuiltinSort_vOld(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	if len(exprs) == 0 {
		return sv.NewArrayRef()
	}

	// Проверяем, если аргумент - переменная массива
	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		if arrSV == nil || (!arrSV.IsArray() && !arrSV.IsRef()) {
			return sv.NewArrayRef()
		}

		// Получаем данные
		var elements []*sv.SV
		if arrSV.IsRef() {
			deref := arrSV.Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if arrSV.IsArray() {
			elements = arrSV.ArrayData()
		}

		if elements == nil {
			return sv.NewArrayRef()
		}

		// Создаём копию для сортировки
		sorted := make([]*sv.SV, len(elements))
		copy(sorted, elements)

		// Сортируем вручную по строковому значению
		for i := 0; i < len(sorted)-1; i++ {
			for j := i + 1; j < len(sorted); j++ {
				if sorted[i].AsString() > sorted[j].AsString() {
					sorted[i], sorted[j] = sorted[j], sorted[i]
				}
			}
		}

		return sv.NewArrayRef(sorted...)
	}

	// Если передан первый аргумент как значение
	if len(args) > 0 && args[0] != nil {
		var elements []*sv.SV
		if args[0].IsRef() {
			deref := args[0].Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if args[0].IsArray() {
			elements = args[0].ArrayData()
		}

		if elements != nil {
			sorted := make([]*sv.SV, len(elements))
			copy(sorted, elements)

			// Сортируем вручную
			for i := 0; i < len(sorted)-1; i++ {
				for j := i + 1; j < len(sorted); j++ {
					if sorted[i].AsString() > sorted[j].AsString() {
						sorted[i], sorted[j] = sorted[j], sorted[i]
					}
				}
			}

			return sv.NewArrayRef(sorted...)
		}
	}

	return sv.NewArrayRef()
}

func (i *Interpreter) builtinSort(exprs []ast.Expression, args []*sv.SV) *sv.SV {
	if len(exprs) == 0 {
		return sv.NewArrayRef()
	}

	// Проверяем, если аргумент - переменная массива
	if arrVar, ok := exprs[0].(*ast.ArrayVar); ok {
		arrSV := i.ctx.GetVar(arrVar.Name)
		if arrSV == nil || (!arrSV.IsArray() && !arrSV.IsRef()) {
			return sv.NewArrayRef()
		}

		// Получаем данные
		var elements []*sv.SV
		if arrSV.IsRef() {
			deref := arrSV.Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if arrSV.IsArray() {
			elements = arrSV.ArrayData()
		}

		if elements == nil {
			return sv.NewArrayRef()
		}

		// Создаём копию для сортировки
		sorted := make([]*sv.SV, len(elements))
		copy(sorted, elements)

		// Сортируем
		sort.Slice(sorted, func(i, j int) bool {
			return sorted[i].AsString() < sorted[j].AsString()
		})

		return sv.NewArrayRef(sorted...)
	}

	// Если передан первый аргумент как значение
	if len(args) > 0 && args[0] != nil {
		var elements []*sv.SV
		if args[0].IsRef() {
			deref := args[0].Deref()
			if deref != nil && deref.IsArray() {
				elements = deref.ArrayData()
			}
		} else if args[0].IsArray() {
			elements = args[0].ArrayData()
		}

		if elements != nil {
			sorted := make([]*sv.SV, len(elements))
			copy(sorted, elements)

			sort.Slice(sorted, func(i, j int) bool {
				return sorted[i].AsString() < sorted[j].AsString()
			})

			return sv.NewArrayRef(sorted...)
		}
	}

	return sv.NewArrayRef()
}

func (i *Interpreter) builtinExists(expr *ast.CallExpr) *sv.SV {
	if len(expr.Args) == 0 {
		return sv.NewString("")
	}

	// exists $hash{key}
	if hashAccess, ok := expr.Args[0].(*ast.HashAccess); ok {
		hash := i.evalExpression(hashAccess.Hash)
		key := i.evalExpression(hashAccess.Key)
		return hv.Exists(hash, key)
	}

	// exists $array[idx]
	if arrAccess, ok := expr.Args[0].(*ast.ArrayAccess); ok {
		arr := i.evalExpression(arrAccess.Array)
		idx := i.evalExpression(arrAccess.Index)
		return av.Exists(arr, idx)
	}

	return sv.NewString("")
}

func (i *Interpreter) builtinDelete(expr *ast.CallExpr) *sv.SV {
	if len(expr.Args) == 0 {
		return sv.NewUndef()
	}

	// delete $hash{key}
	if hashAccess, ok := expr.Args[0].(*ast.HashAccess); ok {
		hash := i.evalExpression(hashAccess.Hash)
		key := i.evalExpression(hashAccess.Key)
		return hv.Delete(hash, key)
	}

	// delete $array[idx]
	if arrAccess, ok := expr.Args[0].(*ast.ArrayAccess); ok {
		arr := i.evalExpression(arrAccess.Array)
		idx := i.evalExpression(arrAccess.Index)
		return av.Delete(arr, idx)
	}

	return sv.NewUndef()
}
```

## File: ./pkg/eval/eval.go
```go
// Package eval implements AST interpretation.
package eval

import (
	"fmt"
	"io"
	"os"
	"regexp"
	"strings"

	"perlc/pkg/ast"
	"perlc/pkg/av"
	"perlc/pkg/context"
	"perlc/pkg/hv"
	"perlc/pkg/sv"
)

// Interpreter executes Perl AST.
type Interpreter struct {
	ctx    *context.Context
	stdout io.Writer
	stderr io.Writer
}

// New creates a new interpreter.
func New() *Interpreter {
	return &Interpreter{
		ctx:    context.New(),
		stdout: os.Stdout,
		stderr: os.Stderr,
	}
}

var interpolateRe = regexp.MustCompile(`\$(\w+)|\$\{(\w+)\}|@(\w+)`)

// SetStdout sets the output writer.
func (i *Interpreter) SetStdout(w io.Writer) {
	i.stdout = w
}

// Eval evaluates a program and returns the last value.
func (i *Interpreter) Eval(program *ast.Program) *sv.SV {
	var result *sv.SV
	for _, stmt := range program.Statements {
		result = i.evalStatement(stmt)
		if i.ctx.HasReturn() {
			return i.ctx.ReturnValue()
		}
	}
	return result
}

// ============================================================
// Statement Evaluation
// ============================================================

func (i *Interpreter) evalStatement(stmt ast.Statement) *sv.SV {
	switch s := stmt.(type) {
	case *ast.ExprStmt:
		return i.evalExpression(s.Expression)
	case *ast.VarDecl:
		return i.evalVarDecl(s)
	case *ast.IfStmt:
		return i.evalIfStmt(s)
	case *ast.WhileStmt:
		return i.evalWhileStmt(s)
	case *ast.ForStmt:
		return i.evalForStmt(s)
	case *ast.ForeachStmt:
		return i.evalForeachStmt(s)
	case *ast.SubDecl:
		return i.evalSubDecl(s)
	case *ast.ReturnStmt:
		return i.evalReturnStmt(s)
	case *ast.BlockStmt:
		return i.evalBlockStmt(s)
	case *ast.LastStmt:
		i.ctx.SetLast(s.Label)
		return sv.NewUndef()
	case *ast.NextStmt:
		i.ctx.SetNext(s.Label)
		return sv.NewUndef()
	case *ast.UseDecl, *ast.PackageDecl, *ast.NoDecl, *ast.RequireDecl:
		return sv.NewUndef()
	default:
		return sv.NewUndef()
	}
}

func (i *Interpreter) evalBlockStmt(block *ast.BlockStmt) *sv.SV {
	var result *sv.SV
	for _, stmt := range block.Statements {
		result = i.evalStatement(stmt)
		if i.ctx.HasReturn() || i.ctx.HasLast() || i.ctx.HasNext() {
			break
		}
	}
	return result
}

func (i *Interpreter) evalVarDecl(decl *ast.VarDecl) *sv.SV {
	var value *sv.SV
	if decl.Value != nil {
		value = i.evalExpression(decl.Value)
	} else {
		// Create appropriate empty value based on variable type
		if len(decl.Names) == 1 {
			switch decl.Names[0].(type) {
			case *ast.HashVar:
				value = sv.NewHashRef().Deref() // Empty hash
			case *ast.ArrayVar:
				value = sv.NewArrayRef().Deref() // Empty array
			default:
				value = sv.NewUndef()
			}
		} else {
			value = sv.NewUndef()
		}
	}

	// List assignment: my ($x, $y) = @arr or my ($x) = @arr
	// Only unpack if declared with parentheses (IsList)
	if decl.IsList && decl.Value != nil {
		values := i.svToList(value)
		for idx, name := range decl.Names {
			var val *sv.SV
			if idx < len(values) {
				val = values[idx]
			} else {
				val = sv.NewUndef()
			}
			i.assignToVar(name, val, decl.Kind)
		}
		return value
	}

	if len(decl.Names) == 1 {
		// Special handling for hash: convert list to hash
		if _, ok := decl.Names[0].(*ast.HashVar); ok {
			// Handle both array and array ref
			var data []*sv.SV
			if value.IsArray() {
				data = value.ArrayData()
			} else if value.IsRef() {
				deref := value.Deref()
				if deref != nil && deref.IsArray() {
					data = deref.ArrayData()
				}
			}
			if data != nil {
				hashSV := sv.NewHashRef().Deref()
				for j := 0; j+1 < len(data); j += 2 {
					key := data[j].AsString()
					val := data[j+1]
					hashSV.HashData()[key] = val
				}
				value = hashSV
			}
		}
		i.assignToVar(decl.Names[0], value, decl.Kind)
	}
	return value
}

func (i *Interpreter) assignToVar(expr ast.Expression, value *sv.SV, kind string) {
	switch v := expr.(type) {
	case *ast.ScalarVar:
		i.ctx.DeclareVar(v.Name, value, kind)
	case *ast.ArrayVar:
		i.ctx.DeclareVar(v.Name, value, kind)
	case *ast.HashVar:
		i.ctx.DeclareVar(v.Name, value, kind)
	}
}

func (i *Interpreter) evalIfStmt(stmt *ast.IfStmt) *sv.SV {
	cond := i.evalExpression(stmt.Condition)
	testResult := cond.IsTrue()
	if stmt.Unless {
		testResult = !testResult
	}

	if testResult {
		return i.evalBlockStmt(stmt.Then)
	}

	for _, elsif := range stmt.Elsif {
		cond := i.evalExpression(elsif.Condition)
		if cond.IsTrue() {
			return i.evalBlockStmt(elsif.Body)
		}
	}

	if stmt.Else != nil {
		return i.evalBlockStmt(stmt.Else)
	}
	return sv.NewUndef()
}

func (i *Interpreter) evalWhileStmt(stmt *ast.WhileStmt) *sv.SV {
	var result *sv.SV
	for {
		cond := i.evalExpression(stmt.Condition)
		testResult := cond.IsTrue()
		if stmt.Until {
			testResult = !testResult
		}
		if !testResult {
			break
		}

		result = i.evalBlockStmt(stmt.Body)

		if i.ctx.HasLast() {
			i.ctx.ClearLast()
			break
		}
		if i.ctx.HasNext() {
			i.ctx.ClearNext()
			continue
		}
		if i.ctx.HasReturn() {
			break
		}
	}
	return result
}

func (i *Interpreter) evalForStmt(stmt *ast.ForStmt) *sv.SV {
	var result *sv.SV

	// Init - может быть VarDecl или ExprStmt
	if stmt.Init != nil {
		i.evalStatement(stmt.Init)
	}

	for {
		// Condition
		if stmt.Condition != nil {
			cond := i.evalExpression(stmt.Condition)
			if !cond.IsTrue() {
				break
			}
		}

		result = i.evalBlockStmt(stmt.Body)

		if i.ctx.HasLast() {
			i.ctx.ClearLast()
			break
		}
		if i.ctx.HasNext() {
			i.ctx.ClearNext()
			// Still need to execute Post before next iteration
		}
		if i.ctx.HasReturn() {
			break
		}

		// Post - execute after body, before next condition check
		if stmt.Post != nil {
			i.evalExpression(stmt.Post)
		}
	}
	return result
}

func (i *Interpreter) evalForeachStmt(stmt *ast.ForeachStmt) *sv.SV {
	var result *sv.SV
	list := i.evalExpression(stmt.List)
	values := i.svToList(list)

	varName := ""
	if v, ok := stmt.Variable.(*ast.ScalarVar); ok {
		varName = v.Name
	}

	for _, val := range values {
		i.ctx.SetVar(varName, val)
		result = i.evalBlockStmt(stmt.Body)

		if i.ctx.HasLast() {
			i.ctx.ClearLast()
			break
		}
		if i.ctx.HasNext() {
			i.ctx.ClearNext()
			continue
		}
		if i.ctx.HasReturn() {
			break
		}
	}
	return result
}

func (i *Interpreter) evalSubDecl(decl *ast.SubDecl) *sv.SV {
	i.ctx.DeclareSub(decl.Name, decl.Body)
	return sv.NewUndef()
}

func (i *Interpreter) evalReturnStmt(stmt *ast.ReturnStmt) *sv.SV {
	var value *sv.SV
	if stmt.Value != nil {
		value = i.evalExpression(stmt.Value)
	} else {
		value = sv.NewUndef()
	}
	i.ctx.SetReturn(value)
	return value
}

// ============================================================
// Expression Evaluation
// ============================================================

func (i *Interpreter) evalExpression(expr ast.Expression) *sv.SV {
	// fmt.Printf("DEBUG @_: %v\n", expr)
	// fmt.Printf("DEBUG @_: %T\n", expr)

	if expr == nil {
		return sv.NewUndef()
	}

	switch e := expr.(type) {
	case *ast.IntegerLiteral:
		return sv.NewInt(e.Value)
	case *ast.FloatLiteral:
		return sv.NewFloat(e.Value)
	case *ast.StringLiteral:
		if e.Interpolated {
			return sv.NewString(i.interpolateString(e.Value))
		}
		return sv.NewString(e.Value)
	case *ast.UndefLiteral:
		return sv.NewUndef()
	case *ast.ScalarVar:
		return i.ctx.GetVar(e.Name)
	case *ast.ArrayVar:
		if e.Name == "_" {
			result := i.ctx.GetArgs()
			return result
		}
		return i.ctx.GetVar(e.Name)
	case *ast.HashVar:
		return i.ctx.GetVar(e.Name)
	case *ast.SpecialVar:
		return i.evalSpecialVar(e.Name)
	case *ast.PrefixExpr:
		return i.evalPrefixExpr(e)
	case *ast.InfixExpr:
		return i.evalInfixExpr(e)
	case *ast.PostfixExpr:
		return i.evalPostfixExpr(e)
	case *ast.AssignExpr:
		return i.evalAssignExpr(e)
	case *ast.TernaryExpr:
		return i.evalTernaryExpr(e)
	case *ast.ArrayExpr:
		return i.evalArrayExpr(e)
	case *ast.HashExpr:
		return i.evalHashExpr(e)
	case *ast.ArrayAccess:
		return i.evalArrayAccess(e)
	case *ast.HashAccess:
		return i.evalHashAccess(e)
	case *ast.CallExpr:
		return i.evalCallExpr(e)
	case *ast.MethodCall:
		return i.evalMethodCall(e)
	case *ast.RefExpr:
		return i.evalRefExpr(e)
	case *ast.Identifier:
		return sv.NewString(e.Value)
	case *ast.RangeExpr:
		return i.evalRangeExpr(e)
	case *ast.ArrowAccess:
		return i.evalArrowAccess(e)
	case *ast.MatchExpr:
		return i.evalMatchExpr(e)
	case *ast.SubstExpr:
		return i.evalSubstExpr(e)
	case *ast.ReadLineExpr:
		return i.evalReadLineExpr(e)
	case *ast.DerefExpr:
		return i.evalDerefExpr(e)
	default:
		return sv.NewUndef()
	}
}

func (i *Interpreter) evalPrefixExpr(expr *ast.PrefixExpr) *sv.SV {
	right := i.evalExpression(expr.Right)

	switch expr.Operator {
	case "-":
		return sv.NewFloat(-right.AsFloat())
	case "+":
		return sv.NewFloat(right.AsFloat())
	case "!":
		return boolToSV(!right.IsTrue())
	case "not":
		return boolToSV(!right.IsTrue())
	case "~":
		return sv.NewInt(^right.AsInt())
	case "++":
		val := sv.NewInt(right.AsInt() + 1)
		i.assignBack(expr.Right, val)
		return val
	case "--":
		val := sv.NewInt(right.AsInt() - 1)
		i.assignBack(expr.Right, val)
		return val
	default:
		return sv.NewUndef()
	}
}

func (i *Interpreter) evalInfixExpr(expr *ast.InfixExpr) *sv.SV {
	// Short-circuit
	if expr.Operator == "&&" || expr.Operator == "and" {
		left := i.evalExpression(expr.Left)
		if !left.IsTrue() {
			return left
		}
		return i.evalExpression(expr.Right)
	}
	if expr.Operator == "||" || expr.Operator == "or" {
		left := i.evalExpression(expr.Left)
		if left.IsTrue() {
			return left
		}
		return i.evalExpression(expr.Right)
	}
	if expr.Operator == "//" {
		left := i.evalExpression(expr.Left)
		if !left.IsUndef() {
			return left
		}
		return i.evalExpression(expr.Right)
	}

	left := i.evalExpression(expr.Left)
	right := i.evalExpression(expr.Right)

	switch expr.Operator {
	case "+":
		return sv.Add(left, right)
	case "-":
		return sv.Sub(left, right)
	case "*":
		return sv.Mul(left, right)
	case "/":
		return sv.Div(left, right)
	case "%":
		return sv.Mod(left, right)
	case "**":
		return sv.Pow(left, right)
	case ".":
		return sv.Concat(left, right)
	case "x":
		return sv.Repeat(left, right)
	case "==":
		return sv.NumEq(left, right)
	case "!=":
		return sv.NumNe(left, right)
	case "<":
		return sv.NumLt(left, right)
	case "<=":
		return sv.NumLe(left, right)
	case ">":
		return sv.NumGt(left, right)
	case ">=":
		return sv.NumGe(left, right)
	case "<=>":
		return sv.NumCmp(left, right)
	case "eq":
		return sv.StrEq(left, right)
	case "ne":
		return sv.StrNe(left, right)
	case "lt":
		return sv.StrLt(left, right)
	case "le":
		return sv.StrLe(left, right)
	case "gt":
		return sv.StrGt(left, right)
	case "ge":
		return sv.StrGe(left, right)
	case "cmp":
		return sv.StrCmp(left, right)
	case "&":
		return sv.BitAnd(left, right)
	case "|":
		return sv.BitOr(left, right)
	case "^":
		return sv.BitXor(left, right)
	case "<<":
		return sv.LeftShift(left, right)
	case ">>":
		return sv.RightShift(left, right)
	default:
		return sv.NewUndef()
	}
}

func (i *Interpreter) evalPostfixExpr(expr *ast.PostfixExpr) *sv.SV {
	left := i.evalExpression(expr.Left)
	oldVal := sv.NewInt(left.AsInt())

	switch expr.Operator {
	case "++":
		i.assignBack(expr.Left, sv.NewInt(left.AsInt()+1))
		return oldVal
	case "--":
		i.assignBack(expr.Left, sv.NewInt(left.AsInt()-1))
		return oldVal
	default:
		return oldVal
	}
}

func (i *Interpreter) evalAssignExpr(expr *ast.AssignExpr) *sv.SV {
	right := i.evalExpression(expr.Right)

	if expr.Operator != "=" {
		left := i.evalExpression(expr.Left)
		switch expr.Operator {
		case "+=":
			right = sv.Add(left, right)
		case "-=":
			right = sv.Sub(left, right)
		case "*=":
			right = sv.Mul(left, right)
		case "/=":
			right = sv.Div(left, right)
		case ".=":
			right = sv.Concat(left, right)
		case "||=":
			if left.IsTrue() {
				return left
			}
		case "//=":
			if !left.IsUndef() {
				return left
			}
		}
	}

	i.assignBack(expr.Left, right)
	return right
}

func (i *Interpreter) evalTernaryExpr(expr *ast.TernaryExpr) *sv.SV {
	cond := i.evalExpression(expr.Condition)
	if cond.IsTrue() {
		return i.evalExpression(expr.Then)
	}
	return i.evalExpression(expr.Else)
}

func (i *Interpreter) evalArrayExpr(expr *ast.ArrayExpr) *sv.SV {
	elements := make([]*sv.SV, len(expr.Elements))
	for idx, el := range expr.Elements {
		elements[idx] = i.evalExpression(el)
	}
	return sv.NewArrayRef(elements...)
}

func (i *Interpreter) evalHashExpr(expr *ast.HashExpr) *sv.SV {
	href := sv.NewHashRef()
	for _, pair := range expr.Pairs {
		key := i.evalExpression(pair.Key)
		value := i.evalExpression(pair.Value)
		hv.Store(href, key, value)
	}
	return href
}

func (i *Interpreter) evalArrayAccess(expr *ast.ArrayAccess) *sv.SV {
	// Special case: $_[n] means @_[n] (argument access)
	if sv, ok := expr.Array.(*ast.SpecialVar); ok && sv.Name == "$_" {
		array := i.ctx.GetArgs()
		index := i.evalExpression(expr.Index)
		result := av.Fetch(array, index)
		return result
	}

	array := i.evalExpression(expr.Array)
	index := i.evalExpression(expr.Index)
	return av.Fetch(array, index)
}

func (i *Interpreter) evalHashAccess(expr *ast.HashAccess) *sv.SV {
	hash := i.evalExpression(expr.Hash)
	key := i.evalExpression(expr.Key)
	return hv.Fetch(hash, key)
}

func (i *Interpreter) evalCallExpr(expr *ast.CallExpr) *sv.SV {
	funcName := ""
	if ident, ok := expr.Function.(*ast.Identifier); ok {
		funcName = ident.Value
	}

	args := make([]*sv.SV, len(expr.Args))
	for idx, arg := range expr.Args {
		args[idx] = i.evalExpression(arg)
	}

	// Built-in functions
	switch funcName {
	case "print":
		return i.builtinPrint(expr)
	case "say":
		return i.builtinSay(expr)
	case "open":
		return i.builtinOpen(expr)
	case "close":
		return i.builtinClose(expr)
	case "length":
		return sv.Length(args[0])
	case "defined":
		return sv.Defined(args[0])
	case "ref":
		return sv.Ref(args[0])
	case "push":
		return i.builtinPush(expr.Args, args)
	case "pop":
		return i.builtinPop(expr.Args)
	case "shift":
		return i.builtinShift(expr.Args)
	case "unshift":
		return i.builtinUnshift(expr.Args, args)
	case "keys":
		return i.builtinKeys(args)
	case "values":
		return i.builtinValues(args)
	case "join":
		return i.builtinJoin(args)
	case "split":
		return i.builtinSplit(args)
	case "substr":
		return i.builtinSubstr(args)
	case "int":
		if len(args) > 0 {
			return sv.NewInt(args[0].AsInt())
		}
		return sv.NewInt(0)
	case "abs":
		return i.builtinAbs(args)
	case "sqrt":
		return i.builtinSqrt(args)
	case "chr":
		return i.builtinChr(args)
	case "ord":
		return i.builtinOrd(args)
	case "lc":
		return sv.Lc(args[0])
	case "uc":
		return sv.Uc(args[0])
	case "chomp":
		return i.builtinChomp(expr.Args)
	case "die":
		return i.builtinDie(args)
	case "warn":
		return i.builtinWarn(args)
	case "exit":
		return i.builtinExit(args)
	case "scalar":
		return i.builtinScalar(args)
	case "bless":
		return i.builtinBless(expr.Args, args)
	case "isa":
		return i.builtinIsa(args)
	case "can":
		return i.builtinCan(args)
	case "set_isa":
		// Helper function: set_isa('Child', 'Parent1', 'Parent2', ...)
		return i.builtinSetIsa(args)
	case "reverse":
		return i.builtinReverse(expr.Args, args)
	case "sort":
		return i.builtinSort(expr.Args, args)
	case "exists":
		return i.builtinExists(expr)
	case "delete":
		return i.builtinDelete(expr)
	}

	return i.callUserSub(funcName, args)
}

func (i *Interpreter) evalMethodCall(expr *ast.MethodCall) *sv.SV {
	// Evaluate the object/class
	obj := i.evalExpression(expr.Object)

	// Prepare arguments - first arg is always the invocant ($self or $class)
	args := make([]*sv.SV, len(expr.Args)+1)
	args[0] = obj
	for idx, arg := range expr.Args {
		args[idx+1] = i.evalExpression(arg)
	}

	// Determine the package/class name
	var pkgName string

	// If object is a blessed reference, get its package
	if obj.IsRef() && obj.IsBlessed() {
		pkgName = obj.Package()
	} else if obj.IsRef() {
		// Unblessed reference - error in strict mode
		// For now, just return undef
		return sv.NewUndef()
	} else {
		// Object might be a class name (string)
		// e.g., ClassName->new()
		pkgName = obj.AsString()
	}

	// Find the method in the package
	methodName := expr.Method

	// Special handling for SUPER::
	superCall := false
	if strings.HasPrefix(methodName, "SUPER::") {
		methodName = strings.TrimPrefix(methodName, "SUPER::")
		superCall = true
	}

	var fullName string
	if superCall {
		// For SUPER:: calls, start search from parent classes
		parents := i.ctx.GetPackageISA(pkgName)
		for _, parent := range parents {
			if found := i.ctx.FindMethod(parent, methodName); found != "" {
				fullName = found
				break
			}
		}
	} else {
		// Normal method resolution - search class and @ISA
		fullName = i.ctx.FindMethod(pkgName, methodName)
	}

	if fullName != "" {
		return i.callSubWithArgs(fullName, args)
	}

	// Try just the method name (for main:: methods)
	if body := i.ctx.GetSub(methodName); body != nil {
		return i.callSubWithArgs(methodName, args)
	}

	// TODO: AUTOLOAD support

	// Method not found
	return sv.NewUndef()
}

func (i *Interpreter) callSubWithArgs(name string, args []*sv.SV) *sv.SV {
	body := i.ctx.GetSub(name)
	if body == nil {
		return sv.NewUndef()
	}

	// Save current args and set new args
	oldArgs := i.ctx.GetArgs()
	i.ctx.SetArgs(args)

	// Create new scope
	i.ctx.PushScope()
	defer i.ctx.PopScope()
	defer i.ctx.ClearReturn()
	defer func() { i.ctx.SetArgs(oldArgs.ArrayData()) }()

	// Execute body
	var result *sv.SV
	for _, stmt := range body.Statements {
		result = i.evalStatement(stmt)
		if i.ctx.HasReturn() {
			result = i.ctx.ReturnValue()
			break
		}
	}

	if result == nil {
		return sv.NewUndef()
	}
	return result
}

func (i *Interpreter) evalDerefExpr(expr *ast.DerefExpr) *sv.SV {
	ref := i.evalExpression(expr.Value)
	if ref == nil {
		return sv.NewUndef()
	}
	return ref.Deref()
}

func (i *Interpreter) evalRefExpr(expr *ast.RefExpr) *sv.SV {
	// Для \@arr - создаём ссылку на массив
	if arrVar, ok := expr.Value.(*ast.ArrayVar); ok {
		arr := i.ctx.GetVar(arrVar.Name)
		if arr == nil || arr.IsUndef() {
			// Создаём пустой массив если не существует
			arr = sv.NewArrayRef().Deref()
			i.ctx.SetVar(arrVar.Name, arr)
		}
		return sv.NewRef(arr)
	}

	// Для \%hash - создаём ссылку на хеш
	if hashVar, ok := expr.Value.(*ast.HashVar); ok {
		hash := i.ctx.GetVar(hashVar.Name)
		if hash == nil || hash.IsUndef() {
			// Создаём пустой хеш если не существует
			hash = sv.NewHashRef().Deref()
			i.ctx.SetVar(hashVar.Name, hash)
		}
		return sv.NewRef(hash)
	}

	// Для \$scalar - создаём ссылку на скаляр
	if scalarVar, ok := expr.Value.(*ast.ScalarVar); ok {
		scalar := i.ctx.GetVar(scalarVar.Name)
		if scalar == nil {
			scalar = sv.NewUndef()
			i.ctx.SetVar(scalarVar.Name, scalar)
		}
		return sv.NewRef(scalar)
	}

	// Для других выражений - обычное поведение
	val := i.evalExpression(expr.Value)
	return sv.NewRef(val)
}

func (i *Interpreter) evalRangeExpr(expr *ast.RangeExpr) *sv.SV {
	start := i.evalExpression(expr.Start)
	end := i.evalExpression(expr.End)
	elements := sv.Range(start, end)
	return sv.NewArrayRef(elements...)
}

func (i *Interpreter) evalSpecialVar(name string) *sv.SV {
	if name == "@_" {
		return i.ctx.GetArgs()
	}
	return i.ctx.GetSpecialVar(name)
}

// ============================================================
// Helper Functions
// ============================================================

func (i *Interpreter) assignBack(expr ast.Expression, value *sv.SV) {
	switch v := expr.(type) {
	case *ast.ScalarVar:
		i.ctx.SetVar(v.Name, value)
	case *ast.ArrayAccess:
		arr := i.evalExpression(v.Array)
		idx := i.evalExpression(v.Index)
		av.Store(arr, idx, value)
	case *ast.HashAccess:
		hash := i.evalExpression(v.Hash)
		key := i.evalExpression(v.Key)
		hv.Store(hash, key, value)
	case *ast.ArrowAccess:
		// $ref->[index] = ... or $ref->{key} = ...
		left := i.evalExpression(v.Left)
		target := left
		if left.IsRef() {
			target = left.Deref()
		}
		switch right := v.Right.(type) {
		case *ast.ArrayAccess:
			idx := i.evalExpression(right.Index)
			av.Store(target, idx, value)
		case *ast.HashAccess:
			key := i.evalExpression(right.Key)
			hv.Store(target, key, value)
		}
	case *ast.DerefExpr:
		// $$ref = value - assign to dereferenced scalar
		ref := i.evalExpression(v.Value)
		if ref != nil && ref.IsRef() {
			target := ref.Deref()
			if target != nil {
				target.CopyFrom(value)
			}
		}
	}
}

func (i *Interpreter) svToList(val *sv.SV) []*sv.SV {
	if val.IsRef() {
		target := val.Deref()
		if target != nil && target.IsArray() {
			return target.ArrayData()
		}
	}
	if val.IsArray() {
		return val.ArrayData()
	}
	return []*sv.SV{val}
}

func (i *Interpreter) interpolateString(s string) string {
	return interpolateRe.ReplaceAllStringFunc(s, func(match string) string {
		var name string
		if match[0] == '@' {
			name = match[1:]
			val := i.ctx.GetVar(name)
			if val != nil && val.IsArray() {
				elements := val.ArrayData()
				parts := make([]string, len(elements))
				for idx, el := range elements {
					parts[idx] = el.AsString()
				}
				return strings.Join(parts, " ")
			}
			return ""
		}
		if strings.HasPrefix(match, "${") {
			name = match[2 : len(match)-1]
		} else {
			name = match[1:]
		}
		val := i.ctx.GetVar(name)
		if val != nil {
			return val.AsString()
		}
		return ""
	})
}

func (i *Interpreter) callUserSub(name string, args []*sv.SV) *sv.SV {
	body := i.ctx.GetSub(name)
	if body == nil {
		return sv.NewUndef()
	}

	i.ctx.PushScope()
	defer i.ctx.PopScope()

	i.ctx.SetArgs(args)

	result := i.evalBlockStmt(body)

	if i.ctx.HasReturn() {
		result = i.ctx.ReturnValue()
		i.ctx.ClearReturn()
	}
	return result
}

func (i *Interpreter) evalArrowAccess(expr *ast.ArrowAccess) *sv.SV {
	left := i.evalExpression(expr.Left)

	// Dereference if needed
	target := left
	if left.IsRef() {
		target = left.Deref()
	}

	// Check what's on the right
	switch right := expr.Right.(type) {
	case *ast.ArrayAccess:
		index := i.evalExpression(right.Index)
		return av.Fetch(target, index)
	case *ast.HashAccess:
		key := i.evalExpression(right.Key)
		return hv.Fetch(target, key)
	default:
		return sv.NewUndef()
	}
}

func (i *Interpreter) evalMatchExpr(expr *ast.MatchExpr) *sv.SV {
	target := i.evalExpression(expr.Target)
	str := target.AsString()

	pattern := expr.Pattern.Pattern
	flags := expr.Pattern.Flags

	// Build regex pattern with flags
	rePattern := pattern
	if strings.Contains(flags, "i") {
		rePattern = "(?i)" + rePattern
	}

	re, err := regexp.Compile(rePattern)
	if err != nil {
		return sv.NewInt(0)
	}

	loc := re.FindStringSubmatchIndex(str)
	matched := loc != nil

	// Set match variables
	if matched {
		matches := re.FindStringSubmatch(str)
		preMath := str[:loc[0]]
		postMatch := str[loc[1]:]
		fullMatch := matches[0]

		// Extract capture groups (skip index 0 which is the full match)
		captures := []string{}
		if len(matches) > 1 {
			captures = matches[1:]
		}

		i.ctx.SetMatchVars(fullMatch, preMath, postMatch, captures)
	}

	if expr.Negate {
		if matched {
			return sv.NewInt(0)
		}
		return sv.NewInt(1)
	}

	if matched {
		return sv.NewInt(1)
	}
	return sv.NewInt(0)
}

func (i *Interpreter) evalSubstExpr(expr *ast.SubstExpr) *sv.SV {
	target := i.evalExpression(expr.Target)
	str := target.AsString()

	pattern := expr.Pattern
	replacement := expr.Replacement
	flags := expr.Flags

	// Build regex with flags
	rePattern := pattern
	if strings.Contains(flags, "i") {
		rePattern = "(?i)" + rePattern
	}

	re, err := regexp.Compile(rePattern)
	if err != nil {
		return sv.NewInt(0)
	}

	var result string
	changed := false

	if strings.Contains(flags, "g") {
		// Global replacement with capture group support
		result = re.ReplaceAllStringFunc(str, func(match string) string {
			// Get submatch for this specific match
			submatches := re.FindStringSubmatch(match)
			return i.interpolateReplacement(replacement, submatches)
		})
		changed = result != str
	} else {
		// Single replacement
		loc := re.FindStringSubmatchIndex(str)
		if loc != nil {
			matches := re.FindStringSubmatch(str)
			// Set match vars for potential use
			if len(matches) > 1 {
				i.ctx.SetMatchVars(matches[0], str[:loc[0]], str[loc[1]:], matches[1:])
			}
			interpolated := i.interpolateReplacement(replacement, matches)
			result = str[:loc[0]] + interpolated + str[loc[1]:]
			changed = true
		} else {
			result = str
		}
	}

	// Update the variable if it's a scalar
	if v, ok := expr.Target.(*ast.ScalarVar); ok {
		i.ctx.SetVar(v.Name, sv.NewString(result))
	}

	if changed {
		return sv.NewInt(1)
	}
	return sv.NewInt(0)
}

// interpolateReplacement replaces $1, $2, etc. in replacement string with captured groups
func (i *Interpreter) interpolateReplacement(replacement string, matches []string) string {
	result := replacement
	// Replace $1, $2, ... $9 with captured groups
	for n := 9; n >= 1; n-- {
		placeholder := fmt.Sprintf("$%d", n)
		if strings.Contains(result, placeholder) {
			value := ""
			if n < len(matches) {
				value = matches[n]
			}
			result = strings.ReplaceAll(result, placeholder, value)
		}
	}
	return result
}

func (i *Interpreter) evalReadLineExpr(expr *ast.ReadLineExpr) *sv.SV {
	var name string
	if expr.Filehandle != nil {
		switch fh := expr.Filehandle.(type) {
		case *ast.Identifier:
			name = fh.Value
		case *ast.ScalarVar:
			// Get the value which contains the filehandle name
			val := i.ctx.GetVar(fh.Name)
			if val != nil {
				name = val.AsString()
			}
			if name == "" {
				name = fh.Name
			}
		}
	}

	line, ok := i.ctx.ReadLine(name)
	if !ok {
		return sv.NewUndef()
	}
	return sv.NewString(line)
}

func boolToSV(b bool) *sv.SV {
	if b {
		return sv.NewInt(1)
	}
	return sv.NewString("")
}
```

## File: ./pkg/eval/eval_test.go
```go
package eval

import (
	"bytes"
	"testing"

	"perlc/pkg/lexer"
	"perlc/pkg/parser"
)

func evalInput(input string) (string, *Interpreter) {
	l := lexer.New(input)
	p := parser.New(l)
	program := p.ParseProgram()

	interp := New()
	var buf bytes.Buffer
	interp.SetStdout(&buf)

	interp.Eval(program)
	return buf.String(), interp
}

// ============================================================
// Basic Tests
// ============================================================

func TestPrint(t *testing.T) {
	output, _ := evalInput(`print "Hello, World!";`)
	if output != "Hello, World!" {
		t.Errorf("expected 'Hello, World!', got %q", output)
	}
}

func TestSay(t *testing.T) {
	output, _ := evalInput(`say "Hello";`)
	if output != "Hello\n" {
		t.Errorf("expected 'Hello\\n', got %q", output)
	}
}

func TestArithmetic(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`say 2 + 3;`, "5\n"},
		{`say 10 - 4;`, "6\n"},
		{`say 3 * 4;`, "12\n"},
		{`say 15 / 3;`, "5\n"},
		{`say 17 % 5;`, "2\n"},
		{`say 2 ** 10;`, "1024\n"},
	}

	for _, tt := range tests {
		output, _ := evalInput(tt.input)
		if output != tt.expected {
			t.Errorf("for %q: expected %q, got %q", tt.input, tt.expected, output)
		}
	}
}

func TestStringOps(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`say "Hello" . " " . "World";`, "Hello World\n"},
		{`say "ab" x 3;`, "ababab\n"},
		{`say length("hello");`, "5\n"},
		{`say uc("hello");`, "HELLO\n"},
		{`say lc("HELLO");`, "hello\n"},
	}

	for _, tt := range tests {
		output, _ := evalInput(tt.input)
		if output != tt.expected {
			t.Errorf("for %q: expected %q, got %q", tt.input, tt.expected, output)
		}
	}
}

// ============================================================
// Variable Tests
// ============================================================

func TestScalarVar(t *testing.T) {
	output, _ := evalInput(`
		my $x = 42;
		say $x;
	`)
	if output != "42\n" {
		t.Errorf("expected '42\\n', got %q", output)
	}
}

func TestVarAssignment(t *testing.T) {
	output, _ := evalInput(`
		my $x = 10;
		$x = $x + 5;
		say $x;
	`)
	if output != "15\n" {
		t.Errorf("expected '15\\n', got %q", output)
	}
}

func TestCompoundAssignment(t *testing.T) {
	output, _ := evalInput(`
		my $x = 10;
		$x += 5;
		say $x;
	`)
	if output != "15\n" {
		t.Errorf("expected '15\\n', got %q", output)
	}
}

func TestStringConcat(t *testing.T) {
	output, _ := evalInput(`
		my $s = "Hello";
		$s .= " World";
		say $s;
	`)
	if output != "Hello World\n" {
		t.Errorf("expected 'Hello World\\n', got %q", output)
	}
}

// ============================================================
// Control Flow Tests
// ============================================================

func TestIfTrue(t *testing.T) {
	output, _ := evalInput(`
		my $x = 1;
		if ($x) {
			say "yes";
		}
	`)
	if output != "yes\n" {
		t.Errorf("expected 'yes\\n', got %q", output)
	}
}

func TestIfFalse(t *testing.T) {
	output, _ := evalInput(`
		my $x = 0;
		if ($x) {
			say "yes";
		} else {
			say "no";
		}
	`)
	if output != "no\n" {
		t.Errorf("expected 'no\\n', got %q", output)
	}
}

func TestIfElsif(t *testing.T) {
	output, _ := evalInput(`
		my $x = 2;
		if ($x == 1) {
			say "one";
		} elsif ($x == 2) {
			say "two";
		} else {
			say "other";
		}
	`)
	if output != "two\n" {
		t.Errorf("expected 'two\\n', got %q", output)
	}
}

func TestUnless(t *testing.T) {
	output, _ := evalInput(`
		my $x = 0;
		unless ($x) {
			say "false";
		}
	`)
	if output != "false\n" {
		t.Errorf("expected 'false\\n', got %q", output)
	}
}

func TestWhile(t *testing.T) {
	output, _ := evalInput(`
		my $i = 0;
		while ($i < 3) {
			say $i;
			$i++;
		}
	`)
	if output != "0\n1\n2\n" {
		t.Errorf("expected '0\\n1\\n2\\n', got %q", output)
	}
}

func TestFor(t *testing.T) {
	output, _ := evalInput(`
		for (my $i = 0; $i < 3; $i++) {
			say $i;
		}
	`)
	if output != "0\n1\n2\n" {
		t.Errorf("expected '0\\n1\\n2\\n', got %q", output)
	}
}

func TestForeach(t *testing.T) {
	output, _ := evalInput(`
		my @arr = (1, 2, 3);
		foreach my $x (@arr) {
			say $x;
		}
	`)
	if output != "1\n2\n3\n" {
		t.Errorf("expected '1\\n2\\n3\\n', got %q", output)
	}
}

func TestLast(t *testing.T) {
	output, _ := evalInput(`
		my $i = 0;
		while (1) {
			say $i;
			$i++;
			if ($i >= 3) {
				last;
			}
		}
	`)
	if output != "0\n1\n2\n" {
		t.Errorf("expected '0\\n1\\n2\\n', got %q", output)
	}
}

func TestNext(t *testing.T) {
	output, _ := evalInput(`
		for (my $i = 0; $i < 5; $i++) {
			if ($i == 2) {
				next;
			}
			say $i;
		}
	`)
	if output != "0\n1\n3\n4\n" {
		t.Errorf("expected '0\\n1\\n3\\n4\\n', got %q", output)
	}
}

// ============================================================
// Subroutine Tests
// ============================================================

func TestSubroutine(t *testing.T) {
	output, _ := evalInput(`
		sub greet {
			say "Hello";
		}
		greet();
	`)
	if output != "Hello\n" {
		t.Errorf("expected 'Hello\\n', got %q", output)
	}
}

func TestSubroutineArgs(t *testing.T) {
	output, _ := evalInput(`
		sub add {
			my $a = shift;
			my $b = shift;
			return $a + $b;
		}
		say add(3, 4);
	`)
	if output != "7\n" {
		t.Errorf("expected '7\\n', got %q", output)
	}
}

func TestSubroutineReturn(t *testing.T) {
	output, _ := evalInput(`
		sub double {
			my $x = shift;
			return $x * 2;
		}
		say double(21);
	`)
	if output != "42\n" {
		t.Errorf("expected '42\\n', got %q", output)
	}
}

// ============================================================
// Array Tests
// ============================================================

func TestArrayLiteral(t *testing.T) {
	output, _ := evalInput(`
		my @arr = (1, 2, 3);
		say $arr[0];
		say $arr[1];
		say $arr[2];
	`)
	if output != "1\n2\n3\n" {
		t.Errorf("expected '1\\n2\\n3\\n', got %q", output)
	}
}

func TestArrayPush(t *testing.T) {
	output, _ := evalInput(`
		my @arr = (1, 2);
		push @arr, 3;
		say $arr[2];
	`)
	if output != "3\n" {
		t.Errorf("expected '3\\n', got %q", output)
	}
}

func TestArrayPop(t *testing.T) {
	output, _ := evalInput(`
		my @arr = (1, 2, 3);
		my $x = pop @arr;
		say $x;
	`)
	if output != "3\n" {
		t.Errorf("expected '3\\n', got %q", output)
	}
}

// ============================================================
// Hash Tests
// ============================================================

func TestHashLiteral(t *testing.T) {
	output, _ := evalInput(`
		my $h = {a => 1, b => 2};
		say $h->{a};
		say $h->{b};
	`)
	if output != "1\n2\n" {
		t.Errorf("expected '1\\n2\\n', got %q", output)
	}
}

// ============================================================
// Ternary Operator Test
// ============================================================

func TestTernary(t *testing.T) {
	output, _ := evalInput(`
		my $x = 1;
		say $x ? "yes" : "no";
	`)
	if output != "yes\n" {
		t.Errorf("expected 'yes\\n', got %q", output)
	}
}

// ============================================================
// Logical Operators Test
// ============================================================

func TestLogicalOr(t *testing.T) {
	output, _ := evalInput(`
		my $x = 0 || 42;
		say $x;
	`)
	if output != "42\n" {
		t.Errorf("expected '42\\n', got %q", output)
	}
}

func TestDefinedOr(t *testing.T) {
	output, _ := evalInput(`
		my $x;
		my $y = $x // "default";
		say $y;
	`)
	if output != "default\n" {
		t.Errorf("expected 'default\\n', got %q", output)
	}
}

func TestForDebug(t *testing.T) {
	input := `for (my $i = 0; $i < 3; $i++) { say $i; }`
	l := lexer.New(input)
	p := parser.New(l)
	program := p.ParseProgram()

	if len(p.Errors()) > 0 {
		for _, e := range p.Errors() {
			t.Logf("parse error: %s", e)
		}
	}

	t.Logf("statements: %d", len(program.Statements))
	for i, stmt := range program.Statements {
		t.Logf("stmt[%d]: %T = %s", i, stmt, stmt.String())
	}
}
```

## File: ./pkg/gv/gv.go
```go
// Package gv implements Perl's glob values (*foo).
// Paket gv, Perl'in glob değerlerini (*foo) uygular.
//
// A glob is a symbol table entry that can hold multiple types:
// $foo, @foo, %foo, &foo, and filehandles - all under one name.
//
// Glob, birden fazla türü tutabilen bir sembol tablosu girdisidir:
// $foo, @foo, %foo, &foo ve dosya tanıtıcıları - hepsi tek isim altında.
package gv

import (
	"fmt"

	"perlc/pkg/sv"
)

// GV represents a glob value - a container for all variable types
// sharing the same name in a package.
//
// GV, bir glob değerini temsil eder - bir pakette aynı adı paylaşan
// tüm değişken türleri için bir kapsayıcı.
type GV struct {
	name   string // Variable name (without sigil) / Değişken adı (sigil olmadan)
	pkg    string // Package name / Paket adı
	scalar *sv.SV // $name
	array  *sv.SV // @name (TypeArray)
	hash   *sv.SV // %name (TypeHash)
	code   *sv.SV // &name (TypeCode)
	io     *sv.SV // Filehandle / Dosya tanıtıcı
	//format *sv.SV // Format (for write) / Format (write için)
	//flags  uint32
}

// GV flags
// GV bayrakları
const (
	GVImported uint32 = 1 << iota // Imported from another package / Başka paketten içe aktarıldı
	GVIntro                       // First declaration / İlk bildirim
	GVMulti                       // Used in multiple ways / Birden fazla şekilde kullanıldı
	GVAssumecv                    // Assume it's a subroutine / Altyordam olduğunu varsay
	GVConst                       // Constant subroutine / Sabit altyordam
)

// New creates a new glob value.
// New, yeni bir glob değeri oluşturur.
func New(pkg, name string) *GV {
	return &GV{
		name: name,
		pkg:  pkg,
	}
}

// ============================================================
// Getters - Get slot values
// Getter'lar - Slot değerlerini al
// ============================================================

// Name returns the variable name.
// Name, değişken adını döndürür.
func (gv *GV) Name() string {
	return gv.name
}

// Package returns the package name.
// Package, paket adını döndürür.
func (gv *GV) Package() string {
	return gv.pkg
}

// FullName returns "Package::name".
// FullName, "Package::name" döndürür.
func (gv *GV) FullName() string {
	if gv.pkg == "" || gv.pkg == "main" {
		return gv.name
	}
	return gv.pkg + "::" + gv.name
}

// Scalar returns $name (creates if not exists).
// Scalar, $name döndürür (yoksa oluşturur).
func (gv *GV) Scalar() *sv.SV {
	if gv.scalar == nil {
		gv.scalar = sv.NewUndef()
	}
	return gv.scalar
}

// Array returns @name (creates if not exists).
// Array, @name döndürür (yoksa oluşturur).
func (gv *GV) Array() *sv.SV {
	if gv.array == nil {
		// Create the actual array (not a reference)
		// Gerçek diziyi oluştur (referans değil)
		gv.array = sv.NewArrayRef().Deref()
	}
	return gv.array
}

// Hash returns %name (creates if not exists).
// Hash, %name döndürür (yoksa oluşturur).
func (gv *GV) Hash() *sv.SV {
	if gv.hash == nil {
		gv.hash = sv.NewHashRef().Deref()
	}
	return gv.hash
}

// Code returns &name (may be nil).
// Code, &name döndürür (nil olabilir).
func (gv *GV) Code() *sv.SV {
	return gv.code
}

// IO returns the filehandle (may be nil).
// IO, dosya tanıtıcıyı döndürür (nil olabilir).
func (gv *GV) IO() *sv.SV {
	return gv.io
}

// ============================================================
// Setters - Set slot values
// Setter'lar - Slot değerlerini ayarla
// ============================================================

// SetScalar sets $name.
// SetScalar, $name'i ayarlar.
func (gv *GV) SetScalar(val *sv.SV) {
	if gv.scalar != nil {
		gv.scalar.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	gv.scalar = val
}

// SetArray sets @name.
// SetArray, @name'i ayarlar.
func (gv *GV) SetArray(val *sv.SV) {
	if gv.array != nil {
		gv.array.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	gv.array = val
}

// SetHash sets %name.
// SetHash, %name'i ayarlar.
func (gv *GV) SetHash(val *sv.SV) {
	if gv.hash != nil {
		gv.hash.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	gv.hash = val
}

// SetCode sets &name.
// SetCode, &name'i ayarlar.
func (gv *GV) SetCode(val *sv.SV) {
	if gv.code != nil {
		gv.code.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	gv.code = val
}

// SetIO sets the filehandle.
// SetIO, dosya tanıtıcıyı ayarlar.
func (gv *GV) SetIO(val *sv.SV) {
	if gv.io != nil {
		gv.io.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	gv.io = val
}

// ============================================================
// Slot checking
// Slot kontrolü
// ============================================================

// HasScalar returns true if $name is defined.
// HasScalar, $name tanımlıysa true döndürür.
func (gv *GV) HasScalar() bool {
	return gv.scalar != nil && !gv.scalar.IsUndef()
}

// HasArray returns true if @name exists.
// HasArray, @name varsa true döndürür.
func (gv *GV) HasArray() bool {
	return gv.array != nil
}

// HasHash returns true if %name exists.
// HasHash, %name varsa true döndürür.
func (gv *GV) HasHash() bool {
	return gv.hash != nil
}

// HasCode returns true if &name exists.
// HasCode, &name varsa true döndürür.
func (gv *GV) HasCode() bool {
	return gv.code != nil
}

// HasIO returns true if filehandle exists.
// HasIO, dosya tanıtıcı varsa true döndürür.
func (gv *GV) HasIO() bool {
	return gv.io != nil
}

// IsEmpty returns true if glob has no defined slots.
// IsEmpty, glob'un tanımlı slotu yoksa true döndürür.
func (gv *GV) IsEmpty() bool {
	return !gv.HasScalar() && !gv.HasArray() && !gv.HasHash() && !gv.HasCode() && !gv.HasIO()
}

// ============================================================
// Glob assignment (*foo = \$bar, *foo = *bar, etc.)
// Glob ataması (*foo = \$bar, *foo = *bar, vb.)
// ============================================================

// Assign assigns a value to the appropriate slot based on type.
// If val is a reference, assigns to the slot matching the referenced type.
// If val is a glob, copies all slots.
//
// Assign, türe göre değeri uygun slota atar.
// val bir referans ise, referans verilen türle eşleşen slota atar.
// val bir glob ise, tüm slotları kopyalar.
func (gv *GV) Assign(val *sv.SV) {
	if val == nil {
		return
	}

	// If it's a reference, assign to matching slot
	// Referans ise, eşleşen slota ata
	if val.IsRef() {
		target := val.Deref()
		if target == nil {
			return
		}

		switch target.Type() {
		case sv.TypeInt, sv.TypeFloat, sv.TypeString, sv.TypeUndef:
			// Scalar reference -> $slot
			// Skaler referans -> $slot
			gv.SetScalar(target)
		case sv.TypeArray:
			// Array reference -> @slot
			// Dizi referansı -> @slot
			gv.SetArray(target)
		case sv.TypeHash:
			// Hash reference -> %slot
			// Hash referansı -> %slot
			gv.SetHash(target)
		case sv.TypeCode:
			// Code reference -> &slot
			// Kod referansı -> &slot
			gv.SetCode(target)
		case sv.TypeIO:
			// IO reference -> filehandle
			// IO referansı -> dosya tanıtıcı
			gv.SetIO(target)
		}
		return
	}

	// If it's a GV (via TypeGlob), copy all slots
	// GV ise (TypeGlob üzerinden), tüm slotları kopyala
	if val.Type() == sv.TypeGlob {
		// TODO: Extract GV from TypeGlob SV and copy slots
		// TODO: TypeGlob SV'den GV'yi çıkar ve slotları kopyala
		return
	}

	// Otherwise, assign to scalar slot
	// Aksi takdirde, skaler slota ata
	gv.SetScalar(val)
}

// ============================================================
// Utility
// Yardımcı
// ============================================================

// String returns a debug representation.
// String, hata ayıklama temsilini döndürür.
func (gv *GV) String() string {
	return fmt.Sprintf("*%s::%s", gv.pkg, gv.name)
}

// Free releases all slot references.
// Free, tüm slot referanslarını serbest bırakır.
func (gv *GV) Free() {
	if gv.scalar != nil {
		gv.scalar.DecRef()
		gv.scalar = nil
	}
	if gv.array != nil {
		gv.array.DecRef()
		gv.array = nil
	}
	if gv.hash != nil {
		gv.hash.DecRef()
		gv.hash = nil
	}
	if gv.code != nil {
		gv.code.DecRef()
		gv.code = nil
	}
	if gv.io != nil {
		gv.io.DecRef()
		gv.io = nil
	}
}
```

## File: ./pkg/gv/gv_test.go
```go
package gv

import (
	"testing"

	"perlc/pkg/sv"
)

// TestSlots tests glob slot access.
// TestSlots, glob slot erişimini test eder.
func TestSlots(t *testing.T) {
	g := New("main", "foo")

	// Scalar
	g.SetScalar(sv.NewInt(42))
	if g.Scalar().AsInt() != 42 {
		t.Error("$foo should be 42")
	}

	// Array
	arr := g.Array()
	if arr == nil || !arr.IsArray() {
		t.Error("@foo should be array")
	}

	// Hash
	hash := g.Hash()
	if hash == nil || !hash.IsHash() {
		t.Error("hash slot should be hash type")
	}

	// Code (initially nil)
	if g.HasCode() {
		t.Error("&foo should not exist yet")
	}
}

// TestAssign tests *foo = \$bar style assignment.
// TestAssign, *foo = \$bar tarzı atamayı test eder.
func TestAssign(t *testing.T) {
	g := New("main", "foo")

	// Assign scalar ref
	// Skaler referans ata
	scalar := sv.NewInt(100)
	g.Assign(sv.NewRef(scalar))

	if g.Scalar().AsInt() != 100 {
		t.Errorf("$foo should be 100, got %d", g.Scalar().AsInt())
	}

	// Assign array ref
	// Dizi referansı ata
	arr := sv.NewArrayRef(sv.NewInt(1), sv.NewInt(2))
	g.Assign(arr)

	if !g.HasArray() {
		t.Error("@foo should exist after array assign")
	}
}

// TestFullName tests name formatting.
// TestFullName, isim biçimlendirmesini test eder.
func TestFullName(t *testing.T) {
	g1 := New("main", "foo")
	if g1.FullName() != "foo" {
		t.Errorf("main::foo should display as 'foo', got '%s'", g1.FullName())
	}

	g2 := New("MyPackage", "bar")
	if g2.FullName() != "MyPackage::bar" {
		t.Errorf("Expected 'MyPackage::bar', got '%s'", g2.FullName())
	}
}
```

## File: ./pkg/hv/hv.go
```go
// Package hv implements Perl's hash operations.
// Paket hv, Perl'in hash işlemlerini uygular.
//
// Hashes in Perl are heterogeneous - values can be any type.
// Perl'deki hash'ler heterojendir - değerler herhangi bir tür olabilir.
package hv

import (
	"sort"

	"perlc/pkg/sv"
)

// ============================================================
// Hash Access Operations
// Hash Erişim İşlemleri
// ============================================================

// Fetch gets value for key, returns undef if not found.
// Fetch, anahtar için değeri alır, bulunamazsa undef döndürür.
func Fetch(hash *sv.SV, key *sv.SV) *sv.SV {
	if hash == nil {
		return sv.NewUndef()
	}

	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewUndef()
	}

	data := target.HashData()
	if data == nil {
		return sv.NewUndef()
	}

	k := key.AsString()
	if val, ok := data[k]; ok {
		return val
	}
	return sv.NewUndef()
}

// Store sets value for key.
// Store, anahtar için değeri ayarlar.
func Store(hash *sv.SV, key *sv.SV, val *sv.SV) {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		panic("Not a hash / Hash değil")
	}

	data := target.HashData()
	if data == nil {
		data = make(map[string]*sv.SV)
		target.SetHashData(data)
	}

	k := key.AsString()

	// Handle refcounts
	// Referans sayılarını yönet
	if old, ok := data[k]; ok && old != nil {
		old.DecRef()
	}
	if val != nil {
		val.IncRef()
	}
	data[k] = val
}

// Exists checks if key exists (even if value is undef).
// Exists, anahtarın var olup olmadığını kontrol eder (değer undef olsa bile).
func Exists(hash *sv.SV, key *sv.SV) *sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewString("")
	}

	data := target.HashData()
	if data == nil {
		return sv.NewString("")
	}

	k := key.AsString()
	if _, ok := data[k]; ok {
		return sv.NewInt(1)
	}
	return sv.NewString("")
}

// Delete removes key and returns its value.
// Delete, anahtarı kaldırır ve değerini döndürür.
func Delete(hash *sv.SV, key *sv.SV) *sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewUndef()
	}

	data := target.HashData()
	if data == nil {
		return sv.NewUndef()
	}

	k := key.AsString()
	if val, ok := data[k]; ok {
		delete(data, k)
		// Don't decref - we're returning it
		// Decref yapma - döndürüyoruz
		return val
	}
	return sv.NewUndef()
}

// ============================================================
// Hash Information
// Hash Bilgisi
// ============================================================

// Scalar returns hash in scalar context.
// Empty hash returns false, non-empty returns element count.
//
// Scalar, hash'i skaler bağlamda döndürür.
// Boş hash false döndürür, dolu hash eleman sayısını döndürür.
func Scalar(hash *sv.SV) *sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewInt(0)
	}

	data := target.HashData()
	if len(data) == 0 {
		return sv.NewString("") // Empty hash is false / Boş hash false'tur
	}
	return sv.NewInt(int64(len(data)))
}

// ============================================================
// Keys, Values, Each
// Anahtarlar, Değerler, Her Biri
// ============================================================

// Keys returns all keys as a list.
// Keys, tüm anahtarları liste olarak döndürür.
func Keys(hash *sv.SV) []*sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return []*sv.SV{}
	}

	data := target.HashData()
	if data == nil {
		return []*sv.SV{}
	}

	result := make([]*sv.SV, 0, len(data))
	for k := range data {
		result = append(result, sv.NewString(k))
	}
	return result
}

// KeysSorted returns keys sorted alphabetically.
// KeysSorted, anahtarları alfabetik sıralı döndürür.
func KeysSorted(hash *sv.SV) []*sv.SV {
	keys := Keys(hash)
	sort.Slice(keys, func(i, j int) bool {
		return keys[i].AsString() < keys[j].AsString()
	})
	return keys
}

// Values returns all values as a list.
// Values, tüm değerleri liste olarak döndürür.
func Values(hash *sv.SV) []*sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return []*sv.SV{}
	}

	data := target.HashData()
	if data == nil {
		return []*sv.SV{}
	}

	result := make([]*sv.SV, 0, len(data))
	for _, v := range data {
		if v != nil {
			v.IncRef()
		}
		result = append(result, v)
	}
	return result
}

// HashIterator maintains state for each() function.
// HashIterator, each() fonksiyonu için durumu korur.
type HashIterator struct {
	keys  []string
	index int
}

// iterators stores per-hash iterator state.
// iterators, hash başına iteratör durumunu saklar.
var iterators = make(map[*sv.SV]*HashIterator)

// Each returns next (key, value) pair for iteration.
// Returns empty slice when exhausted.
//
// Each, iterasyon için sonraki (anahtar, değer) çiftini döndürür.
// Tükendiğinde boş dilim döndürür.
func Each(hash *sv.SV) []*sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return []*sv.SV{}
	}

	data := target.HashData()
	if data == nil {
		return []*sv.SV{}
	}

	// Get or create iterator
	// İteratörü al veya oluştur
	iter, ok := iterators[target]
	if !ok {
		iter = &HashIterator{
			keys:  make([]string, 0, len(data)),
			index: 0,
		}
		for k := range data {
			iter.keys = append(iter.keys, k)
		}
		iterators[target] = iter
	}

	// Return next pair
	// Sonraki çifti döndür
	if iter.index >= len(iter.keys) {
		// Reset for next iteration
		// Sonraki iterasyon için sıfırla
		delete(iterators, target)
		return []*sv.SV{}
	}

	key := iter.keys[iter.index]
	val := data[key]
	iter.index++

	if val != nil {
		val.IncRef()
	}
	return []*sv.SV{sv.NewString(key), val}
}

// ResetIterator resets the each() iterator.
// ResetIterator, each() iteratörünü sıfırlar.
func ResetIterator(hash *sv.SV) {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	delete(iterators, target)
}

// ============================================================
// Hash Manipulation
// Hash Manipülasyonu
// ============================================================

// Clear empties the hash.
// Clear, hash'i boşaltır.
func Clear(hash *sv.SV) {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return
	}

	data := target.HashData()
	if data == nil {
		return
	}

	// Decref all values
	// Tüm değerlerin referanslarını azalt
	for _, v := range data {
		if v != nil {
			v.DecRef()
		}
	}
	target.SetHashData(make(map[string]*sv.SV))
	delete(iterators, target)
}

// Clone creates a shallow copy of the hash.
// Clone, hash'in sığ bir kopyasını oluşturur.
func Clone(hash *sv.SV) *sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewHashRef()
	}

	data := target.HashData()
	newHash := sv.NewHashRef()
	newTarget := newHash.Deref()
	newData := make(map[string]*sv.SV, len(data))

	for k, v := range data {
		if v != nil {
			v.IncRef()
		}
		newData[k] = v
	}
	newTarget.SetHashData(newData)

	return newHash
}

// Merge merges multiple hashes, later values override earlier.
// Merge, birden fazla hash'i birleştirir, sonraki değerler öncekileri geçersiz kılar.
func Merge(hashes ...*sv.SV) *sv.SV {
	result := sv.NewHashRef()
	resultTarget := result.Deref()
	resultData := make(map[string]*sv.SV)

	for _, hash := range hashes {
		target := hash
		if hash.IsRef() {
			target = hash.Deref()
		}
		if target == nil || !target.IsHash() {
			continue
		}

		data := target.HashData()
		for k, v := range data {
			// Decref old value if overwriting
			// Üzerine yazılıyorsa eski değerin referansını azalt
			if old, ok := resultData[k]; ok && old != nil {
				old.DecRef()
			}
			if v != nil {
				v.IncRef()
			}
			resultData[k] = v
		}
	}

	resultTarget.SetHashData(resultData)
	return result
}

// ============================================================
// Hash Slice Operations
// Hash Dilim İşlemleri
// ============================================================

// Slice gets multiple values: @hash{@keys}
// Slice, birden fazla değer alır: @hash{@keys}
func Slice(hash *sv.SV, keys []*sv.SV) []*sv.SV {
	result := make([]*sv.SV, len(keys))
	for i, k := range keys {
		result[i] = Fetch(hash, k)
		result[i].IncRef()
	}
	return result
}

// SliceStore sets multiple values: @hash{@keys} = @values
// SliceStore, birden fazla değer ayarlar: @hash{@keys} = @values
func SliceStore(hash *sv.SV, keys []*sv.SV, values []*sv.SV) {
	for i, k := range keys {
		var v *sv.SV
		if i < len(values) {
			v = values[i]
		} else {
			v = sv.NewUndef()
		}
		Store(hash, k, v)
	}
}

// DeleteSlice deletes multiple keys, returns removed values.
// DeleteSlice, birden fazla anahtarı siler, kaldırılan değerleri döndürür.
func DeleteSlice(hash *sv.SV, keys []*sv.SV) []*sv.SV {
	result := make([]*sv.SV, len(keys))
	for i, k := range keys {
		result[i] = Delete(hash, k)
	}
	return result
}

// ============================================================
// Hash to List Conversion
// Hash'ten Listeye Dönüşüm
// ============================================================

// Flatten returns hash as flat list: (key1, val1, key2, val2, ...)
// Flatten, hash'i düz liste olarak döndürür: (anahtar1, değer1, anahtar2, değer2, ...)
func Flatten(hash *sv.SV) []*sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return []*sv.SV{}
	}

	data := target.HashData()
	result := make([]*sv.SV, 0, len(data)*2)

	for k, v := range data {
		result = append(result, sv.NewString(k))
		if v != nil {
			v.IncRef()
		}
		result = append(result, v)
	}

	return result
}

// FromList creates hash from flat list.
// Odd number of elements: last key gets undef.
//
// FromList, düz listeden hash oluşturur.
// Tek sayıda eleman: son anahtar undef alır.
func FromList(list []*sv.SV) *sv.SV {
	hash := sv.NewHashRef()
	target := hash.Deref()
	data := make(map[string]*sv.SV)

	for i := 0; i < len(list)-1; i += 2 {
		k := list[i].AsString()
		v := list[i+1]
		if v != nil {
			v.IncRef()
		}
		data[k] = v
	}

	// Odd number of elements - last key gets undef
	// Tek sayıda eleman - son anahtar undef alır
	if len(list)%2 == 1 {
		k := list[len(list)-1].AsString()
		data[k] = sv.NewUndef()
	}

	target.SetHashData(data)
	return hash
}

// ============================================================
// Utility Functions
// Yardımcı Fonksiyonlar
// ============================================================

// Invert swaps keys and values: %inverse = reverse %hash
// Invert, anahtarları ve değerleri değiştirir: %inverse = reverse %hash
func Invert(hash *sv.SV) *sv.SV {
	target := hash
	if hash.IsRef() {
		target = hash.Deref()
	}
	if target == nil || !target.IsHash() {
		return sv.NewHashRef()
	}

	data := target.HashData()
	result := sv.NewHashRef()
	resultTarget := result.Deref()
	resultData := make(map[string]*sv.SV, len(data))

	for k, v := range data {
		newKey := ""
		if v != nil {
			newKey = v.AsString()
		}
		resultData[newKey] = sv.NewString(k)
	}

	resultTarget.SetHashData(resultData)
	return result
}
```

## File: ./pkg/hv/hv_test.go
```go
package hv

import (
	"testing"

	"perlc/pkg/sv"
)

// TestFetchStore tests basic hash access.
// TestFetchStore, temel hash erişimini test eder.
func TestFetchStore(t *testing.T) {
	hash := sv.NewHashRef()

	Store(hash, sv.NewString("name"), sv.NewString("Perl"))
	Store(hash, sv.NewString("year"), sv.NewInt(1987))

	val := Fetch(hash, sv.NewString("name"))
	if val.AsString() != "Perl" {
		t.Errorf("Expected 'Perl', got '%s'", val.AsString())
	}

	val = Fetch(hash, sv.NewString("year"))
	if val.AsInt() != 1987 {
		t.Errorf("Expected 1987, got %d", val.AsInt())
	}

	// Non-existent key returns undef
	// Var olmayan anahtar undef döndürür
	val = Fetch(hash, sv.NewString("missing"))
	if !val.IsUndef() {
		t.Error("Missing key should return undef")
	}
}

// TestExists tests key existence check.
// TestExists, anahtar varlık kontrolünü test eder.
func TestExists(t *testing.T) {
	hash := sv.NewHashRef()
	Store(hash, sv.NewString("key"), sv.NewUndef())

	// Key exists even if value is undef
	// Değer undef olsa bile anahtar var
	if !Exists(hash, sv.NewString("key")).AsBool() {
		t.Error("Key should exist")
	}

	if Exists(hash, sv.NewString("missing")).AsBool() {
		t.Error("Missing key should not exist")
	}
}

// TestDelete tests key deletion.
// TestDelete, anahtar silmeyi test eder.
func TestDelete(t *testing.T) {
	hash := sv.NewHashRef()
	Store(hash, sv.NewString("key"), sv.NewInt(42))

	val := Delete(hash, sv.NewString("key"))
	if val.AsInt() != 42 {
		t.Errorf("Delete should return 42, got %d", val.AsInt())
	}

	if Exists(hash, sv.NewString("key")).AsBool() {
		t.Error("Key should not exist after delete")
	}
}

// TestKeysValues tests keys() and values().
// TestKeysValues, keys() ve values() fonksiyonlarını test eder.
func TestKeysValues(t *testing.T) {
	hash := sv.NewHashRef()
	Store(hash, sv.NewString("a"), sv.NewInt(1))
	Store(hash, sv.NewString("b"), sv.NewInt(2))
	Store(hash, sv.NewString("c"), sv.NewInt(3))

	keys := Keys(hash)
	if len(keys) != 3 {
		t.Errorf("Should have 3 keys, got %d", len(keys))
	}

	values := Values(hash)
	if len(values) != 3 {
		t.Errorf("Should have 3 values, got %d", len(values))
	}
}

// TestEach tests iteration.
// TestEach, iterasyonu test eder.
func TestEach(t *testing.T) {
	hash := sv.NewHashRef()
	Store(hash, sv.NewString("x"), sv.NewInt(10))
	Store(hash, sv.NewString("y"), sv.NewInt(20))

	count := 0
	for {
		pair := Each(hash)
		if len(pair) == 0 {
			break
		}
		count++
	}

	if count != 2 {
		t.Errorf("Should iterate 2 times, got %d", count)
	}
}

// TestFromList tests hash creation from list.
// TestFromList, listeden hash oluşturmayı test eder.
func TestFromList(t *testing.T) {
	list := []*sv.SV{
		sv.NewString("name"), sv.NewString("Perl"),
		sv.NewString("year"), sv.NewInt(1987),
	}

	hash := FromList(list)

	if Fetch(hash, sv.NewString("name")).AsString() != "Perl" {
		t.Error("name should be 'Perl'")
	}
	if Fetch(hash, sv.NewString("year")).AsInt() != 1987 {
		t.Error("year should be 1987")
	}
}

// TestMerge tests hash merging.
// TestMerge, hash birleştirmeyi test eder.
func TestMerge(t *testing.T) {
	h1 := sv.NewHashRef()
	Store(h1, sv.NewString("a"), sv.NewInt(1))
	Store(h1, sv.NewString("b"), sv.NewInt(2))

	h2 := sv.NewHashRef()
	Store(h2, sv.NewString("b"), sv.NewInt(20)) // Override
	Store(h2, sv.NewString("c"), sv.NewInt(3))

	merged := Merge(h1, h2)

	if Fetch(merged, sv.NewString("a")).AsInt() != 1 {
		t.Error("a should be 1")
	}
	if Fetch(merged, sv.NewString("b")).AsInt() != 20 {
		t.Error("b should be 20 (overridden)")
	}
	if Fetch(merged, sv.NewString("c")).AsInt() != 3 {
		t.Error("c should be 3")
	}
}

// TestSlice tests hash slicing.
// TestSlice, hash dilimlemeyi test eder.
func TestSlice(t *testing.T) {
	hash := sv.NewHashRef()
	Store(hash, sv.NewString("a"), sv.NewInt(1))
	Store(hash, sv.NewString("b"), sv.NewInt(2))
	Store(hash, sv.NewString("c"), sv.NewInt(3))

	keys := []*sv.SV{sv.NewString("a"), sv.NewString("c")}
	values := Slice(hash, keys)

	if len(values) != 2 {
		t.Errorf("Should get 2 values, got %d", len(values))
	}
	if values[0].AsInt() != 1 || values[1].AsInt() != 3 {
		t.Error("Got wrong values from slice")
	}
}
```

## File: ./pkg/lexer/lexer.go
```go
package lexer

import (
	"fmt"
	"strings"
	"unicode"
	"unicode/utf8"
)

// Lexer tokenizes Perl source code.
// Lexer, Perl kaynak kodunu tokenize eder.
type Lexer struct {
	input   string // Source code / Kaynak kod
	file    string // Filename / Dosya adı
	pos     int    // Current position in input / input'taki geçerli konum
	readPos int    // Reading position (after current char) / Okuma konumu
	line    int    // Current line number / Geçerli satır numarası
	column  int    // Current column number / Geçerli sütun numarası
	ch      rune   // Current character / Geçerli karakter

	// Context for disambiguation
	// Belirsizlik giderme için bağlam
	lastToken TokenType // Previous token type / Önceki token türü
}

// New creates a new lexer for the given input.
// New, verilen input için yeni bir lexer oluşturur.
func New(input string) *Lexer {
	l := &Lexer{
		input:  input,
		file:   "<input>",
		line:   1,
		column: 0,
	}
	l.readChar()
	return l
}

// NewFile creates a lexer with filename for error reporting.
// NewFile, hata raporlaması için dosya adı ile lexer oluşturur.
func NewFile(input, filename string) *Lexer {
	l := New(input)
	l.file = filename
	return l
}

// readChar advances to the next character.
// readChar, sonraki karaktere ilerler.
func (l *Lexer) readChar() {
	if l.readPos >= len(l.input) {
		l.ch = 0 // EOF
	} else {
		l.ch, _ = utf8.DecodeRuneInString(l.input[l.readPos:])
	}
	l.pos = l.readPos
	if l.ch == '\n' {
		l.line++
		l.column = 0
	} else {
		l.column++
	}
	l.readPos += utf8.RuneLen(l.ch)
}

// peekChar returns next character without advancing.
// peekChar, ilerlemeden sonraki karakteri döndürür.
func (l *Lexer) peekChar() rune {
	if l.readPos >= len(l.input) {
		return 0
	}
	ch, _ := utf8.DecodeRuneInString(l.input[l.readPos:])
	return ch
}

// peekChars returns next n characters without advancing.
// peekChars, ilerlemeden sonraki n karakteri döndürür.
// func (l *Lexer) peekChars(n int) string {
// 	end := l.readPos + n
// 	if end > len(l.input) {
// 		end = len(l.input)
// 	}
// 	return l.input[l.readPos:end]
// }

// skipWhitespace skips spaces and tabs (not newlines).
// skipWhitespace, boşlukları ve tabları atlar (satır sonlarını değil).
func (l *Lexer) skipWhitespace() {
	for l.ch == ' ' || l.ch == '\t' || l.ch == '\r' {
		l.readChar()
	}
}

// skipComment skips a comment until end of line.
// skipComment, satır sonuna kadar yorumu atlar.
func (l *Lexer) skipComment() {
	for l.ch != '\n' && l.ch != 0 {
		l.readChar()
	}
}

// NextToken returns the next token.
// NextToken, sonraki tokeni döndürür.
func (l *Lexer) NextToken() Token {
	l.skipWhitespace()

	// Skip comments
	// Yorumları atla
	if l.ch == '#' {
		l.skipComment()
		l.skipWhitespace()
	}

	tok := Token{
		Line:   l.line,
		Column: l.column,
		File:   l.file,
	}

	switch l.ch {
	case 0:
		tok.Type = TokEOF

	case '\n':
		tok.Type = TokNewline
		tok.Value = "\n"
		l.readChar()

	// Single character tokens
	case '(':
		tok.Type = TokLParen
		tok.Value = "("
		l.readChar()
	case ')':
		tok.Type = TokRParen
		tok.Value = ")"
		l.readChar()
	case '[':
		tok.Type = TokLBracket
		tok.Value = "["
		l.readChar()
	case ']':
		tok.Type = TokRBracket
		tok.Value = "]"
		l.readChar()
	case '{':
		tok.Type = TokLBrace
		tok.Value = "{"
		l.readChar()
	case '}':
		tok.Type = TokRBrace
		tok.Value = "}"
		l.readChar()
	case ';':
		tok.Type = TokSemi
		tok.Value = ";"
		l.readChar()
	case ',':
		tok.Type = TokComma
		tok.Value = ","
		l.readChar()
	case '?':
		tok.Type = TokQuestion
		tok.Value = "?"
		l.readChar()
	case '~':
		tok.Type = TokBitNot
		tok.Value = "~"
		l.readChar()
	case '\\':
		tok.Type = TokBackslash
		tok.Value = "\\"
		l.readChar()

	// Multi-character operators
	case '+':
		tok = l.readPlus()
	case '-':
		tok = l.readMinus()
	case '*':
		tok = l.readStar()
	case '/':
		tok = l.readSlash()
	case '%':
		tok = l.readPercent()
	case '.':
		tok = l.readDot()
	case '=':
		tok = l.readEquals()
	case '!':
		tok = l.readBang()
	case '<':
		tok = l.readLess()
	case '>':
		tok = l.readGreater()
	case '&':
		tok = l.readAmpersand()
	case '|':
		tok = l.readPipe()
	case '^':
		tok = l.readCaret()
	case ':':
		tok = l.readColon()

	// Variables
	case '$':
		tok = l.readScalar()
	case '@':
		tok = l.readArray()

	// String literals
	case '"':
		tok = l.readDoubleQuotedString()
	case '\'':
		tok = l.readSingleQuotedString()
	case '`':
		tok = l.readBacktickString()

	default:
		if isDigit(l.ch) {
			tok = l.readNumber()
		} else if l.ch == 's' && l.peekChar() == '/' {
			tok = l.readSubst()
		} else if l.ch == 'm' && l.peekChar() == '/' {
			tok = l.readMatchOp()
		} else if isIdentStart(l.ch) {
			tok = l.readIdentifier()
		} else {
			tok.Type = TokError
			tok.Value = fmt.Sprintf("unexpected character: %c", l.ch)
			l.readChar()
		}
	}

	l.lastToken = tok.Type
	return tok
}

// ============================================================
// Operator readers
// Operatör okuyucuları
// ============================================================

func (l *Lexer) readPlus() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '+':
		tok.Type = TokIncr
		tok.Value = "++"
		l.readChar()
	case '=':
		tok.Type = TokPlusEq
		tok.Value = "+="
		l.readChar()
	default:
		tok.Type = TokPlus
		tok.Value = "+"
	}
	return tok
}

func (l *Lexer) readMinus() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '-':
		tok.Type = TokDecr
		tok.Value = "--"
		l.readChar()
	case '=':
		tok.Type = TokMinusEq
		tok.Value = "-="
		l.readChar()
	case '>':
		tok.Type = TokArrow
		tok.Value = "->"
		l.readChar()
	default:
		tok.Type = TokMinus
		tok.Value = "-"
	}
	return tok
}

func (l *Lexer) readStar() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '*':
		l.readChar()
		if l.ch == '=' {
			tok.Type = TokStarStarEq
			tok.Value = "**="
			l.readChar()
		} else {
			tok.Type = TokStarStar
			tok.Value = "**"
		}
	case '=':
		tok.Type = TokStarEq
		tok.Value = "*="
		l.readChar()
	default:
		// Could be glob or multiplication
		// Glob veya çarpma olabilir
		tok.Type = TokStar
		tok.Value = "*"
	}
	return tok
}

func (l *Lexer) readSlash() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}

	// Check for // or //= first (defined-or) - before regex check
	// Önce // veya //= kontrol et (defined-or) - regex kontrolünden önce
	if l.peekChar() == '/' {
		l.readChar() // consume first /
		l.readChar() // consume second /
		if l.ch == '=' {
			tok.Type = TokDefinedOrEq
			tok.Value = "//="
			l.readChar()
		} else {
			tok.Type = TokDefinedOr
			tok.Value = "//"
		}
		return tok
	}

	// Check if this could be a regex
	// Bu bir regex olabilir mi kontrol et
	if l.expectRegex() {
		return l.readRegex('/')
	}

	l.readChar()
	if l.ch == '=' {
		tok.Type = TokSlashEq
		tok.Value = "/="
		l.readChar()
	} else {
		tok.Type = TokSlash
		tok.Value = "/"
	}
	return tok
}

func (l *Lexer) readPercent() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()

	// Check for hash variable
	// Hash değişkeni kontrol et
	if isIdentStart(l.ch) {
		name := l.readIdentName()
		tok.Type = TokHash
		tok.Value = "%" + name
		return tok
	}

	if l.ch == '=' {
		tok.Type = TokPercentEq
		tok.Value = "%="
		l.readChar()
	} else {
		tok.Type = TokPercent
		tok.Value = "%"
	}
	return tok
}

func (l *Lexer) readDot() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '.':
		l.readChar()
		if l.ch == '.' {
			tok.Type = TokRange3
			tok.Value = "..."
			l.readChar()
		} else {
			tok.Type = TokRange
			tok.Value = ".."
		}
	case '=':
		tok.Type = TokDotEq
		tok.Value = ".="
		l.readChar()
	default:
		tok.Type = TokDot
		tok.Value = "."
	}
	return tok
}

func (l *Lexer) readEquals() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '=':
		tok.Type = TokEq
		tok.Value = "=="
		l.readChar()
	case '~':
		tok.Type = TokMatch
		tok.Value = "=~"
		l.readChar()
	case '>':
		tok.Type = TokFatArrow
		tok.Value = "=>"
		l.readChar()
	default:
		tok.Type = TokAssign
		tok.Value = "="
	}
	return tok
}

func (l *Lexer) readBang() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '=':
		tok.Type = TokNe
		tok.Value = "!="
		l.readChar()
	case '~':
		tok.Type = TokNotMatch
		tok.Value = "!~"
		l.readChar()
	default:
		tok.Type = TokNot
		tok.Value = "!"
	}
	return tok
}

func (l *Lexer) readLess() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '<':
		l.readChar()
		if l.ch == '=' {
			tok.Type = TokLeftShiftEq
			tok.Value = "<<="
			l.readChar()
		} else {
			tok.Type = TokLeftShift
			tok.Value = "<<"
		}
	case '=':
		l.readChar()
		if l.ch == '>' {
			tok.Type = TokSpaceship
			tok.Value = "<=>"
			l.readChar()
		} else {
			tok.Type = TokLe
			tok.Value = "<="
		}
	case '>':
		// <> - read from ARGV/STDIN
		tok.Type = TokDiamond
		tok.Value = "<>"
		l.readChar()
	case '$':
		// <$fh> - read from filehandle variable
		tok.Type = TokReadLine
		var sb strings.Builder
		sb.WriteRune(l.ch)
		l.readChar()
		for l.ch != '>' && l.ch != 0 {
			sb.WriteRune(l.ch)
			l.readChar()
		}
		tok.Value = sb.String()
		if l.ch == '>' {
			l.readChar()
		}
	default:
		// Check if it's <FH> (bareword filehandle)
		if isIdentStart(l.ch) {
			tok.Type = TokReadLine
			var sb strings.Builder
			for l.ch != '>' && l.ch != 0 && !isSpace(l.ch) {
				sb.WriteRune(l.ch)
				l.readChar()
			}
			tok.Value = sb.String()
			if l.ch == '>' {
				l.readChar()
			}
		} else {
			tok.Type = TokLt
			tok.Value = "<"
		}
	}
	return tok
}

func (l *Lexer) readGreater() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '>':
		l.readChar()
		if l.ch == '=' {
			tok.Type = TokRightShiftEq
			tok.Value = ">>="
			l.readChar()
		} else {
			tok.Type = TokRightShift
			tok.Value = ">>"
		}
	case '=':
		tok.Type = TokGe
		tok.Value = ">="
		l.readChar()
	default:
		tok.Type = TokGt
		tok.Value = ">"
	}
	return tok
}

func (l *Lexer) readAmpersand() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()

	// Check for code reference &sub
	// Kod referansı &sub kontrol et
	if isIdentStart(l.ch) {
		name := l.readIdentName()
		tok.Type = TokCode
		tok.Value = "&" + name
		return tok
	}

	switch l.ch {
	case '&':
		l.readChar()
		if l.ch == '=' {
			tok.Type = TokAndEq
			tok.Value = "&&="
			l.readChar()
		} else {
			tok.Type = TokAnd
			tok.Value = "&&"
		}
	case '=':
		tok.Type = TokBitAndEq
		tok.Value = "&="
		l.readChar()
	default:
		tok.Type = TokBitAnd
		tok.Value = "&"
	}
	return tok
}

func (l *Lexer) readPipe() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	switch l.ch {
	case '|':
		l.readChar()
		if l.ch == '=' {
			tok.Type = TokOrEq
			tok.Value = "||="
			l.readChar()
		} else {
			tok.Type = TokOr
			tok.Value = "||"
		}
	case '=':
		tok.Type = TokBitOrEq
		tok.Value = "|="
		l.readChar()
	default:
		tok.Type = TokBitOr
		tok.Value = "|"
	}
	return tok
}

func (l *Lexer) readCaret() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	if l.ch == '=' {
		tok.Type = TokBitXorEq
		tok.Value = "^="
		l.readChar()
	} else {
		tok.Type = TokBitXor
		tok.Value = "^"
	}
	return tok
}

func (l *Lexer) readColon() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar()
	if l.ch == ':' {
		tok.Type = TokDoubleColon
		tok.Value = "::"
		l.readChar()
	} else {
		tok.Type = TokColon
		tok.Value = ":"
	}
	return tok
}

// ============================================================
// Variable readers
// Değişken okuyucuları
// ============================================================

func (l *Lexer) readScalar() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar() // Skip $

	// Special variables: $_, $@, $!, $$, etc.
	// Özel değişkenler: $_, $@, $!, $$, vb.
	switch l.ch {
	case '$':
		// Check if this is $$var (dereference) or $$ (PID)
		if isIdentStart(l.peekChar()) {
			// $$var - scalar dereference
			l.readChar() // skip second $
			name := l.readIdentName()
			tok.Type = TokScalar
			tok.Value = "$$" + name
			return tok
		}
		// $$ alone - PID special variable
		tok.Type = TokSpecialVar
		tok.Value = "$$"
		l.readChar()
		return tok
	case '_', '@', '!', '?', '"', '/', '\\', '&', '`', '\'', '+', '.', '|', '-', '^', '~', '=', '%', ':':
		tok.Type = TokSpecialVar
		tok.Value = "$" + string(l.ch)
		l.readChar()
		return tok
	case '#':
		// $#array - array length
		l.readChar()
		if isIdentStart(l.ch) {
			name := l.readIdentName()
			tok.Type = TokArrayLen
			tok.Value = "$#" + name
		} else {
			tok.Type = TokSpecialVar
			tok.Value = "$#"
		}
		return tok
	case '{':
		// ${var} - explicit variable name
		// ${var} - açık değişken adı
		l.readChar()
		name := l.readIdentName()
		if l.ch == '}' {
			l.readChar()
		}
		tok.Type = TokScalar
		tok.Value = "$" + name
		return tok
	}

	// Regular scalar $var or $Pkg::var
	// Normal skaler $var veya $Pkg::var
	if isIdentStart(l.ch) || isDigit(l.ch) {
		name := l.readIdentName()

		// Check for $1, $2, etc.
		// $1, $2, vb. kontrol et
		if len(name) > 0 && isDigit(rune(name[0])) {
			tok.Type = TokSpecialVar
		} else {
			tok.Type = TokScalar
		}
		tok.Value = "$" + name
	} else {
		tok.Type = TokError
		tok.Value = "expected variable name after $"
	}

	return tok
}

func (l *Lexer) readArray() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	l.readChar() // Skip @

	// Special: @_ @ARGV @ISA
	switch l.ch {
	case '_':
		tok.Type = TokSpecialVar
		tok.Value = "@_"
		l.readChar()
		return tok
	case '{':
		l.readChar()
		name := l.readIdentName()
		if l.ch == '}' {
			l.readChar()
		}
		tok.Type = TokArray
		tok.Value = "@" + name
		return tok
	}

	if isIdentStart(l.ch) {
		name := l.readIdentName()
		tok.Type = TokArray
		tok.Value = "@" + name
	} else {
		tok.Type = TokError
		tok.Value = "expected variable name after @"
	}

	return tok
}

// ============================================================
// String readers
// String okuyucuları
// ============================================================

func (l *Lexer) readDoubleQuotedString() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokString}
	l.readChar() // Skip opening "

	var sb strings.Builder
	for l.ch != '"' && l.ch != 0 {
		if l.ch == '\\' {
			l.readChar()
			switch l.ch {
			case 'n':
				sb.WriteByte('\n')
			case 't':
				sb.WriteByte('\t')
			case 'r':
				sb.WriteByte('\r')
			case '\\':
				sb.WriteByte('\\')
			case '"':
				sb.WriteByte('"')
			case '$':
				sb.WriteByte('$')
			case '@':
				sb.WriteByte('@')
			default:
				sb.WriteByte('\\')
				sb.WriteRune(l.ch)
			}
		} else {
			sb.WriteRune(l.ch)
		}
		l.readChar()
	}

	if l.ch == '"' {
		l.readChar() // Skip closing "
	}

	tok.Value = sb.String()
	return tok
}

func (l *Lexer) readSingleQuotedString() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokRawString}
	l.readChar() // Skip opening '

	var sb strings.Builder
	for l.ch != '\'' && l.ch != 0 {
		if l.ch == '\\' && l.peekChar() == '\'' {
			l.readChar()
			sb.WriteByte('\'')
		} else if l.ch == '\\' && l.peekChar() == '\\' {
			l.readChar()
			sb.WriteByte('\\')
		} else {
			sb.WriteRune(l.ch)
		}
		l.readChar()
	}

	if l.ch == '\'' {
		l.readChar() // Skip closing '
	}

	tok.Value = sb.String()
	return tok
}

func (l *Lexer) readBacktickString() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokString}
	l.readChar() // Skip opening `

	var sb strings.Builder
	for l.ch != '`' && l.ch != 0 {
		sb.WriteRune(l.ch)
		l.readChar()
	}

	if l.ch == '`' {
		l.readChar()
	}

	tok.Value = sb.String()
	return tok
}

// ============================================================
// Number reader
// Sayı okuyucu
// ============================================================

func (l *Lexer) readNumber() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}

	var sb strings.Builder
	isFloat := false

	// Check for hex, octal, binary
	// Hex, octal, binary kontrol et
	if l.ch == '0' {
		sb.WriteRune(l.ch)
		l.readChar()

		switch l.ch {
		case 'x', 'X':
			// Hexadecimal
			sb.WriteRune(l.ch)
			l.readChar()
			for isHexDigit(l.ch) || l.ch == '_' {
				if l.ch != '_' {
					sb.WriteRune(l.ch)
				}
				l.readChar()
			}
			tok.Type = TokInteger
			tok.Value = sb.String()
			return tok

		case 'b', 'B':
			// Binary
			sb.WriteRune(l.ch)
			l.readChar()
			for l.ch == '0' || l.ch == '1' || l.ch == '_' {
				if l.ch != '_' {
					sb.WriteRune(l.ch)
				}
				l.readChar()
			}
			tok.Type = TokInteger
			tok.Value = sb.String()
			return tok

		case 'o', 'O':
			// Octal (explicit)
			sb.WriteRune(l.ch)
			l.readChar()
			for isOctalDigit(l.ch) || l.ch == '_' {
				if l.ch != '_' {
					sb.WriteRune(l.ch)
				}
				l.readChar()
			}
			tok.Type = TokInteger
			tok.Value = sb.String()
			return tok
		}
	}

	// Read integer part
	// Tamsayı kısmını oku
	for isDigit(l.ch) || l.ch == '_' {
		if l.ch != '_' {
			sb.WriteRune(l.ch)
		}
		l.readChar()
	}

	// Check for decimal point
	// Ondalık nokta kontrol et
	if l.ch == '.' && isDigit(l.peekChar()) {
		isFloat = true
		sb.WriteRune(l.ch)
		l.readChar()
		for isDigit(l.ch) || l.ch == '_' {
			if l.ch != '_' {
				sb.WriteRune(l.ch)
			}
			l.readChar()
		}
	}

	// Check for exponent
	// Üs kontrol et
	if l.ch == 'e' || l.ch == 'E' {
		isFloat = true
		sb.WriteRune(l.ch)
		l.readChar()
		if l.ch == '+' || l.ch == '-' {
			sb.WriteRune(l.ch)
			l.readChar()
		}
		for isDigit(l.ch) {
			sb.WriteRune(l.ch)
			l.readChar()
		}
	}

	if isFloat {
		tok.Type = TokFloat
	} else {
		tok.Type = TokInteger
	}
	tok.Value = sb.String()
	return tok
}

// ============================================================
// Identifier reader
// Tanımlayıcı okuyucu
// ============================================================

func (l *Lexer) readIdentifier() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file}
	name := l.readIdentName()

	tok.Type = LookupKeyword(name)
	tok.Value = name
	return tok
}

func (l *Lexer) readIdentName() string {
	var sb strings.Builder
	for isIdentChar(l.ch) {
		sb.WriteRune(l.ch)
		l.readChar()
	}

	// Handle Package::Name
	for l.ch == ':' && l.peekChar() == ':' {
		sb.WriteRune(l.ch)
		l.readChar()
		sb.WriteRune(l.ch)
		l.readChar()
		for isIdentChar(l.ch) {
			sb.WriteRune(l.ch)
			l.readChar()
		}
	}

	return sb.String()
}

// ============================================================
// Regex reader
// Regex okuyucu
// ============================================================

func (l *Lexer) readRegex(delim rune) Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokRegex}
	l.readChar() // Skip opening delimiter

	var sb strings.Builder
	for l.ch != delim && l.ch != 0 {
		if l.ch == '\\' {
			sb.WriteRune(l.ch)
			l.readChar()
			if l.ch != 0 {
				sb.WriteRune(l.ch)
				l.readChar()
			}
		} else {
			sb.WriteRune(l.ch)
			l.readChar()
		}
	}

	pattern := sb.String()

	if l.ch == delim {
		l.readChar()
	}

	// Read modifiers
	// Değiştiricileri oku
	var mods strings.Builder
	for l.ch == 'i' || l.ch == 'm' || l.ch == 's' || l.ch == 'x' || l.ch == 'g' || l.ch == 'o' {
		mods.WriteRune(l.ch)
		l.readChar()
	}

	if mods.Len() > 0 {
		tok.Value = pattern + "/" + mods.String()
	} else {
		tok.Value = pattern
	}

	return tok
}

// expectRegex returns true if the next / should be a regex.
// expectRegex, sonraki / regex olmalıysa true döndürür.
func (l *Lexer) expectRegex() bool {
	switch l.lastToken {
	case TokEOF, TokNewline, TokSemi, TokLParen, TokLBracket, TokLBrace,
		TokComma, TokAssign, TokMatch, TokNotMatch, TokAnd, TokOr,
		TokNot, TokQuestion, TokColon, TokIf, TokUnless, TokWhile,
		TokUntil, TokFor, TokForeach, TokAndWord, TokOrWord, TokNotWord:
		return true
	}
	return false
}

func (l *Lexer) readSubst() Token {
	tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokSubst}
	l.readChar() // skip 's'
	delim := l.ch
	l.readChar() // skip opening delimiter

	// Read pattern
	var pattern strings.Builder
	for l.ch != delim && l.ch != 0 {
		if l.ch == '\\' {
			pattern.WriteRune(l.ch)
			l.readChar()
			if l.ch != 0 {
				pattern.WriteRune(l.ch)
				l.readChar()
			}
		} else {
			pattern.WriteRune(l.ch)
			l.readChar()
		}
	}
	l.readChar() // skip middle delimiter

	// Read replacement
	var replacement strings.Builder
	for l.ch != delim && l.ch != 0 {
		if l.ch == '\\' {
			replacement.WriteRune(l.ch)
			l.readChar()
			if l.ch != 0 {
				replacement.WriteRune(l.ch)
				l.readChar()
			}
		} else {
			replacement.WriteRune(l.ch)
			l.readChar()
		}
	}
	l.readChar() // skip closing delimiter

	// Read flags
	var flags strings.Builder
	for l.ch == 'g' || l.ch == 'i' || l.ch == 'm' || l.ch == 's' || l.ch == 'x' || l.ch == 'e' {
		flags.WriteRune(l.ch)
		l.readChar()
	}

	// Format: pattern/replacement/flags
	tok.Value = pattern.String() + "/" + replacement.String() + "/" + flags.String()
	return tok
}

func (l *Lexer) readMatchOp() Token {
	//tok := Token{Line: l.line, Column: l.column, File: l.file, Type: TokRegex}
	l.readChar() // skip 'm'
	return l.readRegex(l.ch)
}

// ============================================================
// Helper functions
// Yardımcı fonksiyonlar
// ============================================================

func isDigit(ch rune) bool {
	return ch >= '0' && ch <= '9'
}

func isHexDigit(ch rune) bool {
	return isDigit(ch) || (ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')
}

func isOctalDigit(ch rune) bool {
	return ch >= '0' && ch <= '7'
}

func isIdentStart(ch rune) bool {
	return ch == '_' || unicode.IsLetter(ch)
}

func isIdentChar(ch rune) bool {
	return ch == '_' || unicode.IsLetter(ch) || unicode.IsDigit(ch)
}

func isSpace(ch rune) bool {
	return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'
}
```

## File: ./pkg/lexer/lexer_test.go
```go
package lexer

import (
	"testing"
)

// ============================================================
// Basic Token Tests
// Temel Token Testleri
// ============================================================

// TestSingleCharTokens tests single character tokens.
// TestSingleCharTokens, tek karakterli tokenleri test eder.
func TestSingleCharTokens(t *testing.T) {
	input := `( ) [ ] { } ; , ? ~ \`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokLParen, "("},
		{TokRParen, ")"},
		{TokLBracket, "["},
		{TokRBracket, "]"},
		{TokLBrace, "{"},
		{TokRBrace, "}"},
		{TokSemi, ";"},
		{TokComma, ","},
		{TokQuestion, "?"},
		{TokBitNot, "~"},
		{TokBackslash, "\\"},
		{TokEOF, ""},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
		if tt.expectedValue != "" && tok.Value != tt.expectedValue {
			t.Errorf("tests[%d] - wrong value. expected=%q, got=%q",
				i, tt.expectedValue, tok.Value)
		}
	}
}

// TestNewlines tests newline handling.
// TestNewlines, satır sonu işlemeyi test eder.
func TestNewlines(t *testing.T) {
	input := "a\nb\nc"

	l := New(input)

	tok := l.NextToken() // a
	if tok.Line != 1 {
		t.Errorf("First token should be on line 1, got %d", tok.Line)
	}

	l.NextToken()       // newline
	tok = l.NextToken() // b
	if tok.Line != 2 {
		t.Errorf("Second token should be on line 2, got %d", tok.Line)
	}

	l.NextToken()       // newline
	tok = l.NextToken() // c
	if tok.Line != 3 {
		t.Errorf("Third token should be on line 3, got %d", tok.Line)
	}
}

// ============================================================
// Arithmetic Operator Tests
// Aritmetik Operatör Testleri
// ============================================================

// TestArithmeticOperators tests arithmetic operators.
// TestArithmeticOperators, aritmetik operatörleri test eder.
func TestArithmeticOperators(t *testing.T) {
	input := `+ - * / % **`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokPlus, "+"},
		{TokMinus, "-"},
		{TokStar, "*"},
		{TokSlash, "/"},
		{TokPercent, "%"},
		{TokStarStar, "**"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedValue {
			t.Errorf("tests[%d] - wrong value. expected=%q, got=%q",
				i, tt.expectedValue, tok.Value)
		}
	}
}

// TestIncrementDecrement tests ++ and --.
// TestIncrementDecrement, ++ ve -- test eder.
func TestIncrementDecrement(t *testing.T) {
	input := `++ --`

	l := New(input)

	tok := l.NextToken()
	if tok.Type != TokIncr || tok.Value != "++" {
		t.Errorf("Expected ++, got %v %q", tok.Type, tok.Value)
	}

	tok = l.NextToken()
	if tok.Type != TokDecr || tok.Value != "--" {
		t.Errorf("Expected --, got %v %q", tok.Type, tok.Value)
	}
}

// ============================================================
// Comparison Operator Tests
// Karşılaştırma Operatörü Testleri
// ============================================================

// TestNumericComparison tests numeric comparison operators.
// TestNumericComparison, sayısal karşılaştırma operatörlerini test eder.
func TestNumericComparison(t *testing.T) {
	input := `== != < <= > >= <=>`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokEq, "=="},
		{TokNe, "!="},
		{TokLt, "<"},
		{TokLe, "<="},
		{TokGt, ">"},
		{TokGe, ">="},
		{TokSpaceship, "<=>"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedValue {
			t.Errorf("tests[%d] - wrong value. expected=%q, got=%q",
				i, tt.expectedValue, tok.Value)
		}
	}
}

// TestStringComparison tests string comparison operators.
// TestStringComparison, string karşılaştırma operatörlerini test eder.
func TestStringComparison(t *testing.T) {
	input := `eq ne lt le gt ge cmp`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokStrEq, "eq"},
		{TokStrNe, "ne"},
		{TokStrLt, "lt"},
		{TokStrLe, "le"},
		{TokStrGt, "gt"},
		{TokStrGe, "ge"},
		{TokCmp, "cmp"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v (%q)",
				i, tt.expectedType, tok.Type, tok.Value)
		}
	}
}

// ============================================================
// Logical Operator Tests
// Mantıksal Operatör Testleri
// ============================================================

// TestLogicalOperators tests logical operators.
// TestLogicalOperators, mantıksal operatörleri test eder.
func TestLogicalOperators(t *testing.T) {
	input := `&& || ! // and or not`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokAnd, "&&"},
		{TokOr, "||"},
		{TokNot, "!"},
		{TokDefinedOr, "//"},
		{TokAndWord, "and"},
		{TokOrWord, "or"},
		{TokNotWord, "not"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
	}
}

// ============================================================
// Bitwise Operator Tests
// Bitsel Operatör Testleri
// ============================================================

// TestBitwiseOperators tests bitwise operators.
// TestBitwiseOperators, bitsel operatörleri test eder.
func TestBitwiseOperators(t *testing.T) {
	input := `<< >> ^ | ~`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokLeftShift, "<<"},
		{TokRightShift, ">>"},
		{TokBitXor, "^"},
		{TokBitOr, "|"},
		{TokBitNot, "~"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
	}
}

// ============================================================
// Assignment Operator Tests
// Atama Operatörü Testleri
// ============================================================

// TestAssignmentOperators tests assignment operators.
// TestAssignmentOperators, atama operatörlerini test eder.
func TestAssignmentOperators(t *testing.T) {
	input := `= += -= *= /= %= **= .= &&= ||= //= &= |= ^= <<= >>=`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokAssign, "="},
		{TokPlusEq, "+="},
		{TokMinusEq, "-="},
		{TokStarEq, "*="},
		{TokSlashEq, "/="},
		{TokPercentEq, "%="},
		{TokStarStarEq, "**="},
		{TokDotEq, ".="},
		{TokAndEq, "&&="},
		{TokOrEq, "||="},
		{TokDefinedOrEq, "//="},
		{TokBitAndEq, "&="},
		{TokBitOrEq, "|="},
		{TokBitXorEq, "^="},
		{TokLeftShiftEq, "<<="},
		{TokRightShiftEq, ">>="},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedValue {
			t.Errorf("tests[%d] - wrong value. expected=%q, got=%q",
				i, tt.expectedValue, tok.Value)
		}
	}
}

// ============================================================
// Other Operator Tests
// Diğer Operatör Testleri
// ============================================================

// TestMiscOperators tests miscellaneous operators.
// TestMiscOperators, çeşitli operatörleri test eder.
func TestMiscOperators(t *testing.T) {
	input := `. .. ... -> => =~ !~ :: :`

	tests := []struct {
		expectedType  TokenType
		expectedValue string
	}{
		{TokDot, "."},
		{TokRange, ".."},
		{TokRange3, "..."},
		{TokArrow, "->"},
		{TokFatArrow, "=>"},
		{TokMatch, "=~"},
		{TokNotMatch, "!~"},
		{TokDoubleColon, "::"},
		{TokColon, ":"},
	}

	l := New(input)
	for i, tt := range tests {
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("tests[%d] - wrong type. expected=%v, got=%v",
				i, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedValue {
			t.Errorf("tests[%d] - wrong value. expected=%q, got=%q",
				i, tt.expectedValue, tok.Value)
		}
	}
}

// ============================================================
// Number Tests
// Sayı Testleri
// ============================================================

// TestIntegers tests integer literals.
// TestIntegers, tamsayı literallerini test eder.
func TestIntegers(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"42", "42"},
		{"0", "0"},
		{"123456", "123456"},
		{"1_000_000", "1000000"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokInteger {
			t.Errorf("input %q - wrong type. expected=TokInteger, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestHexNumbers tests hexadecimal literals.
// TestHexNumbers, onaltılık literalleri test eder.
func TestHexNumbers(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"0x2A", "0x2A"},
		{"0xFF", "0xFF"},
		{"0xDEAD_BEEF", "0xDEADBEEF"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokInteger {
			t.Errorf("input %q - wrong type. expected=TokInteger, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestBinaryNumbers tests binary literals.
// TestBinaryNumbers, ikili literalleri test eder.
func TestBinaryNumbers(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"0b101010", "0b101010"},
		{"0b1111_0000", "0b11110000"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokInteger {
			t.Errorf("input %q - wrong type. expected=TokInteger, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestOctalNumbers tests octal literals.
// TestOctalNumbers, sekizlik literalleri test eder.
func TestOctalNumbers(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"0o52", "0o52"},
		{"0o755", "0o755"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokInteger {
			t.Errorf("input %q - wrong type. expected=TokInteger, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestFloats tests floating point literals.
// TestFloats, kayan nokta literallerini test eder.
func TestFloats(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"3.14", "3.14"},
		{"0.5", "0.5"},
		{"1.0", "1.0"},
		{"6.02e23", "6.02e23"},
		{"1.5E-10", "1.5E-10"},
		{"1e+5", "1e+5"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokFloat {
			t.Errorf("input %q - wrong type. expected=TokFloat, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// ============================================================
// String Tests
// String Testleri
// ============================================================

// TestDoubleQuotedStrings tests double-quoted strings.
// TestDoubleQuotedStrings, çift tırnaklı stringleri test eder.
func TestDoubleQuotedStrings(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`"hello"`, "hello"},
		{`"hello world"`, "hello world"},
		{`""`, ""},
		{`"line1\nline2"`, "line1\nline2"},
		{`"tab\there"`, "tab\there"},
		{`"quote\"here"`, `quote"here`},
		{`"back\\slash"`, `back\slash`},
		{`"dollar\$var"`, `dollar$var`},
		{`"at\@arr"`, `at@arr`},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokString {
			t.Errorf("input %q - wrong type. expected=TokString, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestSingleQuotedStrings tests single-quoted strings.
// TestSingleQuotedStrings, tek tırnaklı stringleri test eder.
func TestSingleQuotedStrings(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{`'hello'`, "hello"},
		{`'no\ninterpolation'`, `no\ninterpolation`},
		{`'it\'s'`, `it's`},
		{`'back\\slash'`, `back\slash`},
		{`''`, ""},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokRawString {
			t.Errorf("input %q - wrong type. expected=TokRawString, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expected {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expected, tok.Value)
		}
	}
}

// TestBacktickStrings tests backtick strings.
// TestBacktickStrings, backtick stringleri test eder.
func TestBacktickStrings(t *testing.T) {
	input := "`ls -la`"
	l := New(input)
	tok := l.NextToken()

	if tok.Type != TokString {
		t.Errorf("wrong type. expected=TokString, got=%v", tok.Type)
	}
	if tok.Value != "ls -la" {
		t.Errorf("wrong value. expected=%q, got=%q", "ls -la", tok.Value)
	}
}

// ============================================================
// Variable Tests
// Değişken Testleri
// ============================================================

// TestScalarVariables tests scalar variables.
// TestScalarVariables, skaler değişkenleri test eder.
func TestScalarVariables(t *testing.T) {
	tests := []struct {
		input        string
		expectedType TokenType
		expectedVal  string
	}{
		{"$x", TokScalar, "$x"},
		{"$foo", TokScalar, "$foo"},
		{"$foo_bar", TokScalar, "$foo_bar"},
		{"$Foo123", TokScalar, "$Foo123"},
		{"$_", TokSpecialVar, "$_"},
		{"$1", TokSpecialVar, "$1"},
		{"$123", TokSpecialVar, "$123"},
		{"${name}", TokScalar, "$name"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("input %q - wrong type. expected=%v, got=%v",
				tt.input, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// TestArrayVariables tests array variables.
// TestArrayVariables, dizi değişkenlerini test eder.
func TestArrayVariables(t *testing.T) {
	tests := []struct {
		input        string
		expectedType TokenType
		expectedVal  string
	}{
		{"@arr", TokArray, "@arr"},
		{"@foo_bar", TokArray, "@foo_bar"},
		{"@_", TokSpecialVar, "@_"},
		{"@{name}", TokArray, "@name"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("input %q - wrong type. expected=%v, got=%v",
				tt.input, tt.expectedType, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// TestHashVariables tests hash variables.
// TestHashVariables, hash değişkenlerini test eder.
func TestHashVariables(t *testing.T) {
	tests := []struct {
		input       string
		expectedVal string
	}{
		{"%hash", "%hash"},
		{"%foo_bar", "%foo_bar"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokHash {
			t.Errorf("input %q - wrong type. expected=TokHash, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// TestCodeVariables tests code references.
// TestCodeVariables, kod referanslarını test eder.
func TestCodeVariables(t *testing.T) {
	tests := []struct {
		input       string
		expectedVal string
	}{
		{"&sub", "&sub"},
		{"&foo_bar", "&foo_bar"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokCode {
			t.Errorf("input %q - wrong type. expected=TokCode, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// TestArrayLength tests $#array.
// TestArrayLength, $#array test eder.
func TestArrayLength(t *testing.T) {
	input := "$#arr"
	l := New(input)
	tok := l.NextToken()

	if tok.Type != TokArrayLen {
		t.Errorf("wrong type. expected=TokArrayLen, got=%v", tok.Type)
	}
	if tok.Value != "$#arr" {
		t.Errorf("wrong value. expected=%q, got=%q", "$#arr", tok.Value)
	}
}

// TestSpecialVariables tests special variables.
// TestSpecialVariables, özel değişkenleri test eder.
func TestSpecialVariables(t *testing.T) {
	tests := []struct {
		input       string
		expectedVal string
	}{
		{"$_", "$_"},
		{"$@", "$@"},
		{"$!", "$!"},
		{"$$", "$$"},
		{"$?", "$?"},
		{`$"`, `$"`},
		{"$/", "$/"},
		{`$\`, `$\`},
		{"$&", "$&"},
		{"$`", "$`"},
		{"$'", "$'"},
		{"$+", "$+"},
		{"$.", "$."},
		{"$|", "$|"},
		{"$-", "$-"},
		{"$^", "$^"},
		{"$~", "$~"},
		{"$=", "$="},
		{"$%", "$%"},
		{"$:", "$:"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokSpecialVar {
			t.Errorf("input %q - wrong type. expected=TokSpecialVar, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// TestPackageVariables tests package-qualified variables.
// TestPackageVariables, paket-nitelikli değişkenleri test eder.
func TestPackageVariables(t *testing.T) {
	tests := []struct {
		input       string
		expectedVal string
	}{
		{"$Foo::bar", "$Foo::bar"},
		{"@Foo::Bar::arr", "@Foo::Bar::arr"},
		{"%A::B::C::hash", "%A::B::C::hash"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// ============================================================
// Keyword Tests
// Anahtar Kelime Testleri
// ============================================================

// TestKeywords tests keyword recognition.
// TestKeywords, anahtar kelime tanımayı test eder.
func TestKeywords(t *testing.T) {
	tests := []struct {
		input        string
		expectedType TokenType
	}{
		{"if", TokIf},
		{"unless", TokUnless},
		{"else", TokElse},
		{"elsif", TokElsif},
		{"while", TokWhile},
		{"until", TokUntil},
		{"for", TokFor},
		{"foreach", TokForeach},
		{"do", TokDo},
		{"last", TokLast},
		{"next", TokNext},
		{"redo", TokRedo},
		{"return", TokReturn},
		{"goto", TokGoto},
		{"my", TokMy},
		{"our", TokOur},
		{"local", TokLocal},
		{"state", TokState},
		{"sub", TokSub},
		{"package", TokPackage},
		{"use", TokUse},
		{"no", TokNo},
		{"require", TokRequire},
		{"BEGIN", TokBEGIN},
		{"END", TokEND},
		{"eval", TokEval},
		{"die", TokDie},
		{"warn", TokWarn},
		{"print", TokPrint},
		{"say", TokSay},
		{"defined", TokDefined},
		{"undef", TokUndef},
		{"ref", TokRef},
		{"bless", TokBless},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != tt.expectedType {
			t.Errorf("input %q - wrong type. expected=%v, got=%v",
				tt.input, tt.expectedType, tok.Type)
		}
	}
}

// TestIdentifiers tests identifier recognition.
// TestIdentifiers, tanımlayıcı tanımayı test eder.
func TestIdentifiers(t *testing.T) {
	tests := []struct {
		input       string
		expectedVal string
	}{
		{"foo", "foo"},
		{"foo_bar", "foo_bar"},
		{"FooBar", "FooBar"},
		{"_private", "_private"},
		{"foo123", "foo123"},
		{"Foo::Bar", "Foo::Bar"},
		{"A::B::C::D", "A::B::C::D"},
	}

	for _, tt := range tests {
		l := New(tt.input)
		tok := l.NextToken()
		if tok.Type != TokIdent {
			t.Errorf("input %q - wrong type. expected=TokIdent, got=%v",
				tt.input, tok.Type)
		}
		if tok.Value != tt.expectedVal {
			t.Errorf("input %q - wrong value. expected=%q, got=%q",
				tt.input, tt.expectedVal, tok.Value)
		}
	}
}

// ============================================================
// Regex Tests
// Regex Testleri
// ============================================================

// TestRegex tests regex literals.
// TestRegex, regex literallerini test eder.
func TestRegex(t *testing.T) {
	// After =~ we expect regex
	input := `=~ /hello/`

	l := New(input)
	l.NextToken() // =~

	tok := l.NextToken()
	if tok.Type != TokRegex {
		t.Errorf("wrong type. expected=TokRegex, got=%v", tok.Type)
	}
	if tok.Value != "hello" {
		t.Errorf("wrong value. expected=%q, got=%q", "hello", tok.Value)
	}
}

// TestRegexWithModifiers tests regex with modifiers.
// TestRegexWithModifiers, değiştiricili regex test eder.
func TestRegexWithModifiers(t *testing.T) {
	input := `=~ /pattern/gimsxo`

	l := New(input)
	l.NextToken() // =~

	tok := l.NextToken()
	if tok.Type != TokRegex {
		t.Errorf("wrong type. expected=TokRegex, got=%v", tok.Type)
	}
	if tok.Value != "pattern/gimsxo" {
		t.Errorf("wrong value. expected=%q, got=%q", "pattern/gimsxo", tok.Value)
	}
}

// TestRegexWithEscapes tests regex with escaped delimiters.
// TestRegexWithEscapes, kaçışlı sınırlayıcılı regex test eder.
func TestRegexWithEscapes(t *testing.T) {
	input := `=~ /hello\/world/`

	l := New(input)
	l.NextToken() // =~

	tok := l.NextToken()
	if tok.Type != TokRegex {
		t.Errorf("wrong type. expected=TokRegex, got=%v", tok.Type)
	}
	if tok.Value != `hello\/world` {
		t.Errorf("wrong value. expected=%q, got=%q", `hello\/world`, tok.Value)
	}
}

// ============================================================
// Comment Tests
// Yorum Testleri
// ============================================================

// TestComments tests comment skipping.
// TestComments, yorum atlamayı test eder.
func TestComments(t *testing.T) {
	input := `# This is a comment
$x # inline comment
$y`

	l := New(input)

	// Comment is skipped, newline after comment returned
	// Yorum atlanır, yorumdan sonraki newline döndürülür
	tok := l.NextToken() // newline after first comment
	if tok.Type != TokNewline {
		t.Errorf("Expected newline after comment, got %v %q", tok.Type, tok.Value)
	}

	tok = l.NextToken() // $x
	if tok.Type != TokScalar || tok.Value != "$x" {
		t.Errorf("Expected $x, got %v %q", tok.Type, tok.Value)
	}

	tok = l.NextToken() // newline (inline comment skipped)
	if tok.Type != TokNewline {
		t.Errorf("Expected newline, got %v %q", tok.Type, tok.Value)
	}

	tok = l.NextToken() // $y
	if tok.Type != TokScalar || tok.Value != "$y" {
		t.Errorf("Expected $y, got %v %q", tok.Type, tok.Value)
	}
}

// ============================================================
// Complex Expression Tests
// Karmaşık İfade Testleri
// ============================================================

// TestSimpleExpression tests a simple expression.
// TestSimpleExpression, basit bir ifadeyi test eder.
func TestSimpleExpression(t *testing.T) {
	input := `$x + $y * 2`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokScalar, "$x"},
		{TokPlus, "+"},
		{TokScalar, "$y"},
		{TokStar, "*"},
		{TokInteger, "2"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestVariableDeclaration tests my $x = 10;
// TestVariableDeclaration, my $x = 10; test eder.
func TestVariableDeclaration(t *testing.T) {
	input := `my $x = 10;`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokMy, "my"},
		{TokScalar, "$x"},
		{TokAssign, "="},
		{TokInteger, "10"},
		{TokSemi, ";"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestSubroutineDeclaration tests sub foo { }
// TestSubroutineDeclaration, sub foo { } test eder.
func TestSubroutineDeclaration(t *testing.T) {
	input := `sub foo { return $x; }`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokSub, "sub"},
		{TokIdent, "foo"},
		{TokLBrace, "{"},
		{TokReturn, "return"},
		{TokScalar, "$x"},
		{TokSemi, ";"},
		{TokRBrace, "}"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestHashAccess tests hash access $hash{key}.
// TestHashAccess, hash erişimini test eder $hash{key}.
func TestHashAccess(t *testing.T) {
	input := `$hash{key}`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokScalar, "$hash"},
		{TokLBrace, "{"},
		{TokIdent, "key"},
		{TokRBrace, "}"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestArrayAccess tests array access $arr[0].
// TestArrayAccess, dizi erişimini test eder $arr[0].
func TestArrayAccess(t *testing.T) {
	input := `$arr[0]`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokScalar, "$arr"},
		{TokLBracket, "["},
		{TokInteger, "0"},
		{TokRBracket, "]"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestMethodCall tests method call $obj->method().
// TestMethodCall, method çağrısını test eder $obj->method().
func TestMethodCall(t *testing.T) {
	input := `$obj->method()`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokScalar, "$obj"},
		{TokArrow, "->"},
		{TokIdent, "method"},
		{TokLParen, "("},
		{TokRParen, ")"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// TestTernaryOperator tests ternary $x ? $y : $z.
// TestTernaryOperator, üçlü operatörü test eder $x ? $y : $z.
func TestTernaryOperator(t *testing.T) {
	input := `$x ? $y : $z`

	expected := []struct {
		typ TokenType
		val string
	}{
		{TokScalar, "$x"},
		{TokQuestion, "?"},
		{TokScalar, "$y"},
		{TokColon, ":"},
		{TokScalar, "$z"},
	}

	l := New(input)
	for i, exp := range expected {
		tok := l.NextToken()
		if tok.Type != exp.typ {
			t.Errorf("token[%d] - wrong type. expected=%v, got=%v",
				i, exp.typ, tok.Type)
		}
		if tok.Value != exp.val {
			t.Errorf("token[%d] - wrong value. expected=%q, got=%q",
				i, exp.val, tok.Value)
		}
	}
}

// ============================================================
// Line/Column Tracking Tests
// Satır/Sütun İzleme Testleri
// ============================================================

// TestLineColumn tests line and column tracking.
// TestLineColumn, satır ve sütun izlemeyi test eder.
func TestLineColumn(t *testing.T) {
	input := "a b\nc d"

	l := New(input)

	tok := l.NextToken() // a
	if tok.Line != 1 || tok.Column != 1 {
		t.Errorf("'a' should be at 1:1, got %d:%d", tok.Line, tok.Column)
	}

	tok = l.NextToken() // b
	if tok.Line != 1 || tok.Column != 3 {
		t.Errorf("'b' should be at 1:3, got %d:%d", tok.Line, tok.Column)
	}

	tok = l.NextToken() // newline
	tok = l.NextToken() // c
	if tok.Line != 2 || tok.Column != 1 {
		t.Errorf("'c' should be at 2:1, got %d:%d", tok.Line, tok.Column)
	}
}

// TestFilename tests filename in tokens.
// TestFilename, tokenlerdeki dosya adını test eder.
func TestFilename(t *testing.T) {
	l := NewFile("$x", "test.pl")
	tok := l.NextToken()

	if tok.File != "test.pl" {
		t.Errorf("File should be 'test.pl', got %q", tok.File)
	}
}

// ============================================================
// Edge Cases
// Sınır Durumları
// ============================================================

// TestEmptyInput tests empty input.
// TestEmptyInput, boş girdiyi test eder.
func TestEmptyInput(t *testing.T) {
	l := New("")
	tok := l.NextToken()

	if tok.Type != TokEOF {
		t.Errorf("Empty input should return EOF, got %v", tok.Type)
	}
}

// TestWhitespaceOnly tests whitespace-only input.
// TestWhitespaceOnly, sadece boşluk içeren girdiyi test eder.
func TestWhitespaceOnly(t *testing.T) {
	l := New("   \t\t   ")
	tok := l.NextToken()

	if tok.Type != TokEOF {
		t.Errorf("Whitespace-only should return EOF, got %v", tok.Type)
	}
}

// TestUnexpectedCharacter tests unexpected character.
// TestUnexpectedCharacter, beklenmeyen karakteri test eder.
func TestUnexpectedCharacter(t *testing.T) {
	l := New("@") // @ without identifier is error
	tok := l.NextToken()

	if tok.Type != TokError {
		t.Errorf("Expected TokError, got %v", tok.Type)
	}
}

// TestTokenString tests Token.String() method.
// TestTokenString, Token.String() metodunu test eder.
func TestTokenString(t *testing.T) {
	tok := Token{Type: TokPlus, Value: "+"}
	if tok.String() != "+" {
		t.Errorf("String() should return '+', got %q", tok.String())
	}

	tok = Token{Type: TokEOF}
	if tok.String() != "EOF" {
		t.Errorf("String() for EOF should return 'EOF', got %q", tok.String())
	}
}

// TestLookupKeyword tests LookupKeyword function.
// TestLookupKeyword, LookupKeyword fonksiyonunu test eder.
func TestLookupKeyword(t *testing.T) {
	if LookupKeyword("if") != TokIf {
		t.Error("'if' should be TokIf")
	}
	if LookupKeyword("foo") != TokIdent {
		t.Error("'foo' should be TokIdent")
	}
}
```

## File: ./pkg/lexer/token.go
```go
// Package lexer implements Perl tokenization.
// Paket lexer, Perl tokenizasyonunu uygular.
package lexer

// TokenType represents the type of a token.
// TokenType, bir tokenin türünü temsil eder.
type TokenType int

const (
	// Special
	TokEOF TokenType = iota
	TokError
	TokNewline

	// Literals
	TokInteger   // 42, 0x2A, 0b101010, 0o52
	TokFloat     // 3.14, 6.02e23
	TokString    // 'single', "double", q(), qq()
	TokRawString // Raw string (no interpolation)
	TokRegex     // /pattern/, m//, qr//
	TokHeredoc   // <<EOF
	TokVersion   // v5.36, 5.036

	// Identifiers and keywords
	TokIdent      // identifier
	TokPackageRef // Package::Name
	TokLabel      // LABEL:

	// Variables
	TokScalar   // $var
	TokArray    // @arr
	TokHash     // %hash
	TokCode     // &sub
	TokGlob     // *glob
	TokArrayLen // $#arr

	// Special variables
	TokSpecialVar // $_, $@, $!, $$, etc.

	// Operators - Arithmetic
	TokPlus     // +
	TokMinus    // -
	TokStar     // *
	TokSlash    // /
	TokPercent  // %
	TokStarStar // **

	// Operators - String
	TokDot // .
	TokX   // x (string repeat)

	// Operators - Comparison (numeric)
	TokEq        // ==
	TokNe        // !=
	TokLt        //
	TokLe        // <=
	TokGt        // >
	TokGe        // >=
	TokSpaceship // <=>

	// Operators - Comparison (string)
	TokStrEq // eq
	TokStrNe // ne
	TokStrLt // lt
	TokStrLe // le
	TokStrGt // gt
	TokStrGe // ge
	TokCmp   // cmp

	// Operators - Logical
	TokAnd       // &&
	TokOr        // ||
	TokNot       // !
	TokAndWord   // and
	TokOrWord    // or
	TokNotWord   // not
	TokDefinedOr // //

	// Operators - Bitwise
	TokBitAnd     // &
	TokBitOr      // |
	TokBitXor     // ^
	TokBitNot     // ~
	TokLeftShift  //
	TokRightShift // >>

	// Operators - Assignment
	TokAssign       // =
	TokPlusEq       // +=
	TokMinusEq      // -=
	TokStarEq       // *=
	TokSlashEq      // /=
	TokPercentEq    // %=
	TokStarStarEq   // **=
	TokDotEq        // .=
	TokXEq          // x=
	TokAndEq        // &&=
	TokOrEq         // ||=
	TokDefinedOrEq  // //=
	TokBitAndEq     // &=
	TokBitOrEq      // |=
	TokBitXorEq     // ^=
	TokLeftShiftEq  // <<=
	TokRightShiftEq // >>=

	// Operators - Increment/Decrement
	TokIncr // ++
	TokDecr // --

	// Operators - Range
	TokRange  // ..
	TokRange3 // ...

	// Operators - Misc
	TokArrow       // ->
	TokFatArrow    // =>
	TokQuestion    // ?
	TokColon       // :
	TokDoubleColon // ::
	TokBackslash   // \
	TokMatch       // =~
	TokNotMatch    // !~
	TokComma       // ,

	// Brackets
	TokLParen   // (
	TokRParen   // )
	TokLBracket // [
	TokRBracket // ]
	TokLBrace   // {
	TokRBrace   // }

	// Delimiters
	TokSemi // ;

	// Keywords - Control flow
	TokIf
	TokUnless
	TokElse
	TokElsif
	TokWhile
	TokUntil
	TokFor
	TokForeach
	TokDo
	TokLast
	TokNext
	TokRedo
	TokReturn
	TokGoto

	// Keywords - Declarations
	TokMy
	TokOur
	TokLocal
	TokState
	TokSub
	TokPackage
	TokUse
	TokNo
	TokRequire
	TokBEGIN
	TokEND
	TokCHECK
	TokINIT
	TokUNITCHECK

	// Keywords - Misc
	TokQw // qw()
	TokEval
	TokDie
	TokWarn
	TokPrint
	TokSay
	TokOpen
	TokClose
	TokRead
	TokDiamond  // <>
	TokReadLine // <$fh> or <FH>
	TokWrite
	TokDefined
	TokUndef
	TokRef
	TokBless
	TokTie
	TokUntie
	TokTied
	TokWantarray
	TokCaller

	// scalar (keyword, not sigil)
	// Özel
	TokScalarKw
	TokGiven
	TokWhen
	TokDefault

	// Array/Hash functions
	TokShift
	TokUnshift
	TokPop
	TokPush
	TokSplice
	TokKeys
	TokValues
	TokEach
	TokExists
	TokDelete
	TokSort
	TokReverse
	TokMap
	TokGrep
	TokJoin
	TokSplit

	// String functions
	TokLength
	TokSubstr
	TokIndex
	TokRindex
	TokLc
	TokUc
	TokLcfirst
	TokUcfirst
	TokChomp
	TokChop
	TokChr
	TokOrd
	TokHex
	TokOct
	TokPack
	TokUnpack
	TokSprintf

	// Numeric functions
	TokAbs
	TokInt
	TokSqrt
	TokRand
	TokSrand
	TokSin
	TokCos
	TokAtan2
	TokExp
	TokLog

	// Misc functions
	TokLocaltime
	TokGmtime
	TokTime
	TokSleep
	TokExit
	TokSystem
	TokExec
	TokFork
	TokWait
	TokKill

	TokSubst // s/pattern/replacement/
)

// Token represents a lexical token.
// Token, bir leksikal tokeni temsil eder.
type Token struct {
	Type   TokenType
	Value  string // Literal value / Literal değer
	Line   int    // Source line (1-indexed) / Kaynak satır
	Column int    // Source column (1-indexed) / Kaynak sütun
	File   string // Source filename / Kaynak dosya adı
}

// String returns a string representation of the token.
// String, tokenin string temsilini döndürür.
func (t Token) String() string {
	if t.Value != "" {
		return t.Value
	}
	return tokenNames[t.Type]
}

// tokenNames maps token types to names.
// tokenNames, token türlerini isimlere eşler.
var tokenNames = map[TokenType]string{
	TokEOF:       "EOF",
	TokError:     "ERROR",
	TokNewline:   "NEWLINE",
	TokInteger:   "INTEGER",
	TokFloat:     "FLOAT",
	TokString:    "STRING",
	TokRawString: "RAWSTRING",
	TokRegex:     "REGEX",
	TokHeredoc:   "HEREDOC",
	TokIdent:     "IDENT",
	TokScalar:    "SCALAR",
	TokArray:     "ARRAY",
	TokHash:      "HASH",
	TokCode:      "CODE",
	TokGlob:      "GLOB",
	TokPlus:      "+",
	TokMinus:     "-",
	TokStar:      "*",
	TokSlash:     "/",
	TokAssign:    "=",
	TokSemi:      ";",
	TokLParen:    "(",
	TokRParen:    ")",
	TokLBrace:    "{",
	TokRBrace:    "}",
	TokLBracket:  "[",
	TokRBracket:  "]",
	TokIf:        "if",
	TokElse:      "else",
	TokWhile:     "while",
	TokFor:       "for",
	TokForeach:   "foreach",
	TokMy:        "my",
	TokSub:       "sub",
	TokPackage:   "package",
	TokUse:       "use",
	TokReturn:    "return",
}

// keywords maps keyword strings to token types.
// keywords, anahtar kelime stringlerini token türlerine eşler.
var keywords = map[string]TokenType{
	// Control flow
	"if":      TokIf,
	"unless":  TokUnless,
	"else":    TokElse,
	"elsif":   TokElsif,
	"while":   TokWhile,
	"until":   TokUntil,
	"for":     TokFor,
	"foreach": TokForeach,
	"do":      TokDo,
	"last":    TokLast,
	"next":    TokNext,
	"redo":    TokRedo,
	"return":  TokReturn,
	"goto":    TokGoto,
	"given":   TokGiven,
	"when":    TokWhen,
	"default": TokDefault,

	// Declarations
	"my":        TokMy,
	"our":       TokOur,
	"local":     TokLocal,
	"state":     TokState,
	"sub":       TokSub,
	"package":   TokPackage,
	"use":       TokUse,
	"no":        TokNo,
	"require":   TokRequire,
	"BEGIN":     TokBEGIN,
	"END":       TokEND,
	"CHECK":     TokCHECK,
	"INIT":      TokINIT,
	"UNITCHECK": TokUNITCHECK,

	// String comparison operators
	"eq":  TokStrEq,
	"ne":  TokStrNe,
	"lt":  TokStrLt,
	"le":  TokStrLe,
	"gt":  TokStrGt,
	"ge":  TokStrGe,
	"cmp": TokCmp,

	// Logical operators (word form)
	"and": TokAndWord,
	"or":  TokOrWord,
	"not": TokNotWord,

	// String repeat
	"x": TokX,

	// Misc keywords
	"qw":        TokQw,
	"eval":      TokEval,
	"die":       TokDie,
	"warn":      TokWarn,
	"print":     TokPrint,
	"say":       TokSay,
	"open":      TokOpen,
	"close":     TokClose,
	"read":      TokRead,
	"write":     TokWrite,
	"defined":   TokDefined,
	"undef":     TokUndef,
	"ref":       TokRef,
	"bless":     TokBless,
	"tie":       TokTie,
	"untie":     TokUntie,
	"tied":      TokTied,
	"wantarray": TokWantarray,
	"caller":    TokCaller,
	"scalar":    TokScalarKw,

	// Array/Hash functions
	"shift":   TokShift,
	"unshift": TokUnshift,
	"pop":     TokPop,
	"push":    TokPush,
	"splice":  TokSplice,
	"keys":    TokKeys,
	"values":  TokValues,
	"each":    TokEach,
	"exists":  TokExists,
	"delete":  TokDelete,
	"sort":    TokSort,
	"reverse": TokReverse,
	"map":     TokMap,
	"grep":    TokGrep,
	"join":    TokJoin,
	"split":   TokSplit,

	// String functions
	"length":  TokLength,
	"substr":  TokSubstr,
	"index":   TokIndex,
	"rindex":  TokRindex,
	"lc":      TokLc,
	"uc":      TokUc,
	"lcfirst": TokLcfirst,
	"ucfirst": TokUcfirst,
	"chomp":   TokChomp,
	"chop":    TokChop,
	"chr":     TokChr,
	"ord":     TokOrd,
	"hex":     TokHex,
	"oct":     TokOct,
	"pack":    TokPack,
	"unpack":  TokUnpack,
	"sprintf": TokSprintf,

	// Numeric functions
	"abs":   TokAbs,
	"int":   TokInt,
	"sqrt":  TokSqrt,
	"rand":  TokRand,
	"srand": TokSrand,
	"sin":   TokSin,
	"cos":   TokCos,
	"atan2": TokAtan2,
	"exp":   TokExp,
	"log":   TokLog,

	// Misc functions
	"localtime": TokLocaltime,
	"gmtime":    TokGmtime,
	"time":      TokTime,
	"sleep":     TokSleep,
	"exit":      TokExit,
	"system":    TokSystem,
	"exec":      TokExec,
	"fork":      TokFork,
	"wait":      TokWait,
	"kill":      TokKill,
}

// LookupKeyword returns the token type for an identifier.
// If not a keyword, returns TokIdent.
//
// LookupKeyword, bir tanımlayıcı için token türünü döndürür.
// Anahtar kelime değilse, TokIdent döndürür.
func LookupKeyword(ident string) TokenType {
	if tok, ok := keywords[ident]; ok {
		return tok
	}
	return TokIdent
}
```

## File: ./pkg/parser/parser.go
```go
package parser

// Package parser implements Perl parsing using Pratt parsing.
// Paket parser, Pratt ayrıştırma kullanarak Perl ayrıştırmasını uygular.

import (
	"fmt"
	"strconv"
	"strings"

	"perlc/pkg/ast"
	"perlc/pkg/lexer"
)

// Precedence levels for operators.
// Operatörler için öncelik seviyeleri.
const (
	_ int = iota
	LOWEST
	COMMA          // ,
	ASSIGN         // = += -= etc.
	TERNARY        // ?:
	OR             // || or //
	AND            // &&
	BITOR          // |
	BITXOR         // ^
	BITAND         // &
	EQUALITY       // == != eq ne
	COMPARISON     // < > <= >= lt gt le ge <=>
	SHIFT          // << >>
	ADDITIVE       // + - .
	MULTIPLICATIVE // * / % x
	UNARY          // ! - ~ not \
	POWER          // **
	POSTFIX        // ++ --
	ARROW          // ->
	CALL           // ()
	INDEX          // [] {}
)

// precedences maps token types to precedence.
// precedences, token türlerini önceliğe eşler.
var precedences = map[lexer.TokenType]int{
	lexer.TokComma:       COMMA,
	lexer.TokFatArrow:    COMMA,
	lexer.TokAssign:      ASSIGN,
	lexer.TokPlusEq:      ASSIGN,
	lexer.TokMinusEq:     ASSIGN,
	lexer.TokStarEq:      ASSIGN,
	lexer.TokSlashEq:     ASSIGN,
	lexer.TokPercentEq:   ASSIGN,
	lexer.TokStarStarEq:  ASSIGN,
	lexer.TokDotEq:       ASSIGN,
	lexer.TokAndEq:       ASSIGN,
	lexer.TokOrEq:        ASSIGN,
	lexer.TokDefinedOrEq: ASSIGN,
	lexer.TokQuestion:    TERNARY,
	lexer.TokOr:          OR,
	lexer.TokDefinedOr:   OR,
	lexer.TokOrWord:      OR,
	lexer.TokAnd:         AND,
	lexer.TokAndWord:     AND,
	lexer.TokBitOr:       BITOR,
	lexer.TokBitXor:      BITXOR,
	lexer.TokBitAnd:      BITAND,
	lexer.TokEq:          EQUALITY,
	lexer.TokNe:          EQUALITY,
	lexer.TokStrEq:       EQUALITY,
	lexer.TokStrNe:       EQUALITY,
	lexer.TokLt:          COMPARISON,
	lexer.TokLe:          COMPARISON,
	lexer.TokGt:          COMPARISON,
	lexer.TokGe:          COMPARISON,
	lexer.TokStrLt:       COMPARISON,
	lexer.TokStrLe:       COMPARISON,
	lexer.TokStrGt:       COMPARISON,
	lexer.TokStrGe:       COMPARISON,
	lexer.TokSpaceship:   COMPARISON,
	lexer.TokCmp:         COMPARISON,
	lexer.TokLeftShift:   SHIFT,
	lexer.TokRightShift:  SHIFT,
	lexer.TokPlus:        ADDITIVE,
	lexer.TokMinus:       ADDITIVE,
	lexer.TokDot:         ADDITIVE,
	lexer.TokStar:        MULTIPLICATIVE,
	lexer.TokSlash:       MULTIPLICATIVE,
	lexer.TokPercent:     MULTIPLICATIVE,
	lexer.TokX:           MULTIPLICATIVE,
	lexer.TokStarStar:    POWER,
	lexer.TokIncr:        POSTFIX,
	lexer.TokDecr:        POSTFIX,
	lexer.TokArrow:       ARROW,
	lexer.TokLParen:      CALL,
	lexer.TokLBracket:    INDEX,
	lexer.TokLBrace:      INDEX,
	lexer.TokRange:       COMPARISON,
	lexer.TokRange3:      COMPARISON,
	lexer.TokMatch:       COMPARISON,
	lexer.TokNotMatch:    COMPARISON,
}

type (
	prefixParseFn func() ast.Expression
	infixParseFn  func(ast.Expression) ast.Expression
)

// Parser parses Perl source code into an AST.
// Parser, Perl kaynak kodunu AST'ye ayrıştırır.
type Parser struct {
	l      *lexer.Lexer
	errors []string

	curToken  lexer.Token
	peekToken lexer.Token

	prefixParseFns map[lexer.TokenType]prefixParseFn
	infixParseFns  map[lexer.TokenType]infixParseFn
}

// New creates a new parser.
// New, yeni bir ayrıştırıcı oluşturur.
func New(l *lexer.Lexer) *Parser {
	p := &Parser{
		l:      l,
		errors: []string{},
	}

	p.prefixParseFns = make(map[lexer.TokenType]prefixParseFn)
	p.infixParseFns = make(map[lexer.TokenType]infixParseFn)

	// Register prefix parsers
	// Önek ayrıştırıcıları kaydet
	p.registerPrefix(lexer.TokInteger, p.parseIntegerLiteral)
	p.registerPrefix(lexer.TokFloat, p.parseFloatLiteral)
	p.registerPrefix(lexer.TokString, p.parseStringLiteral)
	p.registerPrefix(lexer.TokRawString, p.parseRawStringLiteral)
	p.registerPrefix(lexer.TokScalar, p.parseScalarVar)
	p.registerPrefix(lexer.TokArray, p.parseArrayVar)
	p.registerPrefix(lexer.TokHash, p.parseHashVar)
	p.registerPrefix(lexer.TokCode, p.parseCodeVar)
	p.registerPrefix(lexer.TokArrayLen, p.parseArrayLengthVar)
	p.registerPrefix(lexer.TokSpecialVar, p.parseSpecialVar)
	p.registerPrefix(lexer.TokIdent, p.parseIdentifier)
	p.registerPrefix(lexer.TokUndef, p.parseUndef)
	p.registerPrefix(lexer.TokLParen, p.parseGroupedExpression)
	p.registerPrefix(lexer.TokLBracket, p.parseArrayLiteral)
	p.registerPrefix(lexer.TokLBrace, p.parseHashLiteral)
	p.registerPrefix(lexer.TokBackslash, p.parseRefExpr)
	p.registerPrefix(lexer.TokRegex, p.parseRegexLiteral)
	p.registerPrefix(lexer.TokSub, p.parseAnonSub)

	// Prefix operators
	// Önek operatörleri
	p.registerPrefix(lexer.TokMinus, p.parsePrefixExpression)
	p.registerPrefix(lexer.TokNot, p.parsePrefixExpression)
	p.registerPrefix(lexer.TokBitNot, p.parsePrefixExpression)
	p.registerPrefix(lexer.TokNotWord, p.parsePrefixExpression)
	p.registerPrefix(lexer.TokIncr, p.parsePrefixExpression)
	p.registerPrefix(lexer.TokDecr, p.parsePrefixExpression)

	// Register infix parsers
	// Ara ek ayrıştırıcıları kaydet
	p.registerInfix(lexer.TokPlus, p.parseInfixExpression)
	p.registerInfix(lexer.TokMinus, p.parseInfixExpression)
	p.registerInfix(lexer.TokStar, p.parseInfixExpression)
	p.registerInfix(lexer.TokSlash, p.parseInfixExpression)
	p.registerInfix(lexer.TokPercent, p.parseInfixExpression)
	p.registerInfix(lexer.TokStarStar, p.parseInfixExpression)
	p.registerInfix(lexer.TokDot, p.parseInfixExpression)
	p.registerInfix(lexer.TokX, p.parseInfixExpression)
	p.registerInfix(lexer.TokEq, p.parseInfixExpression)
	p.registerInfix(lexer.TokNe, p.parseInfixExpression)
	p.registerInfix(lexer.TokLt, p.parseInfixExpression)
	p.registerInfix(lexer.TokLe, p.parseInfixExpression)
	p.registerInfix(lexer.TokGt, p.parseInfixExpression)
	p.registerInfix(lexer.TokGe, p.parseInfixExpression)
	p.registerInfix(lexer.TokSpaceship, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrEq, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrNe, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrLt, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrLe, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrGt, p.parseInfixExpression)
	p.registerInfix(lexer.TokStrGe, p.parseInfixExpression)
	p.registerInfix(lexer.TokCmp, p.parseInfixExpression)
	p.registerInfix(lexer.TokAnd, p.parseInfixExpression)
	p.registerInfix(lexer.TokOr, p.parseInfixExpression)
	p.registerInfix(lexer.TokDefinedOr, p.parseInfixExpression)
	p.registerInfix(lexer.TokAndWord, p.parseInfixExpression)
	p.registerInfix(lexer.TokOrWord, p.parseInfixExpression)
	p.registerInfix(lexer.TokBitAnd, p.parseInfixExpression)
	p.registerInfix(lexer.TokBitOr, p.parseInfixExpression)
	p.registerInfix(lexer.TokBitXor, p.parseInfixExpression)
	p.registerInfix(lexer.TokLeftShift, p.parseInfixExpression)
	p.registerInfix(lexer.TokRightShift, p.parseInfixExpression)
	p.registerInfix(lexer.TokRange, p.parseRangeExpression)
	p.registerInfix(lexer.TokRange3, p.parseRangeExpression)

	// Assignment
	// Atama
	p.registerInfix(lexer.TokAssign, p.parseAssignExpression)
	p.registerInfix(lexer.TokPlusEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokMinusEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokStarEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokSlashEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokPercentEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokStarStarEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokDotEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokAndEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokOrEq, p.parseAssignExpression)
	p.registerInfix(lexer.TokDefinedOrEq, p.parseAssignExpression)

	// Special infix
	// Özel ara ek
	p.registerInfix(lexer.TokQuestion, p.parseTernaryExpression)
	p.registerInfix(lexer.TokLParen, p.parseCallExpression)
	p.registerInfix(lexer.TokLBracket, p.parseIndexExpression)
	p.registerInfix(lexer.TokLBrace, p.parseHashAccessExpression)
	p.registerInfix(lexer.TokArrow, p.parseArrowExpression)
	p.registerInfix(lexer.TokIncr, p.parsePostfixExpression)
	p.registerInfix(lexer.TokDecr, p.parsePostfixExpression)
	p.registerInfix(lexer.TokMatch, p.parseMatchExpression)
	p.registerInfix(lexer.TokNotMatch, p.parseMatchExpression)

	p.registerInfix(lexer.TokFatArrow, p.parseFatArrowExpression)
	p.registerPrefix(lexer.TokBless, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokShift, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPop, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPush, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPrint, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSay, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokDie, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokWarn, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokDefined, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokRef, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokScalarKw, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokKeys, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokValues, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokEach, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokExists, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokDelete, p.parseBuiltinCall)

	// Array/Hash builtins
	p.registerPrefix(lexer.TokShift, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokUnshift, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPop, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPush, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSplice, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokKeys, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokValues, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokEach, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokExists, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokDelete, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSort, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokReverse, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokMap, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokGrep, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokJoin, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSplit, p.parseBuiltinCall)

	// String builtins
	p.registerPrefix(lexer.TokLength, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSubstr, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokIndex, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokRindex, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokLc, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokUc, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokLcfirst, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokUcfirst, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokChomp, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokChop, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokChr, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokOrd, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokHex, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokOct, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokPack, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokUnpack, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSprintf, p.parseBuiltinCall)

	// Numeric builtins
	p.registerPrefix(lexer.TokAbs, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokInt, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSqrt, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokRand, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSrand, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSin, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokCos, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokAtan2, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokExp, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokLog, p.parseBuiltinCall)

	// Misc builtins
	p.registerPrefix(lexer.TokLocaltime, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokGmtime, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokTime, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSleep, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokExit, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokSystem, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokExec, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokFork, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokWait, p.parseBuiltinCall)
	p.registerPrefix(lexer.TokKill, p.parseBuiltinCall)

	p.registerPrefix(lexer.TokOpen, p.parseOpenExpr)
	p.registerPrefix(lexer.TokClose, p.parseCloseExpr)
	p.registerPrefix(lexer.TokDiamond, p.parseReadLineExpr)
	p.registerPrefix(lexer.TokReadLine, p.parseReadLineExpr)

	// Regex builtins
	// p.registerInfix(lexer.TokSubst, p.parseSubstExpression)

	// Read two tokens to initialize curToken and peekToken
	// curToken ve peekToken'ı başlatmak için iki token oku
	p.nextToken()
	p.nextToken()

	return p
}

var _ = (*Parser).parseForeachStyleFor
var _ = (*Parser).parseSubstExpression

func (p *Parser) registerPrefix(tokenType lexer.TokenType, fn prefixParseFn) {
	p.prefixParseFns[tokenType] = fn
}

func (p *Parser) registerInfix(tokenType lexer.TokenType, fn infixParseFn) {
	p.infixParseFns[tokenType] = fn
}

func (p *Parser) nextToken() {
	p.curToken = p.peekToken
	p.peekToken = p.l.NextToken()

	// Skip newlines in most contexts
	// Çoğu bağlamda satır sonlarını atla
	for p.peekToken.Type == lexer.TokNewline {
		p.peekToken = p.l.NextToken()
	}
}

// ============================================================
// Main Parse Function
// Ana Ayrıştırma Fonksiyonu
// ============================================================

// ParseProgram parses the entire program.
// ParseProgram, tüm programı ayrıştırır.
func (p *Parser) ParseProgram() *ast.Program {
	program := &ast.Program{}
	program.Statements = []ast.Statement{}

	for !p.curTokenIs(lexer.TokEOF) {
		stmt := p.parseStatement()
		if stmt != nil {
			program.Statements = append(program.Statements, stmt)
		}
		p.nextToken()
	}

	return program
}

// ============================================================
// Statement Parsing
// Deyim Ayrıştırma
// ============================================================

func (p *Parser) parseStatement() ast.Statement {

	switch p.curToken.Type {
	case lexer.TokMy, lexer.TokOur, lexer.TokLocal, lexer.TokState:
		return p.parseVarDecl()
	case lexer.TokSub:
		return p.parseSubDecl()
	case lexer.TokPackage:
		return p.parsePackageDecl()
	case lexer.TokUse:
		return p.parseUseDecl()
	case lexer.TokNo:
		return p.parseNoDecl()
	case lexer.TokRequire:
		return p.parseRequireDecl()
	case lexer.TokIf:
		return p.parseIfStmt()
	case lexer.TokUnless:
		return p.parseIfStmt() // Same parser, different flag
	case lexer.TokWhile:
		return p.parseWhileStmt()
	case lexer.TokUntil:
		return p.parseWhileStmt()
	case lexer.TokFor:
		return p.parseForStmt()
	case lexer.TokForeach:
		return p.parseForeachStmt()
	case lexer.TokLast:
		return p.parseLastStmt()
	case lexer.TokNext:
		return p.parseNextStmt()
	case lexer.TokRedo:
		return p.parseRedoStmt()
	case lexer.TokReturn:
		return p.parseReturnStmt()
	case lexer.TokLBrace:
		return p.parseBlockStmt()
	case lexer.TokBEGIN, lexer.TokEND, lexer.TokCHECK, lexer.TokINIT, lexer.TokUNITCHECK:
		return p.parseSpecialBlock()
	default:
		return p.parseExpressionStatement()
	}
}

func (p *Parser) parseExpressionStatement() ast.Statement {
	exprStmt := &ast.ExprStmt{Token: p.curToken}
	exprStmt.Expression = p.parseExpression(LOWEST)

	// Check for statement modifiers: expr if COND, expr unless COND
	if p.peekTokenIs(lexer.TokIf) {
		p.nextToken() // consume 'if'
		p.nextToken() // move to condition
		cond := p.parseExpression(LOWEST)
		ifStmt := &ast.IfStmt{
			Token:     p.curToken,
			Condition: cond,
			Then:      &ast.BlockStmt{Statements: []ast.Statement{exprStmt}},
		}
		if p.peekTokenIs(lexer.TokSemi) {
			p.nextToken()
		}
		return ifStmt
	}

	if p.peekTokenIs(lexer.TokUnless) {
		p.nextToken() // consume 'unless'
		p.nextToken() // move to condition
		cond := p.parseExpression(LOWEST)
		ifStmt := &ast.IfStmt{
			Token:     p.curToken,
			Condition: cond,
			Unless:    true,
			Then:      &ast.BlockStmt{Statements: []ast.Statement{exprStmt}},
		}
		if p.peekTokenIs(lexer.TokSemi) {
			p.nextToken()
		}
		return ifStmt
	}

	// Optional semicolon
	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return exprStmt
}

func (p *Parser) parseBlockStmt() *ast.BlockStmt {
	block := &ast.BlockStmt{Token: p.curToken}
	block.Statements = []ast.Statement{}

	p.nextToken() // skip {

	for !p.curTokenIs(lexer.TokRBrace) && !p.curTokenIs(lexer.TokEOF) {
		stmt := p.parseStatement()
		if stmt != nil {
			block.Statements = append(block.Statements, stmt)
		}
		p.nextToken()
	}

	return block
}

// ============================================================
// Expression Parsing (Pratt Parser)
// İfade Ayrıştırma (Pratt Ayrıştırıcı)
// ============================================================

func (p *Parser) parseExpression(precedence int) ast.Expression {

	prefix := p.prefixParseFns[p.curToken.Type]
	if prefix == nil {
		p.noPrefixParseFnError(p.curToken.Type)
		return nil
	}
	leftExp := prefix()

	for !p.peekTokenIs(lexer.TokSemi) && precedence < p.peekPrecedence() {
		infix := p.infixParseFns[p.peekToken.Type]
		if infix == nil {
			return leftExp
		}
		p.nextToken()
		leftExp = infix(leftExp)
	}

	return leftExp
}

// ============================================================
// Literal Parsers
// Literal Ayrıştırıcıları
// ============================================================

func (p *Parser) parseIntegerLiteral() ast.Expression {
	lit := &ast.IntegerLiteral{Token: p.curToken}

	value, err := strconv.ParseInt(p.curToken.Value, 0, 64)
	if err != nil {
		msg := fmt.Sprintf("line %d: could not parse %q as integer",
			p.curToken.Line, p.curToken.Value)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}

func (p *Parser) parseFloatLiteral() ast.Expression {
	lit := &ast.FloatLiteral{Token: p.curToken}

	value, err := strconv.ParseFloat(p.curToken.Value, 64)
	if err != nil {
		msg := fmt.Sprintf("line %d: could not parse %q as float",
			p.curToken.Line, p.curToken.Value)
		p.errors = append(p.errors, msg)
		return nil
	}
	lit.Value = value
	return lit
}

func (p *Parser) parseStringLiteral() ast.Expression {
	return &ast.StringLiteral{
		Token:        p.curToken,
		Value:        p.curToken.Value,
		Interpolated: true,
	}
}

func (p *Parser) parseRawStringLiteral() ast.Expression {
	return &ast.StringLiteral{
		Token:        p.curToken,
		Value:        p.curToken.Value,
		Interpolated: false,
	}
}

func (p *Parser) parseRegexLiteral() ast.Expression {
	lit := &ast.RegexLiteral{Token: p.curToken}

	// Value may contain pattern/flags
	// Değer pattern/flags içerebilir
	parts := strings.SplitN(p.curToken.Value, "/", 2)
	lit.Pattern = parts[0]
	if len(parts) > 1 {
		lit.Flags = parts[1]
	}

	return lit
}

func (p *Parser) parseUndef() ast.Expression {
	return &ast.UndefLiteral{Token: p.curToken}
}

// ============================================================
// Variable Parsers
// Değişken Ayrıştırıcıları
// ============================================================

func (p *Parser) parseScalarVar() ast.Expression {
	name := p.curToken.Value
	name = strings.TrimPrefix(name, "$")

	// Check for scalar dereference: $$ref
	if strings.HasPrefix(name, "$") {
		// This is $$ref - dereference
		innerName := strings.TrimPrefix(name, "$")
		innerVar := &ast.ScalarVar{Token: p.curToken, Name: innerName}
		return &ast.DerefExpr{Token: p.curToken, Sigil: "$", Value: innerVar}
	}

	// Check for array dereference: $@ref -> @$ref parsed differently
	// Check for hash dereference: $%ref -> %$ref parsed differently

	return &ast.ScalarVar{Token: p.curToken, Name: name}
}

func (p *Parser) parseArrayVar() ast.Expression {
	name := p.curToken.Value
	name = strings.TrimPrefix(name, "@")
	return &ast.ArrayVar{Token: p.curToken, Name: name}
}

func (p *Parser) parseHashVar() ast.Expression {
	name := p.curToken.Value
	name = strings.TrimPrefix(name, "%")
	return &ast.HashVar{Token: p.curToken, Name: name}
}

func (p *Parser) parseCodeVar() ast.Expression {
	name := p.curToken.Value
	name = strings.TrimPrefix(name, "&")
	return &ast.CodeVar{Token: p.curToken, Name: name}
}

func (p *Parser) parseArrayLengthVar() ast.Expression {
	name := p.curToken.Value
	name = strings.TrimPrefix(name, "$#")
	return &ast.ArrayLengthVar{Token: p.curToken, Name: name}
}

func (p *Parser) parseSpecialVar() ast.Expression {
	return &ast.SpecialVar{Token: p.curToken, Name: p.curToken.Value}
}

func (p *Parser) parseIdentifier() ast.Expression {
	return &ast.Identifier{Token: p.curToken, Value: p.curToken.Value}
}

// ============================================================
// Operator Parsers
// Operatör Ayrıştırıcıları
// ============================================================

func (p *Parser) parsePrefixExpression() ast.Expression {
	// Специальная обработка для \ (создание ссылки)
	if p.curToken.Value == "\\" {
		tok := p.curToken
		p.nextToken()
		right := p.parseExpression(UNARY)
		return &ast.RefExpr{
			Token: tok,
			Value: right,
		}
	}

	expression := &ast.PrefixExpr{
		Token:    p.curToken,
		Operator: p.curToken.Value,
	}
	p.nextToken()
	expression.Right = p.parseExpression(UNARY)
	return expression
}

func (p *Parser) parseInfixExpression(left ast.Expression) ast.Expression {
	expression := &ast.InfixExpr{
		Token:    p.curToken,
		Operator: p.curToken.Value,
		Left:     left,
	}
	precedence := p.curPrecedence()

	// Right associative for **
	// ** için sağdan ilişkili
	if p.curToken.Type == lexer.TokStarStar {
		precedence--
	}

	p.nextToken()
	expression.Right = p.parseExpression(precedence)
	return expression
}

func (p *Parser) parsePostfixExpression(left ast.Expression) ast.Expression {
	return &ast.PostfixExpr{
		Token:    p.curToken,
		Left:     left,
		Operator: p.curToken.Value,
	}
}

func (p *Parser) parseAssignExpression(left ast.Expression) ast.Expression {
	expression := &ast.AssignExpr{
		Token:    p.curToken,
		Operator: p.curToken.Value,
		Left:     left,
	}
	p.nextToken()
	// Right associative
	expression.Right = p.parseExpression(ASSIGN - 1)
	return expression
}

func (p *Parser) parseTernaryExpression(condition ast.Expression) ast.Expression {
	expression := &ast.TernaryExpr{
		Token:     p.curToken,
		Condition: condition,
	}
	p.nextToken()
	expression.Then = p.parseExpression(LOWEST)

	if !p.expectPeek(lexer.TokColon) {
		return nil
	}
	p.nextToken()
	expression.Else = p.parseExpression(TERNARY - 1)
	return expression
}

func (p *Parser) parseRangeExpression(left ast.Expression) ast.Expression {
	expression := &ast.RangeExpr{
		Token:    p.curToken,
		Start:    left,
		ThreeDot: p.curToken.Type == lexer.TokRange3,
	}
	p.nextToken()
	expression.End = p.parseExpression(COMPARISON)
	return expression
}

// ============================================================
// Access Parsers
// Erişim Ayrıştırıcıları
// ============================================================

func (p *Parser) parseGroupedExpression() ast.Expression {
	startToken := p.curToken
	p.nextToken()

	// Empty parens
	if p.curTokenIs(lexer.TokRParen) {
		return &ast.ArrayExpr{Token: startToken, Elements: []ast.Expression{}}
	}

	// Check if this is a hash-like list with bareword keys: (x => 1, y => 2)
	// If current token is followed by =>, treat it as bareword key
	if p.peekTokenIs(lexer.TokFatArrow) {
		return p.parseHashLikeList(startToken)
	}

	exp := p.parseExpression(LOWEST)

	// Check for fat arrow - this means it's a hash-like list: (a => 1, b => 2)
	if p.curTokenIs(lexer.TokFatArrow) || p.peekTokenIs(lexer.TokFatArrow) {
		return p.parseHashLikeListWithFirst(startToken, exp)
	}

	// Check for list: (1, 2, 3)
	if p.peekTokenIs(lexer.TokComma) {
		elements := []ast.Expression{exp}
		for p.peekTokenIs(lexer.TokComma) {
			p.nextToken() // move to ,
			if p.peekTokenIs(lexer.TokRParen) {
				break // trailing comma
			}
			p.nextToken() // skip ,
			elements = append(elements, p.parseExpression(LOWEST))
		}
		if !p.expectPeek(lexer.TokRParen) {
			return nil
		}
		return &ast.ArrayExpr{Token: startToken, Elements: elements}
	}

	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}
	return exp
}

// parseHashLikeList parses (x => 1, y => 2) where first token is bareword
func (p *Parser) parseHashLikeList(startToken lexer.Token) ast.Expression {
	elements := []ast.Expression{}

	for !p.curTokenIs(lexer.TokRParen) && !p.curTokenIs(lexer.TokEOF) {
		// Current token is the key (bareword or expression)
		var key ast.Expression
		if p.peekTokenIs(lexer.TokFatArrow) {
			// Bareword key - treat current token value as string
			key = &ast.StringLiteral{Token: p.curToken, Value: p.curToken.Value}
		} else {
			key = p.parseExpression(COMMA)
		}
		elements = append(elements, key)

		if !p.peekTokenIs(lexer.TokFatArrow) {
			break
		}
		p.nextToken() // move to =>
		p.nextToken() // move to value
		elements = append(elements, p.parseExpression(COMMA))

		if p.peekTokenIs(lexer.TokComma) {
			p.nextToken() // move to ,
			if p.peekTokenIs(lexer.TokRParen) {
				break // trailing comma
			}
			p.nextToken() // move to next key
		}
	}

	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}
	return &ast.ArrayExpr{Token: startToken, Elements: elements}
}

// parseHashLikeListWithFirst continues parsing hash-like list when first element already parsed
func (p *Parser) parseHashLikeListWithFirst(startToken lexer.Token, firstKey ast.Expression) ast.Expression {
	elements := []ast.Expression{firstKey}

	// We're on or before =>
	if p.peekTokenIs(lexer.TokFatArrow) {
		p.nextToken() // move to =>
	}
	p.nextToken() // move to value
	elements = append(elements, p.parseExpression(COMMA))

	// More pairs
	for p.peekTokenIs(lexer.TokComma) {
		p.nextToken() // move to ,
		if p.peekTokenIs(lexer.TokRParen) {
			break // trailing comma
		}
		p.nextToken() // move to next key

		var key ast.Expression
		if p.peekTokenIs(lexer.TokFatArrow) {
			key = &ast.StringLiteral{Token: p.curToken, Value: p.curToken.Value}
		} else {
			key = p.parseExpression(COMMA)
		}
		elements = append(elements, key)

		if p.peekTokenIs(lexer.TokFatArrow) {
			p.nextToken() // move to =>
			p.nextToken() // move to value
			elements = append(elements, p.parseExpression(COMMA))
		}
	}

	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}
	return &ast.ArrayExpr{Token: startToken, Elements: elements}
}

func (p *Parser) parseIndexExpression(left ast.Expression) ast.Expression {
	exp := &ast.ArrayAccess{Token: p.curToken, Array: left}
	p.nextToken()
	exp.Index = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRBracket) {
		return nil
	}
	return exp
}

func (p *Parser) parseHashAccessExpression(left ast.Expression) ast.Expression {
	exp := &ast.HashAccess{Token: p.curToken, Hash: left}
	p.nextToken()
	exp.Key = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRBrace) {
		return nil
	}
	return exp
}

func (p *Parser) parseArrowExpression(left ast.Expression) ast.Expression {
	token := p.curToken
	p.nextToken()

	// Check what follows ->
	// -> sonrasını kontrol et
	switch p.curToken.Type {
	case lexer.TokLBracket:
		// ->[]
		p.nextToken()
		index := p.parseExpression(LOWEST)
		if !p.expectPeek(lexer.TokRBracket) {
			return nil
		}
		return &ast.ArrowAccess{
			Token: token,
			Left:  left,
			Right: &ast.ArrayAccess{Token: p.curToken, Index: index},
		}
	case lexer.TokLBrace:
		// ->{} - need special handling for autoquoting barewords
		p.nextToken()
		var key ast.Expression
		// If it's a bare identifier or keyword, treat it as a string
		if p.isBareword() {
			key = &ast.StringLiteral{
				Token:        p.curToken,
				Value:        p.curToken.Value,
				Interpolated: false,
			}
		} else {
			key = p.parseExpression(LOWEST)
		}
		if !p.expectPeek(lexer.TokRBrace) {
			return nil
		}
		return &ast.ArrowAccess{
			Token: token,
			Left:  left,
			Right: &ast.HashAccess{Token: p.curToken, Key: key},
		}
	case lexer.TokIdent:
		// ->method or ->method()
		method := p.curToken.Value
		if p.peekTokenIs(lexer.TokLParen) {
			p.nextToken()
			args := p.parseExpressionList(lexer.TokRParen)
			return &ast.MethodCall{
				Token:  token,
				Object: left,
				Method: method,
				Args:   args,
			}
		}
		return &ast.MethodCall{
			Token:  token,
			Object: left,
			Method: method,
			Args:   nil,
		}
	default:
		return &ast.ArrowAccess{Token: token, Left: left}
	}
}

func (p *Parser) parseCallExpression(function ast.Expression) ast.Expression {
	exp := &ast.CallExpr{Token: p.curToken, Function: function}
	exp.Args = p.parseExpressionList(lexer.TokRParen)
	return exp
}

func (p *Parser) parseExpressionList(end lexer.TokenType) []ast.Expression {

	list := []ast.Expression{}

	if p.peekTokenIs(end) {
		p.nextToken()
		return list
	}

	p.nextToken()
	list = append(list, p.parseExpression(LOWEST))

	for p.peekTokenIs(lexer.TokComma) {
		p.nextToken()
		p.nextToken()
		list = append(list, p.parseExpression(LOWEST))
	}

	if !p.expectPeek(end) {
		return nil
	}

	return list
}

func (p *Parser) parseMatchExpression(left ast.Expression) ast.Expression {
	matchTok := p.curToken
	negate := matchTok.Type == lexer.TokNotMatch
	p.nextToken()

	// Handle s/pattern/replacement/flags
	if p.curToken.Type == lexer.TokSubst {
		tok := p.curToken
		parts := strings.SplitN(tok.Value, "/", 3)
		pattern := ""
		replacement := ""
		flags := ""
		if len(parts) >= 1 {
			pattern = parts[0]
		}
		if len(parts) >= 2 {
			replacement = parts[1]
		}
		if len(parts) >= 3 {
			flags = parts[2]
		}

		return &ast.SubstExpr{
			Token:       tok,
			Target:      left,
			Pattern:     pattern,
			Replacement: replacement,
			Flags:       flags,
		}
	}

	// Handle /pattern/flags
	if p.curToken.Type == lexer.TokRegex {
		exp := &ast.MatchExpr{
			Token:  matchTok,
			Target: left,
			Negate: negate,
		}
		exp.Pattern = p.parseRegexLiteral().(*ast.RegexLiteral)
		return exp
	}

	return nil
}

// ============================================================
// Composite Literal Parsers
// Bileşik Literal Ayrıştırıcıları
// ============================================================

func (p *Parser) parseArrayLiteral() ast.Expression {
	array := &ast.ArrayExpr{Token: p.curToken}
	array.Elements = p.parseExpressionList(lexer.TokRBracket)
	return array
}

func (p *Parser) parseHashLiteral() ast.Expression {
	hash := &ast.HashExpr{Token: p.curToken}
	hash.Pairs = []*ast.HashPair{}

	if p.peekTokenIs(lexer.TokRBrace) {
		p.nextToken()
		return hash
	}

	p.nextToken() // move to first key
	pair := p.parseHashPair()
	if pair != nil {
		hash.Pairs = append(hash.Pairs, pair)
	}

	for p.peekTokenIs(lexer.TokComma) {
		p.nextToken() // move to comma
		if p.peekTokenIs(lexer.TokRBrace) {
			break // trailing comma
		}
		p.nextToken() // skip comma, move to next key
		pair := p.parseHashPair()
		if pair != nil {
			hash.Pairs = append(hash.Pairs, pair)
		}
	}

	if !p.expectPeek(lexer.TokRBrace) {
		return nil
	}

	return hash
}

func (p *Parser) parseHashPair() *ast.HashPair {
	// Check if current token is a bareword followed by =>
	// Treat word operators (x, eq, ne, etc.) as barewords in hash context
	if p.peekTokenIs(lexer.TokFatArrow) {
		// Current token is a bareword key
		key := &ast.StringLiteral{Token: p.curToken, Value: p.curToken.Value}
		p.nextToken() // move to =>
		p.nextToken() // move to value
		value := p.parseExpression(COMMA)
		return &ast.HashPair{Key: key, Value: value}
	}

	key := p.parseExpression(COMMA + 1) // Higher than comma to stop at =>

	// Expect =>
	if !p.expectPeek(lexer.TokFatArrow) {
		return nil
	}
	p.nextToken() // move to value
	value := p.parseExpression(COMMA)

	return &ast.HashPair{Key: key, Value: value}
}

func (p *Parser) ParseHashPair_old() *ast.HashPair {
	key := p.parseExpression(LOWEST)

	// Expect => or ,
	// => veya , bekle
	if p.peekTokenIs(lexer.TokFatArrow) {
		p.nextToken() // consume =>
		p.nextToken() // move to value
		value := p.parseExpression(LOWEST)
		return &ast.HashPair{Key: key, Value: value}
	}

	// Comma-separated pair (old style)
	if p.peekTokenIs(lexer.TokComma) {
		p.nextToken() // consume ,
		p.nextToken() // move to value
		value := p.parseExpression(LOWEST)
		return &ast.HashPair{Key: key, Value: value}
	}

	return &ast.HashPair{Key: key, Value: nil}
}

func (p *Parser) parseRefExpr() ast.Expression {
	exp := &ast.RefExpr{Token: p.curToken}
	p.nextToken()
	exp.Value = p.parseExpression(UNARY)
	return exp
}

func (p *Parser) parseAnonSub() ast.Expression {
	exp := &ast.AnonSubExpr{Token: p.curToken}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}

	exp.Body = p.parseBlockStmt()
	return exp
}

// ============================================================
// Declaration Parsers
// Bildirim Ayrıştırıcıları
// ============================================================

func (p *Parser) parseVarDecl() ast.Statement {
	decl := &ast.VarDecl{Token: p.curToken, Kind: p.curToken.Value}
	decl.Names = []ast.Expression{}

	p.nextToken() // skip my/our/local/state

	if p.curTokenIs(lexer.TokLParen) {
		// List declaration: my ($x, $y)
		decl.IsList = true
		decl.Names = p.parseExpressionList(lexer.TokRParen)
	} else {
		// Single variable: my $x
		decl.IsList = false
		decl.Names = append(decl.Names, p.parseExpression(ASSIGN))
	}

	// Optional initializer
	if p.peekTokenIs(lexer.TokAssign) {
		p.nextToken()
		p.nextToken()
		decl.Value = p.parseExpression(LOWEST)
	}

	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return decl
}

func (p *Parser) parseSubDecl() ast.Statement {
	decl := &ast.SubDecl{Token: p.curToken}

	if !p.expectPeek(lexer.TokIdent) {
		return nil
	}
	decl.Name = p.curToken.Value

	// Optional prototype
	// Opsiyonel prototip
	if p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		p.nextToken()
		// Read prototype until )
		var proto strings.Builder
		for !p.curTokenIs(lexer.TokRParen) && !p.curTokenIs(lexer.TokEOF) {
			proto.WriteString(p.curToken.Value)
			p.nextToken()
		}
		decl.Prototype = proto.String()
	}

	// Optional attributes
	// Opsiyonel özellikler
	for p.peekTokenIs(lexer.TokColon) {
		p.nextToken()
		p.nextToken()
		decl.Attributes = append(decl.Attributes, p.curToken.Value)
	}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}

	decl.Body = p.parseBlockStmt()
	return decl
}

func (p *Parser) parsePackageDecl() ast.Statement {
	decl := &ast.PackageDecl{Token: p.curToken}

	p.nextToken()
	decl.Name = p.curToken.Value

	// Handle Package::Name
	for p.peekTokenIs(lexer.TokDoubleColon) {
		p.nextToken()
		decl.Name += p.curToken.Value
		p.nextToken()
		decl.Name += p.curToken.Value
	}

	// Optional version
	// Opsiyonel versiyon
	if p.peekTokenIs(lexer.TokFloat) || p.peekTokenIs(lexer.TokVersion) {
		p.nextToken()
		decl.Version = p.curToken.Value
	}

	// Block form or semicolon
	// Blok formu veya noktalı virgül
	if p.peekTokenIs(lexer.TokLBrace) {
		p.nextToken()
		decl.Block = p.parseBlockStmt()
	} else if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return decl
}

func (p *Parser) parseUseDecl() ast.Statement {
	decl := &ast.UseDecl{Token: p.curToken}

	p.nextToken()
	decl.Module = p.curToken.Value

	// Handle Module::Name
	for p.peekTokenIs(lexer.TokDoubleColon) {
		p.nextToken()
		decl.Module += p.curToken.Value
		p.nextToken()
		decl.Module += p.curToken.Value
	}

	// Optional version
	if p.peekTokenIs(lexer.TokFloat) || p.peekTokenIs(lexer.TokVersion) {
		p.nextToken()
		decl.Version = p.curToken.Value
	}

	// Optional import list
	if p.peekTokenIs(lexer.TokQw) || p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		// TODO: Parse qw() or import list
	}

	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return decl
}

func (p *Parser) parseNoDecl() ast.Statement {
	decl := &ast.NoDecl{Token: p.curToken}

	p.nextToken()
	decl.Module = p.curToken.Value

	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return decl
}

func (p *Parser) parseRequireDecl() ast.Statement {
	decl := &ast.RequireDecl{Token: p.curToken}

	p.nextToken()

	if p.curTokenIs(lexer.TokString) || p.curTokenIs(lexer.TokRawString) {
		decl.Expr = p.parseExpression(LOWEST)
	} else {
		decl.Module = p.curToken.Value
	}

	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return decl
}

func (p *Parser) parseSpecialBlock() ast.Statement {
	block := &ast.SpecialBlock{Token: p.curToken, Kind: p.curToken.Value}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}

	block.Body = p.parseBlockStmt()
	return block
}
```

## File: ./pkg/parser/parser_additional.go
```go
package parser

// Package parser implements Perl parsing using Pratt parsing.
// Paket parser, Pratt ayrıştırma kullanarak Perl ayrıştırmasını uygular.

import (
	"fmt"
	"strings"

	"perlc/pkg/ast"
	"perlc/pkg/lexer"
)

// ============================================================
// Control Flow Parsers
// Kontrol Akışı Ayrıştırıcıları
// ============================================================

func (p *Parser) parseIfStmt() ast.Statement {
	stmt := &ast.IfStmt{Token: p.curToken}
	stmt.Unless = p.curToken.Type == lexer.TokUnless

	if !p.expectPeek(lexer.TokLParen) {
		return nil
	}
	p.nextToken()
	stmt.Condition = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}
	stmt.Then = p.parseBlockStmt()

	// Elsif clauses
	for p.peekTokenIs(lexer.TokElsif) {
		p.nextToken()
		clause := &ast.ElsifClause{}

		if !p.expectPeek(lexer.TokLParen) {
			return nil
		}
		p.nextToken()
		clause.Condition = p.parseExpression(LOWEST)
		if !p.expectPeek(lexer.TokRParen) {
			return nil
		}

		if !p.expectPeek(lexer.TokLBrace) {
			return nil
		}
		clause.Body = p.parseBlockStmt()
		stmt.Elsif = append(stmt.Elsif, clause)
	}

	// Else clause
	if p.peekTokenIs(lexer.TokElse) {
		p.nextToken()
		if !p.expectPeek(lexer.TokLBrace) {
			return nil
		}
		stmt.Else = p.parseBlockStmt()
	}

	return stmt
}

func (p *Parser) parseWhileStmt() ast.Statement {
	stmt := &ast.WhileStmt{Token: p.curToken}
	stmt.Until = p.curToken.Type == lexer.TokUntil

	if !p.expectPeek(lexer.TokLParen) {
		return nil
	}
	p.nextToken()
	stmt.Condition = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}
	stmt.Body = p.parseBlockStmt()

	return stmt
}

func (p *Parser) parseForStmt() ast.Statement {
	token := p.curToken

	if !p.expectPeek(lexer.TokLParen) {
		return nil
	}

	p.nextToken() // skip (, now at first token inside

	// Check if it's foreach-style: for my $x (@arr) or for $x (@arr)
	// Need to look ahead to distinguish from C-style: for (my $i = 0; ...)
	if p.curTokenIs(lexer.TokMy) || p.curTokenIs(lexer.TokOur) || p.curTokenIs(lexer.TokLocal) {
		// Save position to check what follows the variable
		// If "my $x (" -> foreach style
		// If "my $x =" -> C-style

		// Peek: my $var ... what's next?
		// For C-style: my $i = 0; -> after $i comes =
		// For foreach: my $x (@arr) -> after $x comes ( but we're already past outer (

		// Actually in "for (my $i = 0; ...)" we're inside parens
		// In "for my $x (@arr)" the my is OUTSIDE parens
		// But our current position is AFTER (, so this must be C-style!

		// So if we're here (after opening paren) and see "my", it's C-style init
		// Fall through to C-style parsing
	} else if p.curTokenIs(lexer.TokScalar) {
		// for ($x ...) - need to check if it's foreach or C-style
		// For now, assume C-style if inside parens
	}

	// C-style for: for (init; cond; post) { body }
	stmt := &ast.ForStmt{Token: token}

	// Init
	if !p.curTokenIs(lexer.TokSemi) {
		stmt.Init = p.parseStatement()
	}
	// After parseStatement, we might be on ; or need to advance
	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}
	if p.curTokenIs(lexer.TokSemi) {
		p.nextToken() // skip ;
	}

	// Condition
	if !p.curTokenIs(lexer.TokSemi) {
		stmt.Condition = p.parseExpression(LOWEST)
	}
	if !p.expectPeek(lexer.TokSemi) {
		return nil
	}
	p.nextToken() // skip ;

	// Post
	if !p.curTokenIs(lexer.TokRParen) {
		stmt.Post = p.parseExpression(LOWEST)
	}
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}

	// Body
	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}
	stmt.Body = p.parseBlockStmt()

	return stmt
}

func (p *Parser) parseForeachStyleFor(token lexer.Token) ast.Statement {
	stmt := &ast.ForeachStmt{Token: token}

	if p.curTokenIs(lexer.TokMy) {
		p.nextToken()
	}
	stmt.Variable = p.parseExpression(LOWEST)

	if !p.expectPeek(lexer.TokLParen) {
		return nil
	}
	p.nextToken()
	stmt.List = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}

	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}
	stmt.Body = p.parseBlockStmt()

	return stmt
}

func (p *Parser) parseForeachStmt() ast.Statement {
	stmt := &ast.ForeachStmt{Token: p.curToken}

	p.nextToken() // skip foreach

	// Optional my/our/local
	if p.curTokenIs(lexer.TokMy) || p.curTokenIs(lexer.TokOur) || p.curTokenIs(lexer.TokLocal) {
		p.nextToken()
	}

	// Variable - parse with high precedence to stop before (
	stmt.Variable = p.parseExpression(CALL)

	// List in parentheses
	if !p.expectPeek(lexer.TokLParen) {
		return nil
	}
	p.nextToken() // skip (
	stmt.List = p.parseExpression(LOWEST)
	if !p.expectPeek(lexer.TokRParen) {
		return nil
	}

	// Body
	if !p.expectPeek(lexer.TokLBrace) {
		return nil
	}
	stmt.Body = p.parseBlockStmt()

	return stmt
}

func (p *Parser) parseLastStmt() ast.Statement {
	stmt := &ast.LastStmt{Token: p.curToken}
	if p.peekTokenIs(lexer.TokIdent) {
		p.nextToken()
		stmt.Label = p.curToken.Value
	}
	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}
	return stmt
}

func (p *Parser) parseNextStmt() ast.Statement {
	stmt := &ast.NextStmt{Token: p.curToken}
	if p.peekTokenIs(lexer.TokIdent) {
		p.nextToken()
		stmt.Label = p.curToken.Value
	}
	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}
	return stmt
}

func (p *Parser) parseRedoStmt() ast.Statement {
	stmt := &ast.RedoStmt{Token: p.curToken}
	if p.peekTokenIs(lexer.TokIdent) {
		p.nextToken()
		stmt.Label = p.curToken.Value
	}
	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}
	return stmt
}

func (p *Parser) parseReturnStmt() ast.Statement {
	stmt := &ast.ReturnStmt{Token: p.curToken}

	if !p.peekTokenIs(lexer.TokSemi) && !p.peekTokenIs(lexer.TokRBrace) {
		p.nextToken()
		stmt.Value = p.parseExpression(LOWEST)
	}

	if p.peekTokenIs(lexer.TokSemi) {
		p.nextToken()
	}

	return stmt
}

func (p *Parser) parseFatArrowExpression(left ast.Expression) ast.Expression {
	// fat arrow used in hash context, return as-is for hash parsing
	// hash bağlamında kullanılan fat arrow, hash ayrıştırma için olduğu gibi döndür
	return left
}

func (p *Parser) parseBuiltinCall() ast.Expression {
	tok := p.curToken
	name := tok.Value

	// Special handling for print/say with filehandle: print $fh "text"
	if name == "print" || name == "say" {
		return p.parsePrintCall(tok, name)
	}

	expr := &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: name},
	}

	// Check for parentheses
	if p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		expr.Args = p.parseExpressionList(lexer.TokRParen)
	} else {
		// No parentheses - parse arguments
		p.nextToken()
		expr.Args = p.parseListExpression()
	}

	return expr
}

func (p *Parser) parsePrintCall(tok lexer.Token, name string) ast.Expression {
	expr := &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: name},
	}

	// Check for parentheses
	if p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		expr.Args = p.parseExpressionList(lexer.TokRParen)
		return expr
	}

	p.nextToken()

	// Check if first token is a scalar variable (potential filehandle)
	// Filehandle form: print $fh "text" or print $fh $var
	// But NOT: print $a + $b (that's an expression)
	// Filehandle is followed by a string or another scalar (not an operator)
	if p.curTokenIs(lexer.TokScalar) &&
		(p.peekTokenIs(lexer.TokString) || p.peekTokenIs(lexer.TokRawString) ||
			(p.peekTokenIs(lexer.TokScalar) && !p.isOperatorToken(p.peekToken.Type))) {
		// This is filehandle form: print $fh "text" or print $fh $var
		fhExpr := p.parseExpression(LOWEST)
		expr.Args = append(expr.Args, fhExpr)
		p.nextToken()
		expr.Args = append(expr.Args, p.parseListExpression()...)
		return expr
	}

	// Normal print - parse full expression list
	expr.Args = p.parseListExpression()
	return expr
}

func (p *Parser) ParsePrintCallComplex(tok lexer.Token, name string) ast.Expression {
	expr := &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: name},
	}

	// Check for parentheses
	if p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		expr.Args = p.parseExpressionList(lexer.TokRParen)
		return expr
	}

	p.nextToken()

	// Check if first token is a scalar variable (potential filehandle)
	// But NOT if it's followed by -> (that's arrow access, not filehandle)
	if p.curTokenIs(lexer.TokScalar) && !p.peekTokenIs(lexer.TokArrow) {

		fhExpr := p.parseExpression(CALL)

		// Check if next token is expression (not comma, not semicolon) - filehandle form
		if !p.peekTokenIs(lexer.TokComma) && !p.peekTokenIs(lexer.TokSemi) && !p.peekTokenIs(lexer.TokEOF) && !p.peekTokenIs(lexer.TokArrow) {
			expr.Args = append(expr.Args, fhExpr)
			p.nextToken()
			expr.Args = append(expr.Args, p.parseListExpression()...)
		} else {
			// Normal: print $var; or print $var, $var2;
			expr.Args = append(expr.Args, fhExpr)
			if p.peekTokenIs(lexer.TokComma) {
				p.nextToken()
				p.nextToken()
				expr.Args = append(expr.Args, p.parseListExpression()...)
			}
		}
		return expr
	}

	// Normal print without filehandle
	expr.Args = p.parseListExpression()
	return expr
}

func (p *Parser) ParsePrintCallComplex2(tok lexer.Token, name string) ast.Expression {
	expr := &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: name},
	}

	// Check for parentheses
	if p.peekTokenIs(lexer.TokLParen) {
		p.nextToken()
		expr.Args = p.parseExpressionList(lexer.TokRParen)
		return expr
	}

	p.nextToken()

	// Check if first token is a scalar variable (potential filehandle)
	// Filehandle form: print $fh "text" (identifier after scalar, no operator)
	if p.curTokenIs(lexer.TokScalar) && p.peekTokenIs(lexer.TokString) {
		// This is filehandle form: print $fh "text"
		fhExpr := p.parseExpression(CALL)

		expr.Args = append(expr.Args, fhExpr)
		p.nextToken()

		expr.Args = append(expr.Args, p.parseListExpression()...)

		return expr
	}

	// Normal print - parse full expression list
	expr.Args = p.parseListExpression()
	return expr
}

func (p *Parser) parseSubstExpression(left ast.Expression) ast.Expression {
	tok := p.curToken
	// Parse s/pattern/replacement/flags from token value
	parts := strings.SplitN(tok.Value, "/", 3)
	pattern := ""
	replacement := ""
	flags := ""
	if len(parts) >= 1 {
		pattern = parts[0]
	}
	if len(parts) >= 2 {
		replacement = parts[1]
	}
	if len(parts) >= 3 {
		flags = parts[2]
	}

	return &ast.SubstExpr{
		Token:       tok,
		Target:      left,
		Pattern:     pattern,
		Replacement: replacement,
		Flags:       flags,
	}
}

func (p *Parser) parseOpenExpr() ast.Expression {
	tok := p.curToken

	if !p.expectPeek(lexer.TokLParen) {
		// open without parens: open FH, MODE, FILE
		p.nextToken()
	} else {
		p.nextToken() // skip (
	}

	// Filehandle
	var fh ast.Expression
	if p.curTokenIs(lexer.TokMy) {
		p.nextToken() // skip my
	}
	fh = p.parseExpression(LOWEST)

	if !p.expectPeek(lexer.TokComma) {
		return nil
	}
	p.nextToken()

	// Mode
	mode := p.parseExpression(LOWEST)

	// Optional third argument (filename)
	var filename ast.Expression
	if p.peekTokenIs(lexer.TokComma) {
		p.nextToken() // skip comma
		p.nextToken()
		filename = p.parseExpression(LOWEST)
	}

	if p.peekTokenIs(lexer.TokRParen) {
		p.nextToken()
	}

	return &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: "open"},
		Args:     []ast.Expression{fh, mode, filename},
	}
}

func (p *Parser) parseCloseExpr() ast.Expression {
	tok := p.curToken

	if !p.expectPeek(lexer.TokLParen) {
		p.nextToken()
	} else {
		p.nextToken() // skip (
	}

	fh := p.parseExpression(LOWEST)

	if p.peekTokenIs(lexer.TokRParen) {
		p.nextToken()
	}

	return &ast.CallExpr{
		Token:    tok,
		Function: &ast.Identifier{Token: tok, Value: "close"},
		Args:     []ast.Expression{fh},
	}
}

func (p *Parser) parseReadLineExpr() ast.Expression {
	tok := p.curToken

	expr := &ast.ReadLineExpr{Token: tok}

	if tok.Type == lexer.TokDiamond {
		// <> - STDIN/ARGV
		expr.Filehandle = nil
	} else {
		// <FH> or <$fh>
		if len(tok.Value) > 0 && tok.Value[0] == '$' {
			// Variable filehandle
			expr.Filehandle = &ast.ScalarVar{Token: tok, Name: tok.Value[1:]}
		} else {
			// Bareword filehandle
			expr.Filehandle = &ast.Identifier{Token: tok, Value: tok.Value}
		}
	}

	return expr
}

// parseListExpression parses comma-separated expressions until semicolon or EOF
func (p *Parser) parseListExpression() []ast.Expression {
	var list []ast.Expression

	if p.curTokenIs(lexer.TokSemi) || p.curTokenIs(lexer.TokEOF) {
		return list
	}

	list = append(list, p.parseExpression(LOWEST))

	for p.peekTokenIs(lexer.TokComma) {
		p.nextToken()
		p.nextToken()
		list = append(list, p.parseExpression(LOWEST))
	}

	return list
}

// -----------------------------------------------------------------//
// ------------------------ Parsing Helpers ----------------------- //
// ------------------------ Ayrıştırma Yardımcıları ----------------------- //
// -----------------------------------------------------------------//
// Errors returns parsing errors.
// Errors, ayrıştırma hatalarını döndürür.
func (p *Parser) Errors() []string {
	return p.errors
}

func (p *Parser) peekError(t lexer.TokenType) {
	msg := fmt.Sprintf("line %d: expected next token to be %v, got %v instead",
		p.peekToken.Line, t, p.peekToken.Type)
	p.errors = append(p.errors, msg)
}

func (p *Parser) noPrefixParseFnError(t lexer.TokenType) {
	msg := fmt.Sprintf("line %d: no prefix parse function for %v found (value=%q, peek=%v/%q)",
		p.curToken.Line, t, p.curToken.Value, p.peekToken.Type, p.peekToken.Value)
	p.errors = append(p.errors, msg)
}

func (p *Parser) curTokenIs(t lexer.TokenType) bool {
	return p.curToken.Type == t
}

func (p *Parser) peekTokenIs(t lexer.TokenType) bool {
	return p.peekToken.Type == t
}

func (p *Parser) expectPeek(t lexer.TokenType) bool {
	if p.peekTokenIs(t) {
		p.nextToken()
		return true
	}
	p.peekError(t)
	return false
}

func (p *Parser) peekPrecedence() int {
	if p, ok := precedences[p.peekToken.Type]; ok {
		return p
	}
	return LOWEST
}

func (p *Parser) curPrecedence() int {
	if p, ok := precedences[p.curToken.Type]; ok {
		return p
	}
	return LOWEST
}

// isOperatorToken checks if token is an operator
func (p *Parser) isOperatorToken(t lexer.TokenType) bool {
	switch t {
	case lexer.TokPlus, lexer.TokMinus, lexer.TokStar, lexer.TokSlash,
		lexer.TokPercent, lexer.TokStarStar, lexer.TokDot, lexer.TokX,
		lexer.TokEq, lexer.TokNe, lexer.TokLt, lexer.TokLe, lexer.TokGt, lexer.TokGe,
		lexer.TokStrEq, lexer.TokStrNe, lexer.TokStrLt, lexer.TokStrLe, lexer.TokStrGt, lexer.TokStrGe,
		lexer.TokAnd, lexer.TokOr, lexer.TokAndWord, lexer.TokOrWord,
		lexer.TokAssign, lexer.TokPlusEq, lexer.TokMinusEq,
		lexer.TokArrow, lexer.TokComma, lexer.TokSemi:
		return true
	default:
		return false
	}
}

// isBareword returns true if current token can be used as a hash key bareword.
// In Perl, keywords can be used as hash keys without quoting.
func (p *Parser) isBareword() bool {
	switch p.curToken.Type {
	case lexer.TokIdent:
		return true
	// Keywords that can be used as barewords in hash keys
	case lexer.TokX, lexer.TokIf, lexer.TokElse, lexer.TokFor, lexer.TokForeach,
		lexer.TokWhile, lexer.TokMy, lexer.TokOur, lexer.TokLocal, lexer.TokSub,
		lexer.TokUse, lexer.TokPackage, lexer.TokReturn, lexer.TokLast, lexer.TokNext,
		lexer.TokStrEq, lexer.TokStrNe, lexer.TokStrLt, lexer.TokStrLe, lexer.TokStrGt, lexer.TokStrGe,
		lexer.TokAndWord, lexer.TokOrWord, lexer.TokNotWord,
		lexer.TokPrint, lexer.TokSay, lexer.TokDefined, lexer.TokUndef, lexer.TokRef,
		lexer.TokLength, lexer.TokPush, lexer.TokPop, lexer.TokShift, lexer.TokUnshift,
		lexer.TokKeys, lexer.TokValues, lexer.TokJoin, lexer.TokSplit,
		lexer.TokAbs, lexer.TokInt, lexer.TokSqrt, lexer.TokChr, lexer.TokOrd,
		lexer.TokLc, lexer.TokUc, lexer.TokChomp, lexer.TokChop,
		lexer.TokOpen, lexer.TokClose, lexer.TokDie, lexer.TokWarn, lexer.TokExit:
		return true
	default:
		return false
	}
}
```

## File: ./pkg/parser/parser_test.go
```go
package parser

// Package parser tests

import (
	"testing"

	"perlc/pkg/ast"
	"perlc/pkg/lexer"
)

// ============================================================
// Helper Functions
// Yardımcı Fonksiyonlar
// ============================================================

func parseProgram(t *testing.T, input string) *ast.Program {
	l := lexer.New(input)
	p := New(l)
	program := p.ParseProgram()
	checkParserErrors(t, p)
	return program
}

func checkParserErrors(t *testing.T, p *Parser) {
	errors := p.Errors()
	if len(errors) == 0 {
		return
	}
	t.Errorf("parser has %d errors", len(errors))
	for _, msg := range errors {
		t.Errorf("parser error: %q", msg)
	}
	t.FailNow()
}

// ============================================================
// Literal Tests
// Literal Testleri
// ============================================================

func TestIntegerLiteral(t *testing.T) {
	tests := []struct {
		input    string
		expected int64
	}{
		{"42;", 42},
		{"0;", 0},
		{"-1;", -1}, // This is actually prefix minus + 1
		{"0x1F;", 31},
		{"0b1010;", 10},
		{"0777;", 511},
	}

	for _, tt := range tests {
		program := parseProgram(t, tt.input)
		if len(program.Statements) != 1 {
			t.Fatalf("expected 1 statement, got %d", len(program.Statements))
		}

		stmt, ok := program.Statements[0].(*ast.ExprStmt)
		if !ok {
			t.Fatalf("not ExprStmt, got %T", program.Statements[0])
		}

		testIntegerLiteral(t, stmt.Expression, tt.expected)
	}
}

func testIntegerLiteral(t *testing.T, exp ast.Expression, expected int64) {
	// Handle negative numbers (prefix expression)
	if prefix, ok := exp.(*ast.PrefixExpr); ok && prefix.Operator == "-" {
		lit, ok := prefix.Right.(*ast.IntegerLiteral)
		if !ok {
			t.Fatalf("not IntegerLiteral, got %T", prefix.Right)
		}
		if lit.Value != -expected {
			t.Errorf("value not %d, got %d", -expected, lit.Value)
		}
		return
	}

	lit, ok := exp.(*ast.IntegerLiteral)
	if !ok {
		t.Fatalf("not IntegerLiteral, got %T", exp)
	}
	if lit.Value != expected {
		t.Errorf("value not %d, got %d", expected, lit.Value)
	}
}

func TestStringLiteral(t *testing.T) {
	input := `"hello world";`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	lit, ok := stmt.Expression.(*ast.StringLiteral)
	if !ok {
		t.Fatalf("not StringLiteral, got %T", stmt.Expression)
	}
	if lit.Value != "hello world" {
		t.Errorf("value not %q, got %q", "hello world", lit.Value)
	}
}

// ============================================================
// Variable Tests
// Değişken Testleri
// ============================================================

func TestScalarVar(t *testing.T) {
	input := `$foo;`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	v, ok := stmt.Expression.(*ast.ScalarVar)
	if !ok {
		t.Fatalf("not ScalarVar, got %T", stmt.Expression)
	}
	if v.Name != "foo" {
		t.Errorf("name not foo, got %s", v.Name)
	}
}

func TestArrayVar(t *testing.T) {
	input := `@arr;`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	v, ok := stmt.Expression.(*ast.ArrayVar)
	if !ok {
		t.Fatalf("not ArrayVar, got %T", stmt.Expression)
	}
	if v.Name != "arr" {
		t.Errorf("name not arr, got %s", v.Name)
	}
}

func TestHashVar(t *testing.T) {
	input := `%hash;`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	v, ok := stmt.Expression.(*ast.HashVar)
	if !ok {
		t.Fatalf("not HashVar, got %T", stmt.Expression)
	}
	if v.Name != "hash" {
		t.Errorf("name not hash, got %s", v.Name)
	}
}

// ============================================================
// Operator Tests
// Operatör Testleri
// ============================================================

func TestInfixExpressions(t *testing.T) {
	tests := []struct {
		input    string
		left     int64
		operator string
		right    int64
	}{
		{"5 + 5;", 5, "+", 5},
		{"5 - 5;", 5, "-", 5},
		{"5 * 5;", 5, "*", 5},
		{"5 / 5;", 5, "/", 5},
		{"5 % 5;", 5, "%", 5},
		{"5 ** 2;", 5, "**", 2},
		{"5 == 5;", 5, "==", 5},
		{"5 != 5;", 5, "!=", 5},
		{"5 < 5;", 5, "<", 5},
		{"5 > 5;", 5, ">", 5},
		{"5 <= 5;", 5, "<=", 5},
		{"5 >= 5;", 5, ">=", 5},
		{"5 <=> 5;", 5, "<=>", 5},
	}

	for _, tt := range tests {
		program := parseProgram(t, tt.input)
		stmt := program.Statements[0].(*ast.ExprStmt)
		exp, ok := stmt.Expression.(*ast.InfixExpr)
		if !ok {
			t.Fatalf("not InfixExpr for %q, got %T", tt.input, stmt.Expression)
		}

		testIntegerLiteral(t, exp.Left, tt.left)
		if exp.Operator != tt.operator {
			t.Errorf("operator not %s, got %s", tt.operator, exp.Operator)
		}
		testIntegerLiteral(t, exp.Right, tt.right)
	}
}

func TestOperatorPrecedence(t *testing.T) {
	tests := []struct {
		input    string
		expected string
	}{
		{"1 + 2 * 3;", "(1 + (2 * 3))"},
		{"1 * 2 + 3;", "((1 * 2) + 3)"},
		{"2 ** 3 ** 2;", "(2 ** (3 ** 2))"}, // Right associative
		{"1 + 2 + 3;", "((1 + 2) + 3)"},     // Left associative
		{"1 < 2 == 3 > 4;", "((1 < 2) == (3 > 4))"},
		{"1 && 2 || 3;", "((1 && 2) || 3)"},
	}

	for _, tt := range tests {
		program := parseProgram(t, tt.input)
		stmt := program.Statements[0].(*ast.ExprStmt)
		actual := stmt.Expression.String()
		if actual != tt.expected {
			t.Errorf("for %q: expected %s, got %s", tt.input, tt.expected, actual)
		}
	}
}

func TestTernaryExpression(t *testing.T) {
	input := `$x ? 1 : 2;`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	exp, ok := stmt.Expression.(*ast.TernaryExpr)
	if !ok {
		t.Fatalf("not TernaryExpr, got %T", stmt.Expression)
	}

	if _, ok := exp.Condition.(*ast.ScalarVar); !ok {
		t.Errorf("condition not ScalarVar")
	}
	testIntegerLiteral(t, exp.Then, 1)
	testIntegerLiteral(t, exp.Else, 2)
}

// ============================================================
// Declaration Tests
// Bildirim Testleri
// ============================================================

func TestMyDecl(t *testing.T) {
	input := `my $x = 42;`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.VarDecl)
	if !ok {
		t.Fatalf("not VarDecl, got %T", program.Statements[0])
	}
	if decl.Kind != "my" {
		t.Errorf("kind not my, got %s", decl.Kind)
	}
	if len(decl.Names) != 1 {
		t.Fatalf("expected 1 name, got %d", len(decl.Names))
	}
}

func TestMyListDecl(t *testing.T) {
	input := `my ($x, $y) = (1, 2);`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.VarDecl)
	if !ok {
		t.Fatalf("not VarDecl, got %T", program.Statements[0])
	}
	if len(decl.Names) != 2 {
		t.Errorf("expected 2 names, got %d", len(decl.Names))
	}
}

func TestSubDecl(t *testing.T) {
	input := `sub foo { return 42; }`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.SubDecl)
	if !ok {
		t.Fatalf("not SubDecl, got %T", program.Statements[0])
	}
	if decl.Name != "foo" {
		t.Errorf("name not foo, got %s", decl.Name)
	}
	if decl.Body == nil {
		t.Error("body is nil")
	}
}

func TestPackageDecl(t *testing.T) {
	input := `package Foo::Bar;`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.PackageDecl)
	if !ok {
		t.Fatalf("not PackageDecl, got %T", program.Statements[0])
	}
	if decl.Name != "Foo::Bar" {
		t.Errorf("name not Foo::Bar, got %s", decl.Name)
	}
}

func TestUseDecl(t *testing.T) {
	input := `use strict;`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.UseDecl)
	if !ok {
		t.Fatalf("not UseDecl, got %T", program.Statements[0])
	}
	if decl.Module != "strict" {
		t.Errorf("module not strict, got %s", decl.Module)
	}
}

// ============================================================
// Control Flow Tests
// Kontrol Akışı Testleri
// ============================================================

func TestIfStmt(t *testing.T) {
	input := `if ($x) { 1; }`
	program := parseProgram(t, input)

	stmt, ok := program.Statements[0].(*ast.IfStmt)
	if !ok {
		t.Fatalf("not IfStmt, got %T", program.Statements[0])
	}
	if stmt.Unless {
		t.Error("should not be unless")
	}
	if stmt.Condition == nil {
		t.Error("condition is nil")
	}
	if stmt.Then == nil {
		t.Error("then block is nil")
	}
}

func TestIfElseStmt(t *testing.T) {
	input := `if ($x) { 1; } else { 2; }`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.IfStmt)
	if stmt.Else == nil {
		t.Error("else block is nil")
	}
}

func TestIfElsifElseStmt(t *testing.T) {
	input := `if ($x) { 1; } elsif ($y) { 2; } else { 3; }`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.IfStmt)
	if len(stmt.Elsif) != 1 {
		t.Errorf("expected 1 elsif, got %d", len(stmt.Elsif))
	}
	if stmt.Else == nil {
		t.Error("else block is nil")
	}
}

func TestWhileStmt(t *testing.T) {
	input := `while ($x) { $x--; }`
	program := parseProgram(t, input)

	stmt, ok := program.Statements[0].(*ast.WhileStmt)
	if !ok {
		t.Fatalf("not WhileStmt, got %T", program.Statements[0])
	}
	if stmt.Until {
		t.Error("should not be until")
	}
}

func TestForeachStmt(t *testing.T) {
	input := `foreach my $x (@arr) { print $x; }`
	program := parseProgram(t, input)

	stmt, ok := program.Statements[0].(*ast.ForeachStmt)
	if !ok {
		t.Fatalf("not ForeachStmt, got %T", program.Statements[0])
	}
	if stmt.Variable == nil {
		t.Error("variable is nil")
	}
	if stmt.List == nil {
		t.Error("list is nil")
	}
}

func TestReturnStmt(t *testing.T) {
	input := `return 42;`
	program := parseProgram(t, input)

	stmt, ok := program.Statements[0].(*ast.ReturnStmt)
	if !ok {
		t.Fatalf("not ReturnStmt, got %T", program.Statements[0])
	}
	testIntegerLiteral(t, stmt.Value, 42)
}

// ============================================================
// Complex Expression Tests
// Karmaşık İfade Testleri
// ============================================================

func TestArrayLiteral(t *testing.T) {
	input := `[1, 2, 3];`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	arr, ok := stmt.Expression.(*ast.ArrayExpr)
	if !ok {
		t.Fatalf("not ArrayExpr, got %T", stmt.Expression)
	}
	if len(arr.Elements) != 3 {
		t.Errorf("expected 3 elements, got %d", len(arr.Elements))
	}
}

func TestHashLiteral(t *testing.T) {
	input := `my $h = {a => 1, b => 2};`
	program := parseProgram(t, input)

	decl, ok := program.Statements[0].(*ast.VarDecl)
	if !ok {
		t.Fatalf("not VarDecl, got %T", program.Statements[0])
	}

	hash, ok := decl.Value.(*ast.HashExpr)
	if !ok {
		t.Fatalf("value not HashExpr, got %T", decl.Value)
	}
	if len(hash.Pairs) != 2 {
		t.Errorf("expected 2 pairs, got %d", len(hash.Pairs))
	}
}

func TestArrayAccess(t *testing.T) {
	input := `$arr[0];`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	acc, ok := stmt.Expression.(*ast.ArrayAccess)
	if !ok {
		t.Fatalf("not ArrayAccess, got %T", stmt.Expression)
	}
	if acc.Array == nil {
		t.Error("array is nil")
	}
	testIntegerLiteral(t, acc.Index, 0)
}

func TestHashAccess(t *testing.T) {
	input := `$hash{key};`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	acc, ok := stmt.Expression.(*ast.HashAccess)
	if !ok {
		t.Fatalf("not HashAccess, got %T", stmt.Expression)
	}
	if acc.Hash == nil {
		t.Error("hash is nil")
	}
}

func TestMethodCall(t *testing.T) {
	input := `$obj->method(1, 2);`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	call, ok := stmt.Expression.(*ast.MethodCall)
	if !ok {
		t.Fatalf("not MethodCall, got %T", stmt.Expression)
	}
	if call.Method != "method" {
		t.Errorf("method not method, got %s", call.Method)
	}
	if len(call.Args) != 2 {
		t.Errorf("expected 2 args, got %d", len(call.Args))
	}
}

func TestCallExpr(t *testing.T) {
	input := `foo(1, 2, 3);`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	call, ok := stmt.Expression.(*ast.CallExpr)
	if !ok {
		t.Fatalf("not CallExpr, got %T", stmt.Expression)
	}
	if len(call.Args) != 3 {
		t.Errorf("expected 3 args, got %d", len(call.Args))
	}
}

func TestRefExpr(t *testing.T) {
	input := `\@arr;`
	program := parseProgram(t, input)

	stmt := program.Statements[0].(*ast.ExprStmt)
	ref, ok := stmt.Expression.(*ast.RefExpr)
	if !ok {
		t.Fatalf("not RefExpr, got %T", stmt.Expression)
	}
	if _, ok := ref.Value.(*ast.ArrayVar); !ok {
		t.Errorf("value not ArrayVar, got %T", ref.Value)
	}
}

func TestAnonSub(t *testing.T) {
	input := `my $f = sub { return 1; };`
	program := parseProgram(t, input)

	decl := program.Statements[0].(*ast.VarDecl)
	anon, ok := decl.Value.(*ast.AnonSubExpr)
	if !ok {
		t.Fatalf("not AnonSubExpr, got %T", decl.Value)
	}
	if anon.Body == nil {
		t.Error("body is nil")
	}
}

// ============================================================
// Real Perl Code Test
// Gerçek Perl Kodu Testi
// ============================================================

func TestRealPerlCode(t *testing.T) {
	input := `
use strict;
use warnings;

package Calculator;

sub new {
    my ($class, $value) = @_;
    return bless { value => $value }, $class;
}

sub add {
    my ($self, $n) = @_;
    $self->{value} += $n;
    return $self;
}

sub value {
    my $self = shift;
    return $self->{value};
}

1;
`
	program := parseProgram(t, input)

	if len(program.Statements) < 5 {
		t.Errorf("expected at least 5 statements, got %d", len(program.Statements))
	}
}

// temporaly at parser_test.go
func TestDebugTokens(t *testing.T) {
	inputs := []string{
		"a => 1",
		"my ($x, $y)",
		"foreach my $x (@arr) { }",
		"bless {}",
	}

	for _, input := range inputs {
		t.Logf("=== %s ===", input)
		l := lexer.New(input)
		for {
			tok := l.NextToken()
			t.Logf("  %d: %q", tok.Type, tok.Value)
			if tok.Type == lexer.TokEOF {
				break
			}
		}
	}
}
```

## File: ./pkg/stash/stash.go
```go
// Package stash implements Perl's symbol tables (stashes).
// Paket stash, Perl'in sembol tablolarını (stash'leri) uygular.
//
// A stash is a hash that maps names to globs. Each package has one stash.
// The main:: stash contains all top-level symbols and nested package stashes.
//
// Stash, isimleri globlara eşleyen bir hash'tir. Her paketin bir stash'i vardır.
// main:: stash'i tüm üst düzey sembolleri ve iç içe paket stash'lerini içerir.
package stash

import (
	"strings"
	"sync"

	"perlc/pkg/gv"
	"perlc/pkg/sv"
)

// Stash represents a package's symbol table.
// Stash, bir paketin sembol tablosunu temsil eder.
type Stash struct {
	name    string            // Package name / Paket adı
	symbols map[string]*gv.GV // name -> glob mapping / isim -> glob eşlemesi
	isa     []*sv.SV          // @ISA for inheritance / Kalıtım için @ISA
	mu      sync.RWMutex      // Thread safety / İş parçacığı güvenliği
}

// Global stash registry - all packages.
// Global stash kaydı - tüm paketler.
var (
	stashes   = make(map[string]*Stash)
	stashesMu sync.RWMutex
)

// init creates the main:: stash.
// init, main:: stash'ini oluşturur.
func init() {
	stashes["main"] = &Stash{
		name:    "main",
		symbols: make(map[string]*gv.GV),
	}
}

// ============================================================
// Stash Registry
// Stash Kaydı
// ============================================================

// Get returns stash for package name (creates if not exists).
// Get, paket adı için stash döndürür (yoksa oluşturur).
func Get(pkgName string) *Stash {
	if pkgName == "" {
		pkgName = "main"
	}

	stashesMu.RLock()
	s, ok := stashes[pkgName]
	stashesMu.RUnlock()

	if ok {
		return s
	}

	// Create new stash
	// Yeni stash oluştur
	stashesMu.Lock()

	// Double-check after acquiring write lock
	// Yazma kilidi aldıktan sonra tekrar kontrol et
	if s, ok = stashes[pkgName]; ok {
		stashesMu.Unlock()
		return s
	}

	s = &Stash{
		name:    pkgName,
		symbols: make(map[string]*gv.GV),
	}
	stashes[pkgName] = s
	stashesMu.Unlock() // Release lock BEFORE recursive call / Özyinelemeli çağrıdan ÖNCE kilidi bırak

	// Register in parent stash (outside of lock to avoid deadlock)
	// Üst stash'e kaydet (deadlock'u önlemek için kilidin dışında)
	if idx := strings.LastIndex(pkgName, "::"); idx > 0 {
		parent := pkgName[:idx]
		child := pkgName[idx+2:] + "::"
		Get(parent).FetchGV(child)
	} else if pkgName != "main" {
		Get("main").FetchGV(pkgName + "::")
	}

	return s
}

// Exists checks if stash exists without creating it.
// Exists, stash'in oluşturmadan var olup olmadığını kontrol eder.
func Exists(pkgName string) bool {
	stashesMu.RLock()
	defer stashesMu.RUnlock()
	_, ok := stashes[pkgName]
	return ok
}

// All returns all registered stash names.
// All, tüm kayıtlı stash isimlerini döndürür.
func All() []string {
	stashesMu.RLock()
	defer stashesMu.RUnlock()

	names := make([]string, 0, len(stashes))
	for name := range stashes {
		names = append(names, name)
	}
	return names
}

// ============================================================
// Symbol Access
// Sembol Erişimi
// ============================================================

// FetchGV returns glob for name (creates if not exists).
// FetchGV, isim için glob döndürür (yoksa oluşturur).
func (s *Stash) FetchGV(name string) *gv.GV {
	s.mu.RLock()
	g, ok := s.symbols[name]
	s.mu.RUnlock()

	if ok {
		return g
	}

	s.mu.Lock()
	defer s.mu.Unlock()

	// Double-check
	// Tekrar kontrol
	if g, ok = s.symbols[name]; ok {
		return g
	}

	g = gv.New(s.name, name)
	s.symbols[name] = g
	return g
}

// LookupGV returns glob for name (returns nil if not exists).
// LookupGV, isim için glob döndürür (yoksa nil döndürür).
func (s *Stash) LookupGV(name string) *gv.GV {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.symbols[name]
}

// DeleteGV removes a glob from the stash.
// DeleteGV, stash'ten bir glob kaldırır.
func (s *Stash) DeleteGV(name string) {
	s.mu.Lock()
	defer s.mu.Unlock()

	if g, ok := s.symbols[name]; ok {
		g.Free()
		delete(s.symbols, name)
	}
}

// ============================================================
// Shortcut accessors for common operations
// Yaygın işlemler için kısayol erişimcileri
// ============================================================

// Scalar returns $Package::name.
// Scalar, $Package::name döndürür.
func (s *Stash) Scalar(name string) *sv.SV {
	return s.FetchGV(name).Scalar()
}

// SetScalar sets $Package::name.
// SetScalar, $Package::name'i ayarlar.
func (s *Stash) SetScalar(name string, val *sv.SV) {
	s.FetchGV(name).SetScalar(val)
}

// Array returns @Package::name.
// Array, @Package::name döndürür.
func (s *Stash) Array(name string) *sv.SV {
	return s.FetchGV(name).Array()
}

// SetArray sets @Package::name.
// SetArray, @Package::name'i ayarlar.
func (s *Stash) SetArray(name string, val *sv.SV) {
	s.FetchGV(name).SetArray(val)
}

// Hash returns %Package::name.
// Hash, %Package::name döndürür.
func (s *Stash) Hash(name string) *sv.SV {
	return s.FetchGV(name).Hash()
}

// SetHash sets %Package::name.
// SetHash, %Package::name'i ayarlar.
func (s *Stash) SetHash(name string, val *sv.SV) {
	s.FetchGV(name).SetHash(val)
}

// Code returns &Package::name.
// Code, &Package::name döndürür.
func (s *Stash) Code(name string) *sv.SV {
	return s.FetchGV(name).Code()
}

// SetCode sets &Package::name.
// SetCode, &Package::name'i ayarlar.
func (s *Stash) SetCode(name string, val *sv.SV) {
	s.FetchGV(name).SetCode(val)
}

// ============================================================
// Symbol enumeration
// Sembol numaralandırma
// ============================================================

// Symbols returns all symbol names in this stash.
// Symbols, bu stash'teki tüm sembol isimlerini döndürür.
func (s *Stash) Symbols() []string {
	s.mu.RLock()
	defer s.mu.RUnlock()

	names := make([]string, 0, len(s.symbols))
	for name := range s.symbols {
		names = append(names, name)
	}
	return names
}

// SubStashes returns names of nested package stashes (entries ending with "::").
// SubStashes, iç içe paket stash'lerinin isimlerini döndürür ("::" ile bitenler).
func (s *Stash) SubStashes() []string {
	s.mu.RLock()
	defer s.mu.RUnlock()

	var result []string
	for name := range s.symbols {
		if strings.HasSuffix(name, "::") {
			result = append(result, name[:len(name)-2])
		}
	}
	return result
}

// ============================================================
// @ISA and Inheritance
// @ISA ve Kalıtım
// ============================================================

// ISA returns the @ISA array for inheritance.
// ISA, kalıtım için @ISA dizisini döndürür.
func (s *Stash) ISA() []*sv.SV {
	s.mu.RLock()
	defer s.mu.RUnlock()
	return s.isa
}

// SetISA sets the @ISA array.
// SetISA, @ISA dizisini ayarlar.
func (s *Stash) SetISA(parents []*sv.SV) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.isa = parents
}

// AddISA adds a parent class to @ISA.
// AddISA, @ISA'ya bir üst sınıf ekler.
func (s *Stash) AddISA(parent string) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.isa = append(s.isa, sv.NewString(parent))
}

// ============================================================
// Method Resolution (for OOP)
// Metod Çözümleme (OOP için)
// ============================================================

// FindMethod searches for a method in this class and its @ISA hierarchy.
// Returns the code ref and the package where it was found.
//
// FindMethod, bu sınıfta ve @ISA hiyerarşisinde bir metod arar.
// Kod referansını ve bulunduğu paketi döndürür.
func (s *Stash) FindMethod(name string) (*sv.SV, string) {
	// Check this package first
	// Önce bu paketi kontrol et
	if g := s.LookupGV(name); g != nil && g.HasCode() {
		return g.Code(), s.name
	}

	// Search @ISA recursively (depth-first, left-to-right)
	// @ISA'yı özyinelemeli ara (önce derinlik, soldan sağa)
	visited := make(map[string]bool)
	return s.findMethodRecursive(name, visited)
}

func (s *Stash) findMethodRecursive(name string, visited map[string]bool) (*sv.SV, string) {
	if visited[s.name] {
		return nil, ""
	}
	visited[s.name] = true

	// Check this package
	// Bu paketi kontrol et
	if g := s.LookupGV(name); g != nil && g.HasCode() {
		return g.Code(), s.name
	}

	// Search parents
	// Üst sınıfları ara
	s.mu.RLock()
	parents := s.isa
	s.mu.RUnlock()

	for _, parentSV := range parents {
		parentName := parentSV.AsString()
		parentStash := Get(parentName)
		if code, pkg := parentStash.findMethodRecursive(name, visited); code != nil {
			return code, pkg
		}
	}

	// Try UNIVERSAL as last resort
	// Son çare olarak UNIVERSAL'ı dene
	if s.name != "UNIVERSAL" {
		universal := Get("UNIVERSAL")
		if g := universal.LookupGV(name); g != nil && g.HasCode() {
			return g.Code(), "UNIVERSAL"
		}
	}

	return nil, ""
}

// Can checks if this class or its parents have a method.
// Can, bu sınıfın veya üst sınıflarının bir metodu olup olmadığını kontrol eder.
func (s *Stash) Can(name string) bool {
	code, _ := s.FindMethod(name)
	return code != nil
}

// Isa checks if this class inherits from another.
// Isa, bu sınıfın başka bir sınıftan miras alıp almadığını kontrol eder.
func (s *Stash) Isa(parent string) bool {
	if s.name == parent {
		return true
	}

	visited := make(map[string]bool)
	return s.isaRecursive(parent, visited)
}

func (s *Stash) isaRecursive(target string, visited map[string]bool) bool {
	if visited[s.name] {
		return false
	}
	visited[s.name] = true

	if s.name == target {
		return true
	}

	s.mu.RLock()
	parents := s.isa
	s.mu.RUnlock()

	for _, parentSV := range parents {
		parentName := parentSV.AsString()
		if parentName == target {
			return true
		}
		if Get(parentName).isaRecursive(target, visited) {
			return true
		}
	}

	// Everything isa UNIVERSAL
	// Her şey UNIVERSAL'dır
	return target == "UNIVERSAL"
}

// ============================================================
// AUTOLOAD Support
// AUTOLOAD Desteği
// ============================================================

// FindAutoload searches for AUTOLOAD in the class hierarchy.
// Returns the AUTOLOAD code ref and the package where it was found.
//
// FindAutoload, sınıf hiyerarşisinde AUTOLOAD arar.
// AUTOLOAD kod referansını ve bulunduğu paketi döndürür.
func (s *Stash) FindAutoload() (*sv.SV, string) {
	return s.FindMethod("AUTOLOAD")
}

// ============================================================
// Symbolic References
// Sembolik Referanslar
// ============================================================

// Resolve resolves a fully qualified name like "Foo::Bar::baz".
// Returns the glob for the symbol.
//
// Resolve, "Foo::Bar::baz" gibi tam nitelikli bir adı çözümler.
// Sembol için glob döndürür.
func Resolve(fullName string) *gv.GV {
	// Split into package and name
	// Paket ve isme böl
	pkg := "main"
	name := fullName

	if idx := strings.LastIndex(fullName, "::"); idx >= 0 {
		pkg = fullName[:idx]
		name = fullName[idx+2:]
	}

	return Get(pkg).FetchGV(name)
}

// ResolveScalar resolves $$varname (symbolic scalar reference).
// ResolveScalar, $$varname'i çözümler (sembolik skaler referans).
func ResolveScalar(fullName string) *sv.SV {
	return Resolve(fullName).Scalar()
}

// ResolveArray resolves @$varname (symbolic array reference).
// ResolveArray, @$varname'i çözümler (sembolik dizi referansı).
func ResolveArray(fullName string) *sv.SV {
	return Resolve(fullName).Array()
}

// ResolveHash resolves %$varname (symbolic hash reference).
// ResolveHash, %$varname'i çözümler (sembolik hash referansı).
func ResolveHash(fullName string) *sv.SV {
	return Resolve(fullName).Hash()
}

// ResolveCode resolves &$varname (symbolic code reference).
// ResolveCode, &$varname'i çözümler (sembolik kod referansı).
func ResolveCode(fullName string) *sv.SV {
	return Resolve(fullName).Code()
}

// ============================================================
// Package Information
// Paket Bilgisi
// ============================================================

// Name returns the package name.
// Name, paket adını döndürür.
func (s *Stash) Name() string {
	return s.name
}

// VERSION returns the $VERSION scalar if defined.
// VERSION, tanımlıysa $VERSION skalerini döndürür.
func (s *Stash) VERSION() *sv.SV {
	if g := s.LookupGV("VERSION"); g != nil {
		return g.Scalar()
	}
	return sv.NewUndef()
}
```

## File: ./pkg/stash/stash_test.go
```go
package stash

import (
	"testing"

	"perlc/pkg/sv"
)

// ============================================================
// Basic Access Tests
// Temel Erişim Testleri
// ============================================================

// TestBasicAccess tests symbol storage and retrieval.
// TestBasicAccess, sembol depolama ve almayı test eder.
func TestBasicAccess(t *testing.T) {
	s := Get("BasicTest")

	s.SetScalar("foo", sv.NewInt(42))

	if s.Scalar("foo").AsInt() != 42 {
		t.Error("$BasicTest::foo should be 42")
	}
}

// TestMultipleTypes tests storing different types under same name.
// TestMultipleTypes, aynı isim altında farklı türleri saklamayı test eder.
func TestMultipleTypes(t *testing.T) {
	s := Get("MultiType")

	// $foo, @foo, %foo can coexist
	// $foo, @foo, %foo bir arada var olabilir
	s.SetScalar("foo", sv.NewString("scalar"))

	arr := s.Array("foo")
	if arr == nil || !arr.IsArray() {
		t.Error("@foo should be array")
	}

	hash := s.Hash("foo")
	if hash == nil || !hash.IsHash() {
		t.Error("hash slot should be hash type")
	}

	// Scalar should still be accessible
	// Skaler hâlâ erişilebilir olmalı
	if s.Scalar("foo").AsString() != "scalar" {
		t.Error("$foo should still be 'scalar'")
	}
}

// TestSetAndGet tests all set/get combinations.
// TestSetAndGet, tüm set/get kombinasyonlarını test eder.
func TestSetAndGet(t *testing.T) {
	s := Get("SetGetTest")

	// Scalar
	s.SetScalar("s", sv.NewInt(1))
	if s.Scalar("s").AsInt() != 1 {
		t.Error("Scalar set/get failed")
	}

	// Array
	arr := sv.NewArrayRef(sv.NewInt(1), sv.NewInt(2)).Deref()
	s.SetArray("a", arr)
	if s.Array("a").ArrayData() == nil {
		t.Error("Array set/get failed")
	}

	// Hash
	hash := sv.NewHashRef().Deref()
	s.SetHash("h", hash)
	if s.Hash("h").HashData() == nil {
		t.Error("Hash set/get failed")
	}

	// Code
	code := sv.NewInt(999) // Placeholder for CV
	s.SetCode("c", code)
	if s.Code("c").AsInt() != 999 {
		t.Error("Code set/get failed")
	}
}

// ============================================================
// Package Hierarchy Tests
// Paket Hiyerarşisi Testleri
// ============================================================

// TestNestedPackages tests package hierarchy.
// TestNestedPackages, paket hiyerarşisini test eder.
func TestNestedPackages(t *testing.T) {
	s := Get("Foo::Bar::Baz")

	if s.Name() != "Foo::Bar::Baz" {
		t.Errorf("Package name wrong: %s", s.Name())
	}

	// Parent stashes should exist
	// Üst stash'ler var olmalı
	if !Exists("Foo::Bar") {
		t.Error("Foo::Bar should exist")
	}
	if !Exists("Foo") {
		t.Error("Foo should exist")
	}
}

// TestDeeplyNested tests very deep nesting.
// TestDeeplyNested, çok derin iç içeliği test eder.
func TestDeeplyNested(t *testing.T) {
	s := Get("A::B::C::D::E::F")

	if s.Name() != "A::B::C::D::E::F" {
		t.Error("Deep package name wrong")
	}

	// All parents should exist
	// Tüm üst paketler var olmalı
	parents := []string{"A", "A::B", "A::B::C", "A::B::C::D", "A::B::C::D::E"}
	for _, p := range parents {
		if !Exists(p) {
			t.Errorf("Parent %s should exist", p)
		}
	}
}

// TestMainPackage tests the main package.
// TestMainPackage, main paketini test eder.
func TestMainPackage(t *testing.T) {
	main := Get("main")

	if main.Name() != "main" {
		t.Error("main package name wrong")
	}

	// main should always exist
	// main her zaman var olmalı
	if !Exists("main") {
		t.Error("main should always exist")
	}
}

// TestEmptyPackageName tests empty string defaults to main.
// TestEmptyPackageName, boş string'in main'e varsayıldığını test eder.
func TestEmptyPackageName(t *testing.T) {
	s := Get("")

	if s.Name() != "main" {
		t.Error("Empty package name should default to main")
	}
}

// TestSubStashes tests getting nested package list.
// TestSubStashes, iç içe paket listesini almayı test eder.
func TestSubStashes(t *testing.T) {
	parent := Get("SubTest")
	Get("SubTest::Child1")
	Get("SubTest::Child2")
	Get("SubTest::Child3")

	subs := parent.SubStashes()
	if len(subs) < 3 {
		t.Errorf("Should have at least 3 sub-stashes, got %d", len(subs))
	}
}

// ============================================================
// Symbolic Reference Tests
// Sembolik Referans Testleri
// ============================================================

// TestResolve tests symbolic reference resolution.
// TestResolve, sembolik referans çözümlemeyi test eder.
func TestResolve(t *testing.T) {
	Get("MyMod").SetScalar("version", sv.NewString("1.0"))

	val := ResolveScalar("MyMod::version")
	if val.AsString() != "1.0" {
		t.Errorf("Expected '1.0', got '%s'", val.AsString())
	}
}

// TestResolveAllTypes tests resolving all sigil types.
// TestResolveAllTypes, tüm sigil türlerini çözümlemeyi test eder.
func TestResolveAllTypes(t *testing.T) {
	pkg := Get("ResolveTypes")

	pkg.SetScalar("var", sv.NewInt(42))

	// $ResolveTypes::var
	if ResolveScalar("ResolveTypes::var").AsInt() != 42 {
		t.Error("Scalar resolve failed")
	}

	// @ResolveTypes::arr
	arr := ResolveArray("ResolveTypes::arr")
	if arr == nil || !arr.IsArray() {
		t.Error("Array resolve failed")
	}

	// %ResolveTypes::hash
	hash := ResolveHash("ResolveTypes::hash")
	if hash == nil || !hash.IsHash() {
		t.Error("Hash resolve failed")
	}

	// &ResolveTypes::code
	code := ResolveCode("ResolveTypes::code")
	// Code might be nil, but shouldn't panic
	_ = code
}

// TestResolveMainPackage tests resolving without package prefix.
// TestResolveMainPackage, paket öneki olmadan çözümlemeyi test eder.
func TestResolveMainPackage(t *testing.T) {
	Get("main").SetScalar("mainvar", sv.NewInt(123))

	// "mainvar" should resolve to main::mainvar
	// "mainvar" main::mainvar olarak çözümlenmeli
	gv := Resolve("mainvar")
	if gv.Scalar().AsInt() != 123 {
		t.Error("Should resolve to main:: by default")
	}
}

// TestResolveCreatesGV tests that Resolve creates GV if not exists.
// TestResolveCreatesGV, Resolve'ın yoksa GV oluşturduğunu test eder.
func TestResolveCreatesGV(t *testing.T) {
	gv := Resolve("NewPkg::newvar")

	if gv == nil {
		t.Error("Resolve should create GV")
	}
	if gv.Name() != "newvar" {
		t.Errorf("GV name should be 'newvar', got '%s'", gv.Name())
	}
}

// ============================================================
// Inheritance Tests (@ISA)
// Kalıtım Testleri (@ISA)
// ============================================================

// TestInheritance tests @ISA and method resolution.
// TestInheritance, @ISA ve metod çözümlemeyi test eder.
func TestInheritance(t *testing.T) {
	parent := Get("Parent")
	parent.SetCode("greet", sv.NewInt(1))

	child := Get("Child")
	child.AddISA("Parent")

	code, pkg := child.FindMethod("greet")
	if code == nil {
		t.Error("Should find greet method")
	}
	if pkg != "Parent" {
		t.Errorf("Method should be from Parent, got %s", pkg)
	}
}

// TestMultipleInheritance tests multiple parent classes.
// TestMultipleInheritance, birden fazla üst sınıfı test eder.
func TestMultipleInheritance(t *testing.T) {
	Get("MixinA").SetCode("method_a", sv.NewInt(1))
	Get("MixinB").SetCode("method_b", sv.NewInt(2))

	child := Get("MultiChild")
	child.AddISA("MixinA")
	child.AddISA("MixinB")

	// Should find both methods
	// Her iki metodu da bulmalı
	codeA, _ := child.FindMethod("method_a")
	codeB, _ := child.FindMethod("method_b")

	if codeA == nil {
		t.Error("Should find method_a from MixinA")
	}
	if codeB == nil {
		t.Error("Should find method_b from MixinB")
	}
}

// TestInheritanceOrder tests left-to-right, depth-first search.
// TestInheritanceOrder, soldan sağa, derinlik öncelikli aramayı test eder.
func TestInheritanceOrder(t *testing.T) {
	// Diamond inheritance: D -> B, C -> A
	//      A
	//     / \
	//    B   C
	//     \ /
	//      D
	Get("DiamondA").SetCode("method", sv.NewInt(100))

	bPkg := Get("DiamondB")
	bPkg.AddISA("DiamondA")
	bPkg.SetCode("method", sv.NewInt(200)) // Override

	cPkg := Get("DiamondC")
	cPkg.AddISA("DiamondA")

	dPkg := Get("DiamondD")
	dPkg.AddISA("DiamondB")
	dPkg.AddISA("DiamondC")

	// Should find B's method first (left-to-right)
	// B'nin metodunu önce bulmalı (soldan sağa)
	code, pkg := dPkg.FindMethod("method")
	if pkg != "DiamondB" {
		t.Errorf("Should find method in DiamondB first, got %s", pkg)
	}
	if code.AsInt() != 200 {
		t.Error("Should get overridden value")
	}
}

// TestDeepInheritance tests deep inheritance chain.
// TestDeepInheritance, derin kalıtım zincirini test eder.
func TestDeepInheritance(t *testing.T) {
	// Chain: E -> D -> C -> B -> A
	Get("ChainA").SetCode("root_method", sv.NewInt(1))
	Get("ChainB").AddISA("ChainA")
	Get("ChainC").AddISA("ChainB")
	Get("ChainD").AddISA("ChainC")
	Get("ChainE").AddISA("ChainD")

	code, pkg := Get("ChainE").FindMethod("root_method")
	if code == nil {
		t.Error("Should find method through deep chain")
	}
	if pkg != "ChainA" {
		t.Errorf("Method should be from ChainA, got %s", pkg)
	}
}

// TestIsaCheck tests isa() method.
// TestIsaCheck, isa() metodunu test eder.
func TestIsaCheck(t *testing.T) {
	Get("IsaParent")
	child := Get("IsaChild")
	child.AddISA("IsaParent")

	if !child.Isa("IsaParent") {
		t.Error("Child should isa Parent")
	}
	if !child.Isa("IsaChild") {
		t.Error("Child should isa itself")
	}
	if !child.Isa("UNIVERSAL") {
		t.Error("Everything should isa UNIVERSAL")
	}
	if child.Isa("NonExistent") {
		t.Error("Should not isa NonExistent")
	}
}

// TestIsaSelf tests that class isa itself.
// TestIsaSelf, sınıfın kendisi olduğunu test eder.
func TestIsaSelf(t *testing.T) {
	s := Get("SelfTest")
	if !s.Isa("SelfTest") {
		t.Error("Class should isa itself")
	}
}

// TestCircularInheritance tests protection against circular @ISA.
// TestCircularInheritance, döngüsel @ISA'ya karşı korumayı test eder.
func TestCircularInheritance(t *testing.T) {
	// Create circular: A -> B -> A
	aPkg := Get("CircularA")
	bPkg := Get("CircularB")

	aPkg.AddISA("CircularB")
	bPkg.AddISA("CircularA")

	// Should not infinite loop - visited map prevents this
	// Sonsuz döngü olmamalı - visited map bunu önler
	code, _ := aPkg.FindMethod("nonexistent")
	if code != nil {
		t.Error("Should not find nonexistent method")
	}

	// Same for Isa
	// Isa için de aynı
	result := aPkg.Isa("CircularA")
	if !result {
		t.Error("Circular A should still isa itself")
	}
}

// ============================================================
// Can Tests
// Can Testleri
// ============================================================

// TestCan tests method existence check.
// TestCan, metod varlık kontrolünü test eder.
func TestCan(t *testing.T) {
	s := Get("CanTest2")
	s.SetCode("exists", sv.NewInt(1))

	if !s.Can("exists") {
		t.Error("Should have 'exists' method")
	}
	if s.Can("missing") {
		t.Error("Should not have 'missing' method")
	}
}

// TestCanInherited tests can() with inherited methods.
// TestCanInherited, kalıtılmış metodlarla can()'i test eder.
func TestCanInherited(t *testing.T) {
	Get("CanParent").SetCode("parent_method", sv.NewInt(1))

	child := Get("CanChild")
	child.AddISA("CanParent")

	if !child.Can("parent_method") {
		t.Error("Should find inherited method with can()")
	}
}

// ============================================================
// UNIVERSAL Tests
// UNIVERSAL Testleri
// ============================================================

// TestUniversalMethod tests UNIVERSAL method resolution.
// TestUniversalMethod, UNIVERSAL metod çözümlemeyi test eder.
func TestUniversalMethod(t *testing.T) {
	Get("UNIVERSAL").SetCode("universal_method", sv.NewInt(1))

	// Any class should find UNIVERSAL methods
	// Herhangi bir sınıf UNIVERSAL metodları bulmalı
	randomPkg := Get("RandomPackage")
	code, pkg := randomPkg.FindMethod("universal_method")

	if code == nil {
		t.Error("Should find UNIVERSAL method")
	}
	if pkg != "UNIVERSAL" {
		t.Errorf("Method should be from UNIVERSAL, got %s", pkg)
	}
}

// ============================================================
// AUTOLOAD Tests
// AUTOLOAD Testleri
// ============================================================

// TestFindAutoload tests AUTOLOAD resolution.
// TestFindAutoload, AUTOLOAD çözümlemeyi test eder.
func TestFindAutoload(t *testing.T) {
	Get("AutoParent").SetCode("AUTOLOAD", sv.NewInt(1))

	child := Get("AutoChild")
	child.AddISA("AutoParent")

	code, pkg := child.FindAutoload()
	if code == nil {
		t.Error("Should find AUTOLOAD")
	}
	if pkg != "AutoParent" {
		t.Errorf("AUTOLOAD should be from AutoParent, got %s", pkg)
	}
}

// TestNoAutoload tests when no AUTOLOAD exists.
// TestNoAutoload, AUTOLOAD yokken test eder.
func TestNoAutoload(t *testing.T) {
	s := Get("NoAutoload")
	code, _ := s.FindAutoload()

	if code != nil {
		t.Error("Should not find AUTOLOAD when none defined")
	}
}

// ============================================================
// Symbol Enumeration Tests
// Sembol Numaralandırma Testleri
// ============================================================

// TestSymbols tests symbol enumeration.
// TestSymbols, sembol numaralandırmayı test eder.
func TestSymbols(t *testing.T) {
	s := Get("EnumTest2")
	s.SetScalar("a", sv.NewInt(1))
	s.SetScalar("b", sv.NewInt(2))
	s.SetCode("func", sv.NewInt(3))

	symbols := s.Symbols()
	if len(symbols) < 3 {
		t.Errorf("Should have at least 3 symbols, got %d", len(symbols))
	}

	// Check specific symbols exist
	// Belirli sembollerin varlığını kontrol et
	found := make(map[string]bool)
	for _, sym := range symbols {
		found[sym] = true
	}

	if !found["a"] || !found["b"] || !found["func"] {
		t.Error("Should find all added symbols")
	}
}

// ============================================================
// GV Operations Tests
// GV İşlem Testleri
// ============================================================

// TestFetchGV tests GV creation and retrieval.
// TestFetchGV, GV oluşturma ve almayı test eder.
func TestFetchGV(t *testing.T) {
	s := Get("GVTest")

	gv1 := s.FetchGV("test")
	gv2 := s.FetchGV("test")

	// Should return same GV
	// Aynı GV döndürmeli
	if gv1 != gv2 {
		t.Error("FetchGV should return same GV for same name")
	}
}

// TestLookupGV tests GV lookup without creation.
// TestLookupGV, oluşturmadan GV aramayı test eder.
func TestLookupGV(t *testing.T) {
	s := Get("LookupTest")

	// Before creation
	// Oluşturmadan önce
	if s.LookupGV("nonexistent") != nil {
		t.Error("LookupGV should return nil for nonexistent")
	}

	// After creation
	// Oluşturduktan sonra
	s.FetchGV("created")
	if s.LookupGV("created") == nil {
		t.Error("LookupGV should find created GV")
	}
}

// TestDeleteGV tests GV deletion.
// TestDeleteGV, GV silmeyi test eder.
func TestDeleteGV(t *testing.T) {
	s := Get("DeleteTest")
	s.SetScalar("todelete", sv.NewInt(42))

	// Verify exists
	// Varlığını doğrula
	if s.LookupGV("todelete") == nil {
		t.Error("Should exist before delete")
	}

	s.DeleteGV("todelete")

	// Should be gone
	// Gitmiş olmalı
	if s.LookupGV("todelete") != nil {
		t.Error("Should not exist after delete")
	}
}

// ============================================================
// VERSION Tests
// VERSION Testleri
// ============================================================

// TestVERSION tests $VERSION retrieval.
// TestVERSION, $VERSION almayı test eder.
func TestVERSION(t *testing.T) {
	s := Get("VersionTest")
	s.SetScalar("VERSION", sv.NewString("2.0.0"))

	ver := s.VERSION()
	if ver.AsString() != "2.0.0" {
		t.Errorf("VERSION should be '2.0.0', got '%s'", ver.AsString())
	}
}

// TestVERSIONUndef tests undefined $VERSION.
// TestVERSIONUndef, tanımsız $VERSION'ı test eder.
func TestVERSIONUndef(t *testing.T) {
	s := Get("NoVersionTest")

	ver := s.VERSION()
	if !ver.IsUndef() {
		t.Error("VERSION should be undef when not set")
	}
}

// ============================================================
// Thread Safety Tests
// İş Parçacığı Güvenliği Testleri
// ============================================================

// TestConcurrentAccess tests concurrent stash access.
// TestConcurrentAccess, eşzamanlı stash erişimini test eder.
func TestConcurrentAccess(t *testing.T) {
	done := make(chan bool)

	// Concurrent reads and writes
	// Eşzamanlı okuma ve yazma
	for i := 0; i < 10; i++ {
		go func(n int) {
			s := Get("ConcurrentTest")
			s.SetScalar("var", sv.NewInt(int64(n)))
			_ = s.Scalar("var")
			done <- true
		}(i)
	}

	// Wait for all goroutines
	// Tüm goroutine'leri bekle
	for i := 0; i < 10; i++ {
		<-done
	}
}

// TestConcurrentPackageCreation tests concurrent package creation.
// TestConcurrentPackageCreation, eşzamanlı paket oluşturmayı test eder.
func TestConcurrentPackageCreation(t *testing.T) {
	done := make(chan bool)

	for i := 0; i < 10; i++ {
		go func(n int) {
			// All trying to create same nested package
			// Hepsi aynı iç içe paketi oluşturmaya çalışıyor
			s := Get("Concurrent::Nested::Package")
			_ = s.Name()
			done <- true
		}(i)
	}

	for i := 0; i < 10; i++ {
		<-done
	}

	// Should have created successfully
	// Başarıyla oluşturulmuş olmalı
	if !Exists("Concurrent::Nested::Package") {
		t.Error("Concurrent creation should succeed")
	}
}

// ============================================================
// All Stashes Tests
// Tüm Stash'ler Testleri
// ============================================================

// TestAll tests listing all stashes.
// TestAll, tüm stash'leri listelemeyi test eder.
func TestAll(t *testing.T) {
	// Create some packages
	// Bazı paketler oluştur
	Get("AllTest1")
	Get("AllTest2")

	all := All()
	if len(all) < 3 { // At least main + our 2
		t.Errorf("Should have at least 3 stashes, got %d", len(all))
	}

	// Check main exists
	// main'in var olduğunu kontrol et
	foundMain := false
	for _, name := range all {
		if name == "main" {
			foundMain = true
			break
		}
	}
	if !foundMain {
		t.Error("All() should include 'main'")
	}
}

// ============================================================
// ISA Management Tests
// ISA Yönetimi Testleri
// ============================================================

// TestSetISA tests replacing @ISA entirely.
// TestSetISA, @ISA'yı tamamen değiştirmeyi test eder.
func TestSetISA(t *testing.T) {
	s := Get("SetISATest")
	s.AddISA("Parent1")
	s.AddISA("Parent2")

	// Replace with new list
	// Yeni liste ile değiştir
	s.SetISA([]*sv.SV{sv.NewString("NewParent")})

	isa := s.ISA()
	if len(isa) != 1 {
		t.Errorf("Should have 1 parent, got %d", len(isa))
	}
	if isa[0].AsString() != "NewParent" {
		t.Error("Parent should be NewParent")
	}
}

// TestEmptyISA tests class with no parents.
// TestEmptyISA, üst sınıfsız sınıfı test eder.
func TestEmptyISA(t *testing.T) {
	s := Get("EmptyISATest")

	isa := s.ISA()
	if len(isa) != 0 {
		t.Error("New class should have empty @ISA")
	}

	// Should still isa UNIVERSAL
	// Yine de UNIVERSAL olmalı
	if !s.Isa("UNIVERSAL") {
		t.Error("Even with empty @ISA, should isa UNIVERSAL")
	}
}
```

## File: ./pkg/sv/ops.go
```go
package sv

import (
	"math"
	"strings"
	"unicode/utf8"
)

// ============================================================
// Arithmetic Operations
// ============================================================

// Add performs $a + $b
func Add(a, b *SV) *SV {
	// Check if either operand wants float math
	if needsFloatMath(a) || needsFloatMath(b) {
		return NewFloat(a.AsFloat() + b.AsFloat())
	}
	return NewInt(a.AsInt() + b.AsInt())
}

// Sub performs $a - $b
func Sub(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		return NewFloat(a.AsFloat() - b.AsFloat())
	}
	return NewInt(a.AsInt() - b.AsInt())
}

// Mul performs $a * $b
func Mul(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		return NewFloat(a.AsFloat() * b.AsFloat())
	}
	return NewInt(a.AsInt() * b.AsInt())
}

// Div performs $a / $b (always returns float like Perl)
func Div(a, b *SV) *SV {
	bv := b.AsFloat()
	if bv == 0 {
		// Perl: division by zero is fatal error
		panic("Illegal division by zero")
	}
	return NewFloat(a.AsFloat() / bv)
}

// IntDiv performs int($a / $b) - integer division
func IntDiv(a, b *SV) *SV {
	bv := b.AsInt()
	if bv == 0 {
		panic("Illegal division by zero")
	}
	return NewInt(a.AsInt() / bv)
}

// Mod performs $a % $b
func Mod(a, b *SV) *SV {
	bv := b.AsInt()
	if bv == 0 {
		panic("Illegal modulus zero")
	}
	return NewInt(a.AsInt() % bv)
}

// Pow performs $a ** $b
func Pow(a, b *SV) *SV {
	result := math.Pow(a.AsFloat(), b.AsFloat())
	// Return int if result is whole and fits
	if result == math.Trunc(result) && result >= math.MinInt64 && result <= math.MaxInt64 {
		return NewInt(int64(result))
	}
	return NewFloat(result)
}

// Neg performs -$a (negation)
func Neg(a *SV) *SV {
	if a.typ == TypeFloat || a.flags&FlagNOK != 0 {
		return NewFloat(-a.AsFloat())
	}
	return NewInt(-a.AsInt())
}

// needsFloatMath checks if value requires float arithmetic
func needsFloatMath(sv *SV) bool {
	if sv == nil {
		return false
	}
	if sv.typ == TypeFloat {
		return true
	}
	if sv.typ == TypeString {
		s := sv.pv
		for _, c := range s {
			if c == '.' || c == 'e' || c == 'E' {
				return true
			}
		}
	}
	return false
}

// ============================================================
// Increment/Decrement (Perl's magical ++ and --)
// ============================================================

// Inc performs ++$a (pre-increment) - modifies in place
func Inc(a *SV) *SV {
	a.checkWritable()

	// Perl's magical string increment: "aa" -> "ab", "az" -> "ba", "z9" -> "aa0"
	if a.typ == TypeString && !hasNumericPrefix(a.pv) && isIncrementableString(a.pv) {
		a.pv = incrementString(a.pv)
		a.flags = FlagPOK | FlagUTF8
		return a
	}

	if a.typ == TypeFloat || a.flags&FlagNOK != 0 {
		a.nv = a.AsFloat() + 1
		a.flags = FlagNOK
		a.typ = TypeFloat
	} else {
		a.iv = a.AsInt() + 1
		a.flags = FlagIOK
		a.typ = TypeInt
	}
	return a
}

// Dec performs --$a (pre-decrement) - modifies in place
// Note: -- does NOT do magical string decrement in Perl
func Dec(a *SV) *SV {
	a.checkWritable()

	if a.typ == TypeFloat || a.flags&FlagNOK != 0 {
		a.nv = a.AsFloat() - 1
		a.flags = FlagNOK
		a.typ = TypeFloat
	} else {
		a.iv = a.AsInt() - 1
		a.flags = FlagIOK
		a.typ = TypeInt
	}
	return a
}

// hasNumericPrefix checks if string starts with a number
func hasNumericPrefix(s string) bool {
	s = strings.TrimSpace(s)
	if len(s) == 0 {
		return false
	}
	c := s[0]
	return (c >= '0' && c <= '9') || c == '-' || c == '+' || c == '.'
}

// isIncrementableString checks if string can be magically incremented
func isIncrementableString(s string) bool {
	if s == "" {
		return false
	}
	for _, c := range s {
		if !((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9')) {
			return false
		}
	}
	return true
}

// incrementString performs Perl's magical string increment
func incrementString(s string) string {
	if s == "" {
		return "1"
	}

	runes := []rune(s)
	carry := true

	for i := len(runes) - 1; i >= 0 && carry; i-- {
		c := runes[i]

		switch {
		case c >= 'a' && c < 'z':
			runes[i] = c + 1
			carry = false
		case c == 'z':
			runes[i] = 'a'
		case c >= 'A' && c < 'Z':
			runes[i] = c + 1
			carry = false
		case c == 'Z':
			runes[i] = 'A'
		case c >= '0' && c < '9':
			runes[i] = c + 1
			carry = false
		case c == '9':
			runes[i] = '0'
		default:
			carry = false
		}
	}

	if carry {
		// Need to prepend
		first := runes[0]
		var prefix rune
		switch {
		case first >= 'a' && first <= 'z':
			prefix = 'a'
		case first >= 'A' && first <= 'Z':
			prefix = 'A'
		default:
			prefix = '1'
		}
		runes = append([]rune{prefix}, runes...)
	}

	return string(runes)
}

// ============================================================
// Bitwise Operations
// ============================================================

// BitAnd performs $a & $b
func BitAnd(a, b *SV) *SV {
	return NewInt(a.AsInt() & b.AsInt())
}

// BitOr performs $a | $b
func BitOr(a, b *SV) *SV {
	return NewInt(a.AsInt() | b.AsInt())
}

// BitXor performs $a ^ $b
func BitXor(a, b *SV) *SV {
	return NewInt(a.AsInt() ^ b.AsInt())
}

// BitNot performs ~$a
func BitNot(a *SV) *SV {
	return NewInt(^a.AsInt())
}

// LeftShift performs $a << $b
func LeftShift(a, b *SV) *SV {
	shift := b.AsInt()
	if shift < 0 {
		panic("Negative shift count")
	}
	return NewInt(a.AsInt() << uint(shift))
}

// RightShift performs $a >> $b
func RightShift(a, b *SV) *SV {
	shift := b.AsInt()
	if shift < 0 {
		panic("Negative shift count")
	}
	return NewInt(a.AsInt() >> uint(shift))
}

// ============================================================
// String Operations
// ============================================================

// Concat performs $a . $b (string concatenation)
func Concat(a, b *SV) *SV {
	return NewString(a.AsString() + b.AsString())
}

// Repeat performs $a x $b (string repetition)
func Repeat(a, b *SV) *SV {
	s := a.AsString()
	n := b.AsInt()
	if n <= 0 {
		return NewString("")
	}
	return NewString(strings.Repeat(s, int(n)))
}

// Length returns length($a) - character count for strings
func Length(a *SV) *SV {
	if a == nil || a.typ == TypeUndef {
		return NewUndef()
	}
	s := a.AsString()
	// Perl's length() returns character count, not byte count
	return NewInt(int64(utf8.RuneCountInString(s)))
}

// Substr implements substr($str, $offset, $len)
func Substr(str, offset, length *SV) *SV {
	s := str.AsString()
	runes := []rune(s)
	runeLen := len(runes)

	off := int(offset.AsInt())
	// Negative offset counts from end
	if off < 0 {
		off = runeLen + off
	}
	if off < 0 {
		off = 0
	}
	if off > runeLen {
		return NewString("")
	}

	var ln int
	if length == nil || length.IsUndef() {
		ln = runeLen - off
	} else {
		ln = int(length.AsInt())
		if ln < 0 {
			// Negative length means leave that many chars at end
			ln = runeLen - off + ln
		}
	}

	if ln <= 0 {
		return NewString("")
	}
	if off+ln > runeLen {
		ln = runeLen - off
	}

	return NewString(string(runes[off : off+ln]))
}

// Index implements index($str, $substr, $pos)
func Index(str, substr, pos *SV) *SV {
	s := str.AsString()
	sub := substr.AsString()

	startPos := 0
	if pos != nil && !pos.IsUndef() {
		startPos = int(pos.AsInt())
	}

	// Work with runes for proper Unicode handling
	runes := []rune(s)
	subRunes := []rune(sub)

	if startPos < 0 {
		startPos = 0
	}
	if startPos > len(runes) {
		return NewInt(-1)
	}

	// Simple search
	for i := startPos; i <= len(runes)-len(subRunes); i++ {
		match := true
		for j := 0; j < len(subRunes); j++ {
			if runes[i+j] != subRunes[j] {
				match = false
				break
			}
		}
		if match {
			return NewInt(int64(i))
		}
	}

	return NewInt(-1)
}

// Rindex implements rindex($str, $substr, $pos)
func Rindex(str, substr, pos *SV) *SV {
	s := str.AsString()
	sub := substr.AsString()

	runes := []rune(s)
	subRunes := []rune(sub)

	endPos := len(runes) - len(subRunes)
	if pos != nil && !pos.IsUndef() {
		p := int(pos.AsInt())
		if p < endPos {
			endPos = p
		}
	}

	if endPos < 0 {
		return NewInt(-1)
	}

	// Search backwards
	for i := endPos; i >= 0; i-- {
		match := true
		for j := 0; j < len(subRunes); j++ {
			if runes[i+j] != subRunes[j] {
				match = false
				break
			}
		}
		if match {
			return NewInt(int64(i))
		}
	}

	return NewInt(-1)
}

// Uc implements uc($str) - uppercase
func Uc(a *SV) *SV {
	return NewString(strings.ToUpper(a.AsString()))
}

// Lc implements lc($str) - lowercase
func Lc(a *SV) *SV {
	return NewString(strings.ToLower(a.AsString()))
}

// Ucfirst implements ucfirst($str)
func Ucfirst(a *SV) *SV {
	s := a.AsString()
	if s == "" {
		return NewString("")
	}
	runes := []rune(s)
	runes[0] = []rune(strings.ToUpper(string(runes[0])))[0]
	return NewString(string(runes))
}

// Lcfirst implements lcfirst($str)
func Lcfirst(a *SV) *SV {
	s := a.AsString()
	if s == "" {
		return NewString("")
	}
	runes := []rune(s)
	runes[0] = []rune(strings.ToLower(string(runes[0])))[0]
	return NewString(string(runes))
}

// Reverse implements reverse($str) for scalar context
func Reverse(a *SV) *SV {
	s := a.AsString()
	runes := []rune(s)
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}
	return NewString(string(runes))
}

// ============================================================
// Numeric Comparison Operations
// ============================================================

// NumEq performs $a == $b
func NumEq(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		if a.AsFloat() == b.AsFloat() {
			return NewInt(1)
		}
	} else {
		if a.AsInt() == b.AsInt() {
			return NewInt(1)
		}
	}
	return NewString("") // False
}

// NumNe performs $a != $b
func NumNe(a, b *SV) *SV {
	return Not(NumEq(a, b))
}

// NumLt performs $a < $b
func NumLt(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		if a.AsFloat() < b.AsFloat() {
			return NewInt(1)
		}
	} else {
		if a.AsInt() < b.AsInt() {
			return NewInt(1)
		}
	}
	return NewString("")
}

// NumLe performs $a <= $b
func NumLe(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		if a.AsFloat() <= b.AsFloat() {
			return NewInt(1)
		}
	} else {
		if a.AsInt() <= b.AsInt() {
			return NewInt(1)
		}
	}
	return NewString("")
}

// NumGt performs $a > $b
func NumGt(a, b *SV) *SV {
	return NumLt(b, a)
}

// NumGe performs $a >= $b
func NumGe(a, b *SV) *SV {
	return NumLe(b, a)
}

// NumCmp performs $a <=> $b (spaceship operator)
func NumCmp(a, b *SV) *SV {
	if needsFloatMath(a) || needsFloatMath(b) {
		av, bv := a.AsFloat(), b.AsFloat()
		if math.IsNaN(av) || math.IsNaN(bv) {
			return NewUndef()
		}
		switch {
		case av < bv:
			return NewInt(-1)
		case av > bv:
			return NewInt(1)
		default:
			return NewInt(0)
		}
	}
	av, bv := a.AsInt(), b.AsInt()
	switch {
	case av < bv:
		return NewInt(-1)
	case av > bv:
		return NewInt(1)
	default:
		return NewInt(0)
	}
}

// ============================================================
// String Comparison Operations
// ============================================================

// StrEq performs $a eq $b
func StrEq(a, b *SV) *SV {
	if a.AsString() == b.AsString() {
		return NewInt(1)
	}
	return NewString("")
}

// StrNe performs $a ne $b
func StrNe(a, b *SV) *SV {
	return Not(StrEq(a, b))
}

// StrLt performs $a lt $b
func StrLt(a, b *SV) *SV {
	if a.AsString() < b.AsString() {
		return NewInt(1)
	}
	return NewString("")
}

// StrLe performs $a le $b
func StrLe(a, b *SV) *SV {
	if a.AsString() <= b.AsString() {
		return NewInt(1)
	}
	return NewString("")
}

// StrGt performs $a gt $b
func StrGt(a, b *SV) *SV {
	return StrLt(b, a)
}

// StrGe performs $a ge $b
func StrGe(a, b *SV) *SV {
	return StrLe(b, a)
}

// StrCmp performs $a cmp $b
func StrCmp(a, b *SV) *SV {
	cmp := strings.Compare(a.AsString(), b.AsString())
	return NewInt(int64(cmp))
}

// ============================================================
// Logical Operations
// ============================================================

// Not performs !$a (logical not)
func Not(a *SV) *SV {
	if a.AsBool() {
		return NewString("")
	}
	return NewInt(1)
}

// And performs $a && $b (returns last evaluated value)
func And(a, b *SV) *SV {
	if !a.AsBool() {
		return a
	}
	return b
}

// Or performs $a || $b (returns last evaluated value)
func Or(a, b *SV) *SV {
	if a.AsBool() {
		return a
	}
	return b
}

// DefinedOr performs $a // $b (returns $a if defined, else $b)
func DefinedOr(a, b *SV) *SV {
	if !a.IsUndef() {
		return a
	}
	return b
}

// Defined checks if value is defined
func Defined(a *SV) *SV {
	if a == nil || a.typ == TypeUndef {
		return NewString("")
	}
	return NewInt(1)
}

// ============================================================
// Range Operations
// ============================================================

// Range generates $a .. $b (list of values)
func Range(a, b *SV) []*SV {
	// Numeric range
	if !isStringRange(a, b) {
		start := a.AsInt()
		end := b.AsInt()

		if start > end {
			return []*SV{}
		}

		result := make([]*SV, end-start+1)
		for i := start; i <= end; i++ {
			result[i-start] = NewInt(i)
		}
		return result
	}

	// String range: "aa" .. "az"
	startStr := a.AsString()
	endStr := b.AsString()

	var result []*SV
	current := startStr

	for {
		result = append(result, NewString(current))
		if current == endStr {
			break
		}
		if len(result) > 1000000 { // Safety limit
			break
		}
		current = incrementString(current)
		// Prevent infinite loop if we passed the end
		if len(current) > len(endStr) {
			break
		}
	}

	return result
}

// isStringRange checks if this should be a string range
func isStringRange(a, b *SV) bool {
	if a.typ == TypeString && b.typ == TypeString {
		as, bs := a.pv, b.pv
		return isIncrementableString(as) && isIncrementableString(bs) &&
			!hasNumericPrefix(as) && !hasNumericPrefix(bs)
	}
	return false
}

// ============================================================
// Type Operations
// ============================================================

// Ref returns ref($a) - the reference type as string
func Ref(a *SV) *SV {
	if a == nil || a.typ != TypeRef {
		return NewString("")
	}

	// If blessed, return the class name
	if a.flags&FlagBless != 0 {
		return NewString(a.stash)
	}

	// Otherwise return the type
	if a.rv == nil {
		return NewString("SCALAR")
	}

	switch a.rv.typ {
	case TypeArray:
		return NewString("ARRAY")
	case TypeHash:
		return NewString("HASH")
	case TypeCode:
		return NewString("CODE")
	case TypeGlob:
		return NewString("GLOB")
	case TypeRegex:
		return NewString("Regexp")
	case TypeIO:
		return NewString("IO")
	default:
		return NewString("SCALAR")
	}
}

// Reftype returns reftype($a) - always the underlying type, ignoring blessing
func Reftype(a *SV) *SV {
	if a == nil || a.typ != TypeRef || a.rv == nil {
		return NewUndef()
	}

	switch a.rv.typ {
	case TypeArray:
		return NewString("ARRAY")
	case TypeHash:
		return NewString("HASH")
	case TypeCode:
		return NewString("CODE")
	case TypeGlob:
		return NewString("GLOB")
	case TypeRegex:
		return NewString("Regexp")
	case TypeIO:
		return NewString("IO")
	default:
		return NewString("SCALAR")
	}
}
```

## File: ./pkg/sv/ops_test.go
```go
package sv

import (
	"testing"
)

func floatEq(a, b float64) bool {
	const epsilon = 0.0001
	diff := a - b
	return diff < epsilon && diff > -epsilon
}

func TestArithmetic(t *testing.T) {
	a := NewInt(10)
	b := NewInt(3)

	// Add
	if Add(a, b).AsInt() != 13 {
		t.Errorf("10 + 3 should be 13")
	}

	// Sub
	if Sub(a, b).AsInt() != 7 {
		t.Errorf("10 - 3 should be 7")
	}

	// Mul
	if Mul(a, b).AsInt() != 30 {
		t.Errorf("10 * 3 should be 30")
	}

	// Div (always float)
	if Div(a, b).AsFloat() != 10.0/3.0 {
		t.Errorf("10 / 3 should be %f", 10.0/3.0)
	}

	// Mod
	if Mod(a, b).AsInt() != 1 {
		t.Errorf("10 %% 3 should be 1")
	}

	// Power
	if Pow(NewInt(2), NewInt(10)).AsInt() != 1024 {
		t.Errorf("2 ** 10 should be 1024")
	}
}

func TestFloatArithmetic(t *testing.T) {
	a := NewFloat(3.14)
	b := NewFloat(2.0)

	result := Add(a, b)
	if !floatEq(result.AsFloat(), 5.14) {
		t.Errorf("3.14 + 2.0 should be ~5.14, got %f", result.AsFloat())
	}

	s := NewString("3.5")
	result = Add(NewInt(1), s)
	if !floatEq(result.AsFloat(), 4.5) {
		t.Errorf("1 + '3.5' should be 4.5, got %f", result.AsFloat())
	}
}

func TestStringIncrement(t *testing.T) {
	tests := []struct {
		input string
		want  string
	}{
		{"aa", "ab"},
		{"az", "ba"},
		{"zz", "aaa"},
		{"a9", "b0"},
		{"z9", "aa0"},
		{"A", "B"},
		{"Z", "AA"},
		{"a1", "a2"},
	}

	for _, tt := range tests {
		s := NewString(tt.input)
		Inc(s)
		if got := s.AsString(); got != tt.want {
			t.Errorf("++%q = %q, want %q", tt.input, got, tt.want)
		}
	}
}

func TestNumericIncrement(t *testing.T) {
	// Numeric string increments numerically
	s := NewString("42")
	Inc(s)
	if s.AsInt() != 43 {
		t.Errorf("++'42' should be 43, got %d", s.AsInt())
	}

	// Int
	i := NewInt(10)
	Inc(i)
	if i.AsInt() != 11 {
		t.Errorf("++10 should be 11")
	}

	// Float
	f := NewFloat(1.5)
	Inc(f)
	if f.AsFloat() != 2.5 {
		t.Errorf("++1.5 should be 2.5")
	}
}

func TestConcat(t *testing.T) {
	a := NewString("Hello")
	b := NewString(" World")

	result := Concat(a, b)
	if result.AsString() != "Hello World" {
		t.Errorf("Concat failed: got '%s'", result.AsString())
	}

	// Numbers stringify
	num := NewInt(42)
	result = Concat(NewString("Answer: "), num)
	if result.AsString() != "Answer: 42" {
		t.Errorf("Concat with number failed: got '%s'", result.AsString())
	}
}

func TestRepeat(t *testing.T) {
	s := NewString("ab")
	n := NewInt(3)

	result := Repeat(s, n)
	if result.AsString() != "ababab" {
		t.Errorf("'ab' x 3 should be 'ababab', got '%s'", result.AsString())
	}

	// Zero times
	result = Repeat(s, NewInt(0))
	if result.AsString() != "" {
		t.Errorf("'ab' x 0 should be '', got '%s'", result.AsString())
	}
}

func TestLength(t *testing.T) {
	// ASCII
	s := NewString("hello")
	if Length(s).AsInt() != 5 {
		t.Errorf("length('hello') should be 5")
	}

	// Unicode - length counts characters, not bytes
	u := NewString("привет") // 6 Cyrillic characters
	if Length(u).AsInt() != 6 {
		t.Errorf("length('привет') should be 6, got %d", Length(u).AsInt())
	}

	// Emoji
	e := NewString("👍🎉") // 2 emoji
	if Length(e).AsInt() != 2 {
		t.Errorf("length of 2 emoji should be 2, got %d", Length(e).AsInt())
	}
}

func TestSubstr(t *testing.T) {
	s := NewString("Hello World")

	// Basic substr
	result := Substr(s, NewInt(0), NewInt(5))
	if result.AsString() != "Hello" {
		t.Errorf("substr('Hello World', 0, 5) = '%s', want 'Hello'", result.AsString())
	}

	// Negative offset
	result = Substr(s, NewInt(-5), nil)
	if result.AsString() != "World" {
		t.Errorf("substr('Hello World', -5) = '%s', want 'World'", result.AsString())
	}

	// Negative length
	result = Substr(s, NewInt(0), NewInt(-6))
	if result.AsString() != "Hello" {
		t.Errorf("substr with negative length failed: '%s'", result.AsString())
	}
}

func TestNumericComparison(t *testing.T) {
	a := NewInt(10)
	b := NewInt(20)

	if !NumLt(a, b).AsBool() {
		t.Error("10 < 20 should be true")
	}
	if NumLt(b, a).AsBool() {
		t.Error("20 < 10 should be false")
	}
	if !NumEq(a, NewInt(10)).AsBool() {
		t.Error("10 == 10 should be true")
	}

	// Spaceship
	if NumCmp(a, b).AsInt() != -1 {
		t.Error("10 <=> 20 should be -1")
	}
	if NumCmp(b, a).AsInt() != 1 {
		t.Error("20 <=> 10 should be 1")
	}
	if NumCmp(a, a).AsInt() != 0 {
		t.Error("10 <=> 10 should be 0")
	}
}

func TestStringComparison(t *testing.T) {
	a := NewString("apple")
	b := NewString("banana")

	if !StrLt(a, b).AsBool() {
		t.Error("'apple' lt 'banana' should be true")
	}
	if !StrEq(a, NewString("apple")).AsBool() {
		t.Error("'apple' eq 'apple' should be true")
	}

	// cmp
	if StrCmp(a, b).AsInt() >= 0 {
		t.Error("'apple' cmp 'banana' should be negative")
	}
}

func TestLogical(t *testing.T) {
	tr := NewInt(1)
	fa := NewString("")

	// Not
	if Not(tr).AsBool() {
		t.Error("!1 should be false")
	}
	if !Not(fa).AsBool() {
		t.Error("!'' should be true")
	}

	// And - returns last evaluated
	if And(tr, NewInt(42)).AsInt() != 42 {
		t.Error("1 && 42 should return 42")
	}
	if And(fa, tr).AsString() != "" {
		t.Error("'' && 1 should return ''")
	}

	// Or - returns first true
	if Or(tr, NewInt(42)).AsInt() != 1 {
		t.Error("1 || 42 should return 1")
	}
	if Or(fa, NewInt(42)).AsInt() != 42 {
		t.Error("'' || 42 should return 42")
	}

	// Defined-or
	if DefinedOr(NewUndef(), NewInt(42)).AsInt() != 42 {
		t.Error("undef // 42 should return 42")
	}
	if DefinedOr(NewInt(0), NewInt(42)).AsInt() != 0 {
		t.Error("0 // 42 should return 0 (defined but false)")
	}
}

func TestRange(t *testing.T) {
	// Numeric range
	result := Range(NewInt(1), NewInt(5))
	if len(result) != 5 {
		t.Errorf("1..5 should have 5 elements, got %d", len(result))
	}
	for i, v := range result {
		if v.AsInt() != int64(i+1) {
			t.Errorf("Element %d should be %d, got %d", i, i+1, v.AsInt())
		}
	}

	// String range
	result = Range(NewString("aa"), NewString("ad"))
	if len(result) != 4 {
		t.Errorf("'aa'..'ad' should have 4 elements, got %d", len(result))
	}
	expected := []string{"aa", "ab", "ac", "ad"}
	for i, v := range result {
		if v.AsString() != expected[i] {
			t.Errorf("Element %d should be '%s', got '%s'", i, expected[i], v.AsString())
		}
	}
}

func TestRef(t *testing.T) {
	// Not a reference
	if Ref(NewInt(42)).AsString() != "" {
		t.Error("ref(42) should return empty string")
	}

	// Array ref
	arr := NewArrayRef()
	if Ref(arr).AsString() != "ARRAY" {
		t.Errorf("ref([]) should be 'ARRAY', got '%s'", Ref(arr).AsString())
	}

	// Hash ref
	hash := NewHashRef()
	if Ref(hash).AsString() != "HASH" {
		t.Errorf("ref({}) should be 'HASH', got '%s'", Ref(hash).AsString())
	}

	// Blessed
	hash.Bless("MyClass")
	if Ref(hash).AsString() != "MyClass" {
		t.Errorf("ref(blessed) should be 'MyClass', got '%s'", Ref(hash).AsString())
	}

	// Reftype ignores blessing
	if Reftype(hash).AsString() != "HASH" {
		t.Errorf("reftype(blessed hash) should be 'HASH', got '%s'", Reftype(hash).AsString())
	}
}

func TestBitwiseOps(t *testing.T) {
	if BitAnd(NewInt(0b1100), NewInt(0b1010)).AsInt() != 0b1000 {
		t.Error("Bitwise AND failed")
	}
	if BitOr(NewInt(0b1100), NewInt(0b1010)).AsInt() != 0b1110 {
		t.Error("Bitwise OR failed")
	}
	if BitXor(NewInt(0b1100), NewInt(0b1010)).AsInt() != 0b0110 {
		t.Error("Bitwise XOR failed")
	}
	if LeftShift(NewInt(1), NewInt(4)).AsInt() != 16 {
		t.Error("Left shift failed")
	}
	if RightShift(NewInt(16), NewInt(2)).AsInt() != 4 {
		t.Error("Right shift failed")
	}
}
```

## File: ./pkg/sv/sv.go
```go
// Package sv implements Perl's scalar value (SV) type system.
// This is the foundation of the entire runtime - every value in Perl is an SV.
package sv

import (
	"fmt"
	"math"
	"strconv"
	"strings"
	"sync/atomic"
	"unicode/utf8"
	"unsafe"
)

// Type represents the primary type of an SV
type Type uint8

const (
	TypeUndef  Type = iota
	TypeInt         // IV - integer value
	TypeFloat       // NV - numeric value (float64)
	TypeString      // PV - pointer value (string)
	TypeRef         // RV - reference to another SV
	TypeArray       // AV - array value ([]SV)
	TypeHash        // HV - hash value (map[string]SV)
	TypeCode        // CV - code value (subroutine)
	TypeGlob        // GV - glob value (*foo)
	TypeRegex       // Compiled regex
	TypeIO          // IO handle
)

// Flags для SV - определяют какие представления валидны
type Flags uint32

const (
	FlagIOK   Flags = 1 << iota // Integer value is valid
	FlagNOK                     // Numeric (float) value is valid
	FlagPOK                     // String value is valid
	FlagROK                     // Reference value is valid
	FlagUTF8                    // String is UTF-8 encoded
	FlagRO                      // Read-only
	FlagTemp                    // Temporary (mortal)
	FlagBless                   // Blessed into a package
	FlagWeak                    // Weak reference
	FlagTied                    // Tied variable
)

// SV is the core scalar value type, similar to Perl's internal SV structure.
// Every value in Perl (scalars, array elements, hash values) is an SV.
type SV struct {
	typ    Type
	flags  Flags
	refcnt uint32

	// Cached representations - Perl keeps multiple valid at once
	iv     int64   // Integer cache
	nv     float64 // Float cache
	pv     string  // String cache (Go strings are immutable, good for us)
	pvUTF8 bool    // pv contains valid UTF-8

	// For references and complex types
	rv *SV            // Referenced SV (when TypeRef)
	av []*SV          // Array storage (when TypeArray)
	hv map[string]*SV // Hash storage (when TypeHash)

	// For blessed references
	stash string // Package name if blessed

	// For tied variables
	tiedObj *SV // The tie object

	// Magic callbacks (simplified for now)
	magic []Magic
}

// Magic represents magical behavior attached to an SV
type Magic struct {
	Type  byte
	Flags uint32
	Obj   *SV // Associated object
	Get   func(*SV) *SV
	Set   func(*SV, *SV)
}

// ============================================================
// Constructors
// ============================================================

// NewUndef creates an undefined SV
func NewUndef() *SV {
	return &SV{typ: TypeUndef, refcnt: 1}
}

// NewInt creates an integer SV
func NewInt(v int64) *SV {
	return &SV{
		typ:    TypeInt,
		flags:  FlagIOK,
		refcnt: 1,
		iv:     v,
	}
}

// NewFloat creates a float SV
func NewFloat(v float64) *SV {
	return &SV{
		typ:    TypeFloat,
		flags:  FlagNOK,
		refcnt: 1,
		nv:     v,
	}
}

// NewString creates a string SV
func NewString(v string) *SV {
	flags := FlagPOK
	if utf8.ValidString(v) {
		flags |= FlagUTF8
	}
	return &SV{
		typ:    TypeString,
		flags:  flags,
		refcnt: 1,
		pv:     v,
		pvUTF8: utf8.ValidString(v),
	}
}

// NewRef creates a reference to another SV
func NewRef(target *SV) *SV {
	if target != nil {
		target.IncRef()
	}
	return &SV{
		typ:    TypeRef,
		flags:  FlagROK,
		refcnt: 1,
		rv:     target,
	}
}

// NewArrayRef creates a reference to a new array
func NewArrayRef(elements ...*SV) *SV {
	av := &SV{
		typ:    TypeArray,
		refcnt: 1,
		av:     make([]*SV, len(elements)),
	}
	for i, el := range elements {
		if el != nil {
			el.IncRef()
		}
		av.av[i] = el
	}
	return NewRef(av)
}

// NewHashRef creates a reference to a new hash
func NewHashRef() *SV {
	hv := &SV{
		typ:    TypeHash,
		refcnt: 1,
		hv:     make(map[string]*SV),
	}
	return NewRef(hv)
}

// ============================================================
// Reference Counting
// ============================================================

// IncRef increments reference count
func (sv *SV) IncRef() {
	if sv != nil {
		atomic.AddUint32(&sv.refcnt, 1)
	}
}

// DecRef decrements reference count and frees if zero
func (sv *SV) DecRef() {
	if sv == nil {
		return
	}
	if atomic.AddUint32(&sv.refcnt, ^uint32(0)) == 0 {
		sv.free()
	}
}

// RefCount returns current reference count
func (sv *SV) RefCount() uint32 {
	if sv == nil {
		return 0
	}
	return atomic.LoadUint32(&sv.refcnt)
}

// free releases all resources held by this SV
func (sv *SV) free() {
	// Decref any referenced SVs
	if sv.rv != nil {
		sv.rv.DecRef()
		sv.rv = nil
	}
	for _, el := range sv.av {
		if el != nil {
			el.DecRef()
		}
	}
	sv.av = nil
	for _, el := range sv.hv {
		if el != nil {
			el.DecRef()
		}
	}
	sv.hv = nil

	// Clear magic
	sv.magic = nil
}

// ============================================================
// Type Checking
// ============================================================

func (sv *SV) Type() Type      { return sv.typ }
func (sv *SV) IsUndef() bool   { return sv == nil || sv.typ == TypeUndef }
func (sv *SV) IsRef() bool     { return sv != nil && sv.typ == TypeRef }
func (sv *SV) IsArray() bool   { return sv != nil && sv.typ == TypeArray }
func (sv *SV) IsHash() bool    { return sv != nil && sv.typ == TypeHash }
func (sv *SV) IsCode() bool    { return sv != nil && sv.typ == TypeCode }
func (sv *SV) IsBlessed() bool { return sv != nil && sv.flags&FlagBless != 0 }

// Deref dereferences a reference, returns nil if not a ref
func (sv *SV) Deref() *SV {
	if sv == nil || sv.typ != TypeRef {
		return nil
	}
	return sv.rv
}

// ============================================================
// Value Coercion - The Heart of Perl's Type System
// ============================================================

// AsInt returns integer value, coercing if necessary (Perl's SvIV)
func (sv *SV) AsInt() int64 {
	if sv == nil {
		return 0
	}

	// Already have valid integer?
	if sv.flags&FlagIOK != 0 {
		return sv.iv
	}

	switch sv.typ {
	case TypeUndef:
		return 0
	case TypeInt:
		return sv.iv
	case TypeFloat:
		sv.iv = int64(sv.nv)
		sv.flags |= FlagIOK
		return sv.iv
	case TypeString:
		sv.iv = stringToInt(sv.pv)
		sv.flags |= FlagIOK
		return sv.iv
	case TypeRef:
		// Reference as integer = memory address (we fake it)
		return int64(uintptr(unsafe.Pointer(sv.rv)))
	case TypeArray:
		// Array in scalar context = length
		return int64(len(sv.av))
	case TypeHash:
		// Hash in scalar context = "used/buckets" fraction, we return count
		return int64(len(sv.hv))
	default:
		return 0
	}
}

// AsFloat returns float value, coercing if necessary (Perl's SvNV)
func (sv *SV) AsFloat() float64 {
	if sv == nil {
		return 0.0
	}

	if sv.flags&FlagNOK != 0 {
		return sv.nv
	}

	switch sv.typ {
	case TypeUndef:
		return 0.0
	case TypeInt:
		sv.nv = float64(sv.iv)
		sv.flags |= FlagNOK
		return sv.nv
	case TypeFloat:
		return sv.nv
	case TypeString:
		sv.nv = stringToFloat(sv.pv)
		sv.flags |= FlagNOK
		return sv.nv
	default:
		return 0.0
	}
}

// AsString returns string value, coercing if necessary (Perl's SvPV)
func (sv *SV) AsString() string {
	if sv == nil {
		return ""
	}

	if sv.flags&FlagPOK != 0 {
		return sv.pv
	}

	switch sv.typ {
	case TypeUndef:
		return ""
	case TypeInt:
		sv.pv = strconv.FormatInt(sv.iv, 10)
		sv.flags |= FlagPOK | FlagUTF8
		sv.pvUTF8 = true
		return sv.pv
	case TypeFloat:
		sv.pv = formatFloat(sv.nv)
		sv.flags |= FlagPOK | FlagUTF8
		sv.pvUTF8 = true
		return sv.pv
	case TypeRef:
		return sv.refString()
	case TypeArray:
		return fmt.Sprintf("ARRAY(0x%x)", uintptr(unsafe.Pointer(sv)))
	case TypeHash:
		return fmt.Sprintf("HASH(0x%x)", uintptr(unsafe.Pointer(sv)))
	case TypeCode:
		return fmt.Sprintf("CODE(0x%x)", uintptr(unsafe.Pointer(sv)))
	default:
		return ""
	}
}

// AsBool returns boolean value (Perl's SvTRUE)
func (sv *SV) AsBool() bool {
	if sv == nil || sv.typ == TypeUndef {
		return false
	}

	switch sv.typ {
	case TypeInt:
		return sv.iv != 0
	case TypeFloat:
		return sv.nv != 0.0 && !math.IsNaN(sv.nv)
	case TypeString:
		// Perl: "" and "0" are false, everything else is true
		return sv.pv != "" && sv.pv != "0"
	case TypeRef:
		// References are always true
		return true
	case TypeArray:
		return len(sv.av) > 0
	case TypeHash:
		return len(sv.hv) > 0
	default:
		return false
	}
}

// refString returns the string representation of a reference
func (sv *SV) refString() string {
	if sv.rv == nil {
		return "REF(0x0)"
	}

	target := sv.rv
	prefix := ""

	if sv.flags&FlagBless != 0 {
		prefix = sv.stash + "="
	}

	switch target.typ {
	case TypeArray:
		return fmt.Sprintf("%sARRAY(0x%x)", prefix, uintptr(unsafe.Pointer(target)))
	case TypeHash:
		return fmt.Sprintf("%sHASH(0x%x)", prefix, uintptr(unsafe.Pointer(target)))
	case TypeCode:
		return fmt.Sprintf("%sCODE(0x%x)", prefix, uintptr(unsafe.Pointer(target)))
	default:
		return fmt.Sprintf("%sSCALAR(0x%x)", prefix, uintptr(unsafe.Pointer(target)))
	}
}

// ============================================================
// String-to-Number Conversion (Perl semantics)
// ============================================================

// stringToInt converts string to int with Perl semantics
// "42abc" -> 42, "abc" -> 0, "  123  " -> 123
func stringToInt(s string) int64 {
	s = strings.TrimSpace(s)
	if s == "" {
		return 0
	}

	// Find numeric prefix
	end := 0
	if len(s) > 0 && (s[0] == '-' || s[0] == '+') {
		end = 1
	}
	for end < len(s) && s[end] >= '0' && s[end] <= '9' {
		end++
	}

	if end == 0 || (end == 1 && (s[0] == '-' || s[0] == '+')) {
		return 0
	}

	v, _ := strconv.ParseInt(s[:end], 10, 64)
	return v
}

// stringToFloat converts string to float with Perl semantics
func stringToFloat(s string) float64 {
	s = strings.TrimSpace(s)
	if s == "" {
		return 0.0
	}

	// Try parsing as float, accepting partial matches
	// This is simplified - real Perl is more complex
	end := 0
	sawDot := false
	sawE := false

	if len(s) > 0 && (s[0] == '-' || s[0] == '+') {
		end = 1
	}

	for end < len(s) {
		c := s[end]
		if c >= '0' && c <= '9' {
			end++
		} else if c == '.' && !sawDot && !sawE {
			sawDot = true
			end++
		} else if (c == 'e' || c == 'E') && !sawE && end > 0 {
			sawE = true
			end++
			if end < len(s) && (s[end] == '+' || s[end] == '-') {
				end++
			}
		} else {
			break
		}
	}

	if end == 0 {
		return 0.0
	}

	v, _ := strconv.ParseFloat(s[:end], 64)
	return v
}

// formatFloat formats a float like Perl does
func formatFloat(v float64) string {
	if math.IsInf(v, 1) {
		return "Inf"
	}
	if math.IsInf(v, -1) {
		return "-Inf"
	}
	if math.IsNaN(v) {
		return "NaN"
	}

	// If it's a whole number, format without decimal
	if v == math.Trunc(v) && math.Abs(v) < 1e15 {
		return strconv.FormatInt(int64(v), 10)
	}

	// Otherwise use %g style formatting
	s := strconv.FormatFloat(v, 'g', -1, 64)
	return s
}

// ============================================================
// Setters - Modify SV value
// ============================================================

// SetInt sets integer value
func (sv *SV) SetInt(v int64) {
	sv.checkWritable()
	sv.typ = TypeInt
	sv.iv = v
	sv.flags = FlagIOK
	// Invalidate other caches
	sv.pv = ""
	sv.nv = 0
}

// SetFloat sets float value
func (sv *SV) SetFloat(v float64) {
	sv.checkWritable()
	sv.typ = TypeFloat
	sv.nv = v
	sv.flags = FlagNOK
	sv.pv = ""
	sv.iv = 0
}

// SetString sets string value
func (sv *SV) SetString(v string) {
	sv.checkWritable()
	sv.typ = TypeString
	sv.pv = v
	sv.flags = FlagPOK
	if utf8.ValidString(v) {
		sv.flags |= FlagUTF8
		sv.pvUTF8 = true
	}
	sv.iv = 0
	sv.nv = 0
}

// SetUndef sets to undefined
func (sv *SV) SetUndef() {
	sv.checkWritable()
	sv.typ = TypeUndef
	sv.flags = 0
	sv.iv = 0
	sv.nv = 0
	sv.pv = ""
	if sv.rv != nil {
		sv.rv.DecRef()
		sv.rv = nil
	}
}

// SetRef sets as reference to target
func (sv *SV) SetRef(target *SV) {
	sv.checkWritable()
	if sv.rv != nil {
		sv.rv.DecRef()
	}
	sv.typ = TypeRef
	sv.flags = FlagROK
	sv.rv = target
	if target != nil {
		target.IncRef()
	}
}

func (sv *SV) checkWritable() {
	if sv.flags&FlagRO != 0 {
		panic("Modification of a read-only value attempted")
	}
}

// ============================================================
// Blessing (OOP)
// ============================================================

// Bless blesses the reference into a package
func (sv *SV) Bless(pkg string) *SV {
	if sv.typ != TypeRef {
		panic("Can't bless non-reference value")
	}
	sv.stash = pkg
	sv.flags |= FlagBless
	return sv
}

// Package returns the package name if blessed, empty string otherwise
func (sv *SV) Package() string {
	if sv.flags&FlagBless == 0 {
		return ""
	}
	return sv.stash
}

// Isa checks if this blessed reference is-a given package
// TODO: Needs stash integration for inheritance checking
func (sv *SV) Isa(pkg string) bool {
	if sv.flags&FlagBless == 0 {
		return false
	}
	return sv.stash == pkg // Simple check, full implementation needs @ISA
}

// ============================================================
// Internal Data Access (for av/hv packages)
// ============================================================

// ArrayData returns the underlying array slice
func (sv *SV) ArrayData() []*SV {
	if sv == nil || sv.typ != TypeArray {
		return nil
	}
	return sv.av
}

// SetArrayData sets the underlying array slice
func (sv *SV) SetArrayData(data []*SV) {
	if sv == nil || sv.typ != TypeArray {
		return
	}
	sv.av = data
}

// HashData returns the underlying hash map
func (sv *SV) HashData() map[string]*SV {
	if sv == nil || sv.typ != TypeHash {
		return nil
	}
	return sv.hv
}

// SetHashData sets the underlying hash map
func (sv *SV) SetHashData(data map[string]*SV) {
	if sv == nil || sv.typ != TypeHash {
		return
	}
	sv.hv = data
}

// ============================================================
// Copy and Clone
// ============================================================

// Copy creates a shallow copy of the SV value (not references)
func (sv *SV) Copy() *SV {
	if sv == nil {
		return NewUndef()
	}

	cp := &SV{
		typ:    sv.typ,
		flags:  sv.flags &^ (FlagRO | FlagTemp), // Clear RO and Temp
		refcnt: 1,
		iv:     sv.iv,
		nv:     sv.nv,
		pv:     sv.pv,
		pvUTF8: sv.pvUTF8,
		stash:  sv.stash,
	}

	// For refs, copy the reference (not deep copy)
	if sv.rv != nil {
		cp.rv = sv.rv
		cp.rv.IncRef()
	}

	// For arrays and hashes, share the underlying storage (ref semantics)
	cp.av = sv.av
	cp.hv = sv.hv

	return cp
}

// CopyFrom copies the value from another SV into this one
func (sv *SV) CopyFrom(src *SV) {
	if sv == nil || src == nil {
		return
	}
	sv.checkWritable()

	sv.typ = src.typ
	sv.flags = src.flags &^ (FlagRO | FlagTemp)
	sv.iv = src.iv
	sv.nv = src.nv
	sv.pv = src.pv
	sv.pvUTF8 = src.pvUTF8
	sv.stash = src.stash

	// Handle reference
	if sv.rv != nil {
		sv.rv.DecRef()
	}
	if src.rv != nil {
		sv.rv = src.rv
		sv.rv.IncRef()
	} else {
		sv.rv = nil
	}

	// Share array/hash data
	sv.av = src.av
	sv.hv = src.hv
}

// ============================================================
// Debug
// ============================================================

func (sv *SV) String() string {
	if sv == nil {
		return "SV{nil}"
	}
	return fmt.Sprintf("SV{type=%v, flags=0x%x, val=%q}", sv.typ, sv.flags, sv.AsString())
}

// IsTrue returns true if value is truthy (alias for AsBool)
func (sv *SV) IsTrue() bool {
	return sv.AsBool()
}

// RefType returns the reference type as string
func (sv *SV) RefType() string {
	return Ref(sv).AsString()
}

func (t Type) String() string {
	names := []string{"undef", "int", "float", "string", "ref", "array", "hash", "code", "glob", "regex", "io"}
	if int(t) < len(names) {
		return names[t]
	}
	return fmt.Sprintf("unknown(%d)", t)
}
```

## File: ./pkg/sv/sv_test.go
```go
package sv

import (
	"testing"
)

func TestNewTypes(t *testing.T) {
	// Test undef
	u := NewUndef()
	if !u.IsUndef() {
		t.Error("NewUndef should be undef")
	}
	if u.AsBool() {
		t.Error("undef should be false")
	}

	// Test int
	i := NewInt(42)
	if i.AsInt() != 42 {
		t.Errorf("Expected 42, got %d", i.AsInt())
	}
	if i.AsString() != "42" {
		t.Errorf("Expected '42', got '%s'", i.AsString())
	}
	if !i.AsBool() {
		t.Error("42 should be true")
	}

	// Test zero
	z := NewInt(0)
	if z.AsBool() {
		t.Error("0 should be false")
	}

	// Test float
	f := NewFloat(3.14)
	if f.AsFloat() != 3.14 {
		t.Errorf("Expected 3.14, got %f", f.AsFloat())
	}

	// Test string
	s := NewString("hello")
	if s.AsString() != "hello" {
		t.Errorf("Expected 'hello', got '%s'", s.AsString())
	}

	// Empty string is false
	es := NewString("")
	if es.AsBool() {
		t.Error("Empty string should be false")
	}

	// "0" is false!
	zs := NewString("0")
	if zs.AsBool() {
		t.Error("String '0' should be false in Perl")
	}
}

func TestStringCoercion(t *testing.T) {
	tests := []struct {
		input     string
		wantInt   int64
		wantFloat float64
	}{
		{"42", 42, 42.0},
		{"  42  ", 42, 42.0},
		{"42abc", 42, 42.0},
		{"abc", 0, 0.0},
		{"-17", -17, -17.0},
		{"3.14", 3, 3.14},
		{"1e5", 1, 100000.0},
		{"", 0, 0.0},
	}

	for _, tt := range tests {
		s := NewString(tt.input)
		if got := s.AsInt(); got != tt.wantInt {
			t.Errorf("AsInt(%q) = %d, want %d", tt.input, got, tt.wantInt)
		}
		if got := s.AsFloat(); got != tt.wantFloat {
			t.Errorf("AsFloat(%q) = %f, want %f", tt.input, got, tt.wantFloat)
		}
	}
}

func TestReferences(t *testing.T) {
	// Scalar ref
	scalar := NewInt(42)
	ref := NewRef(scalar)

	if !ref.IsRef() {
		t.Error("Should be a reference")
	}

	deref := ref.Deref()
	if deref.AsInt() != 42 {
		t.Errorf("Deref should give 42, got %d", deref.AsInt())
	}

	// Modifying through reference
	deref.SetInt(100)
	if scalar.AsInt() != 100 {
		t.Errorf("Original should be modified to 100, got %d", scalar.AsInt())
	}
}

func TestArrayRef(t *testing.T) {
	arr := NewArrayRef(NewInt(1), NewString("hello"), NewFloat(3.14))

	if !arr.IsRef() {
		t.Error("Should be a reference")
	}

	deref := arr.Deref()
	if !deref.IsArray() {
		t.Error("Deref should be array")
	}

	data := deref.ArrayData()
	if len(data) != 3 {
		t.Errorf("Array should have 3 elements, got %d", len(data))
	}

	if data[0].AsInt() != 1 {
		t.Errorf("First element should be 1, got %d", data[0].AsInt())
	}
	if data[1].AsString() != "hello" {
		t.Errorf("Second element should be 'hello', got '%s'", data[1].AsString())
	}
}

func TestBlessing(t *testing.T) {
	hash := NewHashRef()
	hash.Bless("MyClass")

	if !hash.IsBlessed() {
		t.Error("Should be blessed")
	}
	if hash.Package() != "MyClass" {
		t.Errorf("Package should be 'MyClass', got '%s'", hash.Package())
	}
	if !hash.Isa("MyClass") {
		t.Error("Should isa MyClass")
	}

	// String representation should include class
	s := hash.AsString()
	if s[:8] != "MyClass=" {
		t.Errorf("Blessed ref string should start with class name, got '%s'", s)
	}
}

func TestRefCount(t *testing.T) {
	sv := NewInt(42)
	if sv.RefCount() != 1 {
		t.Errorf("Initial refcount should be 1, got %d", sv.RefCount())
	}

	sv.IncRef()
	if sv.RefCount() != 2 {
		t.Errorf("After incref should be 2, got %d", sv.RefCount())
	}

	sv.DecRef()
	if sv.RefCount() != 1 {
		t.Errorf("After decref should be 1, got %d", sv.RefCount())
	}
}
```

## File: ./pkg/xs2go/translator.go
```go
// pkg/xs2go/translator.go
package xs2go

import (
	"fmt"
	"os"
	"perlc/pkg/c2go"
	"regexp"
	"strings"
)

type Translator struct {
	input     string
	output    strings.Builder
	functions map[string]*XSFunction
	module    string
	package_  string
}

type XSArg struct {
	Name string
	Type string
}

type XSFunction struct {
	Name       string
	ReturnType string
	Args       []XSArg
	Code       string
	OutputVar  string
}

func New() *Translator {
	return &Translator{
		functions: make(map[string]*XSFunction),
	}
}

func (t *Translator) Translate(xsFile string) (string, error) {
	content, err := os.ReadFile(xsFile)
	if err != nil {
		return "", err
	}

	t.input = string(content)

	// Парсим XS
	if err := t.parseXS(); err != nil {
		return "", err
	}

	// Генерируем Go
	t.generateHeader()

	for _, fn := range t.functions {
		t.translateFunction(fn)
	}

	t.generateInit()

	return t.output.String(), nil
}

func (t *Translator) parseXS() error {
	content := t.input

	// Удаляем C комментарии /* ... */
	commentRe := regexp.MustCompile(`(?s)/\*.*?\*/`)
	content = commentRe.ReplaceAllString(content, "")

	// Удаляем #include, #define и другие директивы
	preprocessorRe := regexp.MustCompile(`(?m)^#\s*(include|define|ifdef|ifndef|endif|else|elif|if|undef).*$`)
	content = preprocessorRe.ReplaceAllString(content, "")

	// Удаляем typedef и struct
	typedefRe := regexp.MustCompile(`(?s)typedef\s+(?:struct|enum)?\s*\{[^}]*\}[^;]*;`)
	content = typedefRe.ReplaceAllString(content, "")

	structRe := regexp.MustCompile(`(?s)struct\s+\w+\s*\{[^}]*\}\s*;`)
	content = structRe.ReplaceAllString(content, "")

	// Парсим MODULE = ... PACKAGE = ...
	moduleRe := regexp.MustCompile(`MODULE\s*=\s*(\S+)\s+PACKAGE\s*=\s*(\S+)`)
	if matches := moduleRe.FindStringSubmatch(content); len(matches) >= 3 {
		t.module = matches[1]
		t.package_ = matches[2]
	}

	// Находим начало XS секции (после MODULE =)
	moduleIdx := strings.Index(content, "MODULE =")
	if moduleIdx == -1 {
		return nil
	}
	xsContent := content[moduleIdx:]

	// Ищем функции в двух форматах:
	// Формат 1: тип и имя на одной строке - "int add(a, b)"
	// Формат 2: тип на отдельной строке - "SV *\nhello(name)"

	// Формат 2: тип на отдельной строке (XS стиль)
	funcRe2 := regexp.MustCompile(`(?m)^(\w+\s*\*?)\s*\n(\w+)\s*\(([^)]*)\)`)
	matches2 := funcRe2.FindAllStringSubmatchIndex(xsContent, -1)

	for i, match := range matches2 {
		if len(match) < 8 {
			continue
		}

		returnType := strings.TrimSpace(xsContent[match[2]:match[3]])
		funcName := strings.TrimSpace(xsContent[match[4]:match[5]])
		argsStr := strings.TrimSpace(xsContent[match[6]:match[7]])

		funcStart := match[0]
		funcEnd := len(xsContent)
		if i+1 < len(matches2) {
			funcEnd = matches2[i+1][0]
		}

		funcBody := xsContent[funcStart:funcEnd]

		fn := t.parseXSFunction(returnType, funcName, argsStr, funcBody)
		if fn != nil && fn.Name != "" {
			t.functions[fn.Name] = fn
		}
	}

	// Формат 1: тип и имя на одной строке (fallback)
	funcRe1 := regexp.MustCompile(`(?m)^(\w+)\s+(\w+)\s*\(([^)]*)\)`)
	matches1 := funcRe1.FindAllStringSubmatchIndex(xsContent, -1)

	for i, match := range matches1 {
		if len(match) < 8 {
			continue
		}

		returnType := xsContent[match[2]:match[3]]
		funcName := xsContent[match[4]:match[5]]
		argsStr := xsContent[match[6]:match[7]]

		// Пропускаем если уже нашли эту функцию
		if _, exists := t.functions[funcName]; exists {
			continue
		}

		funcStart := match[0]
		funcEnd := len(xsContent)
		if i+1 < len(matches1) {
			funcEnd = matches1[i+1][0]
		}

		funcBody := xsContent[funcStart:funcEnd]

		fn := t.parseXSFunction(returnType, funcName, argsStr, funcBody)
		if fn != nil && fn.Name != "" {
			t.functions[fn.Name] = fn
		}
	}

	return nil
}

func (t *Translator) parseXSFunction(returnType, funcName, argsStr, body string) *XSFunction {
	// Пропускаем служебные функции
	if t.isSkippable(funcName, "") {
		return nil
	}

	// Пропускаем если это не XS функция (нет PPCODE: или CODE:)
	hasPPCode := strings.Contains(body, "PPCODE:")
	hasCode := strings.Contains(body, "CODE:")

	if !hasPPCode && !hasCode {
		return nil
	}

	fn := &XSFunction{
		ReturnType: strings.TrimSpace(returnType),
		Name:       strings.TrimSpace(funcName),
	}

	// Получаем имена аргументов из сигнатуры
	argNames := []string{}
	if argsStr != "" {
		for _, arg := range strings.Split(argsStr, ",") {
			arg = strings.TrimSpace(arg)
			if arg != "" {
				argNames = append(argNames, arg)
			}
		}
	}

	if hasPPCode {
		// Извлекаем код после PPCODE:
		idx := strings.Index(body, "PPCODE:")
		if idx != -1 {
			// Парсим типы аргументов из части до PPCODE:
			beforeCode := body[:idx]
			fn.Args = t.parseArgTypes(beforeCode, argNames)

			code := body[idx+len("PPCODE:"):]
			fn.Code = t.cleanPPCode(code)
		}
	} else if hasCode {
		codeIdx := strings.Index(body, "CODE:")
		outputIdx := strings.Index(body, "OUTPUT:")

		if codeIdx != -1 {
			// Парсим типы аргументов из части до CODE:
			beforeCode := body[:codeIdx]
			fn.Args = t.parseArgTypes(beforeCode, argNames)

			codeStart := codeIdx + len("CODE:")
			codeEnd := len(body)
			if outputIdx != -1 && outputIdx > codeIdx {
				codeEnd = outputIdx
			}
			fn.Code = strings.TrimSpace(body[codeStart:codeEnd])
		}

		// Извлекаем OUTPUT переменную
		if outputIdx != -1 {
			outputSection := body[outputIdx+len("OUTPUT:"):]
			lines := strings.Split(outputSection, "\n")
			for _, line := range lines {
				line = strings.TrimSpace(line)
				if line != "" && !strings.Contains(line, ":") {
					fn.OutputVar = line
					break
				}
			}
		}
	}

	// Если типы не найдены, используем SV* по умолчанию
	if len(fn.Args) == 0 && len(argNames) > 0 {
		for _, name := range argNames {
			fn.Args = append(fn.Args, XSArg{
				Type: "SV *",
				Name: name,
			})
		}
	}

	return fn
}

// parseArgTypes парсит типы аргументов из секции между сигнатурой и CODE:
func (t *Translator) parseArgTypes(section string, argNames []string) []XSArg {
	var args []XSArg

	lines := strings.Split(section, "\n")

	// Создаём map для быстрого поиска
	argSet := make(map[string]bool)
	for _, name := range argNames {
		argSet[name] = true
	}

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// Пропускаем если это сигнатура функции
		if strings.Contains(line, "(") && strings.Contains(line, ")") {
			continue
		}

		// Формат: "int a" или "SV *name" или "char *str"
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			varName := parts[len(parts)-1]
			varName = strings.TrimPrefix(varName, "*")

			// Проверяем что это один из наших аргументов
			if argSet[varName] {
				typeName := strings.Join(parts[:len(parts)-1], " ")
				if strings.HasPrefix(parts[len(parts)-1], "*") {
					typeName += " *"
				}
				args = append(args, XSArg{
					Type: typeName,
					Name: varName,
				})
			}
		}
	}

	// Сохраняем порядок аргументов как в сигнатуре
	orderedArgs := make([]XSArg, 0, len(argNames))
	argMap := make(map[string]XSArg)
	for _, arg := range args {
		argMap[arg.Name] = arg
	}

	for _, name := range argNames {
		if arg, ok := argMap[name]; ok {
			orderedArgs = append(orderedArgs, arg)
		} else {
			// Тип не найден - используем SV* по умолчанию
			orderedArgs = append(orderedArgs, XSArg{
				Type: "SV *",
				Name: name,
			})
		}
	}

	return orderedArgs
}

func (t *Translator) parseXSArgs(argsStr string) []XSArg {
	var args []XSArg

	if argsStr == "" {
		return args
	}

	parts := strings.Split(argsStr, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		// Убираем значение по умолчанию: "int enable = 1" -> "int enable"
		if idx := strings.Index(part, "="); idx != -1 {
			part = strings.TrimSpace(part[:idx])
		}

		tokens := strings.Fields(part)
		if len(tokens) >= 2 {
			varName := tokens[len(tokens)-1]
			varName = strings.TrimPrefix(varName, "*")
			typeName := strings.Join(tokens[:len(tokens)-1], " ")

			// Если * было в имени, добавляем к типу
			if strings.HasPrefix(tokens[len(tokens)-1], "*") {
				typeName += " *"
			}

			args = append(args, XSArg{
				Type: typeName,
				Name: varName,
			})
		} else if len(tokens) == 1 {
			// Только имя без типа - предполагаем SV*
			args = append(args, XSArg{
				Type: "SV *",
				Name: tokens[0],
			})
		}
	}

	return args
}

func (t *Translator) cleanPPCode(code string) string {
	lines := strings.Split(code, "\n")
	var cleaned []string

	inAlias := false
	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Пропускаем пустые строки в начале
		if len(cleaned) == 0 && trimmed == "" {
			continue
		}

		// Пропускаем ALIAS: секции
		if strings.HasPrefix(trimmed, "ALIAS:") {
			inAlias = true
			continue
		}
		if inAlias {
			// ALIAS строки имеют формат "name = VALUE"
			if regexp.MustCompile(`^\w+\s*=\s*\w+$`).MatchString(trimmed) {
				continue
			}
			inAlias = false
		}

		// Пропускаем ATTRS:
		if strings.HasPrefix(trimmed, "ATTRS:") {
			continue
		}

		// Останавливаемся на следующей функции
		if regexp.MustCompile(`^\w+\s+\w+\s*\(`).MatchString(trimmed) {
			break
		}

		cleaned = append(cleaned, trimmed)
	}

	return strings.Join(cleaned, "\n")
}

func (t *Translator) parsePPCodeFunction(match []string) *XSFunction {
	returnType := strings.TrimSpace(match[1])
	funcName := strings.TrimSpace(match[2])
	argsStr := strings.TrimSpace(match[3])
	body := match[4]

	// Пропускаем служебные функции
	if t.isSkippable(funcName, "") {
		return nil
	}

	fn := &XSFunction{
		ReturnType: returnType,
		Name:       funcName,
		OutputVar:  "", // PPCODE не использует RETVAL
	}

	// Парсим аргументы
	fn.Args = t.parseXSArgs(argsStr)

	// Очищаем код
	fn.Code = t.cleanPPCode(body)

	return fn
}

func (t *Translator) parseCodeFunction(match []string) *XSFunction {
	returnType := strings.TrimSpace(match[1])
	funcName := strings.TrimSpace(match[2])
	argsStr := strings.TrimSpace(match[3])
	body := match[4]
	outputVar := strings.TrimSpace(match[5])

	if t.isSkippable(funcName, "") {
		return nil
	}

	fn := &XSFunction{
		ReturnType: returnType,
		Name:       funcName,
		OutputVar:  outputVar,
	}

	fn.Args = t.parseXSArgs(argsStr)
	fn.Code = strings.TrimSpace(body)

	return fn
}

func (t *Translator) extractFunctions(section string) {
	// Ищем XS функции
	// Формат:
	// ReturnType
	// func_name(args)
	//     type arg1
	//     type arg2
	//     CODE:
	//         ...
	//     OUTPUT:
	//         RETVAL

	// Паттерн для XS функции
	// Ключевой признак: CODE: и OUTPUT: секции
	funcPattern := regexp.MustCompile(`(?sm)^(\w+(?:\s*\*)?)\s*$\s*^(\w+)\s*\(([^)]*)\)\s*$(.*?)^[ \t]+OUTPUT:\s*$\s*^[ \t]+(\w+)`)

	matches := funcPattern.FindAllStringSubmatch(section, -1)

	for _, match := range matches {
		if len(match) < 6 {
			continue
		}

		returnType := strings.TrimSpace(match[1])
		funcName := strings.TrimSpace(match[2])
		argsStr := strings.TrimSpace(match[3])
		body := match[4]
		outputVar := strings.TrimSpace(match[5])

		// Пропускаем если это не похоже на XS функцию
		if t.isSkippable(funcName, returnType) {
			continue
		}

		fn := &XSFunction{
			ReturnType: returnType,
			Name:       funcName,
			OutputVar:  outputVar,
		}

		// Парсим имена аргументов из сигнатуры
		argNames := []string{}
		if argsStr != "" {
			for _, arg := range strings.Split(argsStr, ",") {
				arg = strings.TrimSpace(arg)
				if arg != "" {
					argNames = append(argNames, arg)
				}
			}
		}

		// Разделяем тело на декларации аргументов и CODE
		t.parseBody(fn, body, argNames)

		// Добавляем функцию только если она валидна
		if fn.Name != "" && (len(fn.Args) > 0 || len(argNames) == 0) {
			t.functions[fn.Name] = fn
		}
	}
}

func (t *Translator) isSkippable(funcName, returnType string) bool {
	_ = returnType
	// Пропускаем внутренние функции
	skipNames := map[string]bool{
		"DESTROY":   true,
		"CLONE":     true,
		"AUTOLOAD":  true,
		"BEGIN":     true,
		"END":       true,
		"UNITCHECK": true,
		"CHECK":     true,
		"INIT":      true,
	}

	if skipNames[funcName] {
		return true
	}

	// Пропускаем если имя начинается с _
	if strings.HasPrefix(funcName, "_") {
		return true
	}

	return false
}

func (t *Translator) parseBody(fn *XSFunction, body string, argNames []string) {
	// Разделяем на часть до CODE: и после
	codeParts := regexp.MustCompile(`(?si)(.*?)CODE:\s*(.*)`).FindStringSubmatch(body)

	argDeclarations := ""
	codeBody := ""

	if len(codeParts) >= 3 {
		argDeclarations = codeParts[1]
		codeBody = codeParts[2]
	} else {
		// Нет CODE: секции
		return
	}

	// Парсим декларации аргументов
	fn.Args = t.parseArgDeclarations(argDeclarations, argNames)

	// Если аргументы не найдены, используем имена из сигнатуры с типом по умолчанию
	if len(fn.Args) == 0 && len(argNames) > 0 {
		for _, name := range argNames {
			fn.Args = append(fn.Args, XSArg{
				Type: "SV *",
				Name: name,
			})
		}
	}

	// Очищаем код от лишнего
	fn.Code = t.cleanCode(codeBody)
}

func (t *Translator) parseArgDeclarations(declarations string, argNames []string) []XSArg {
	_ = argNames
	var args []XSArg

	lines := strings.Split(declarations, "\n")
	argIndex := 0

	for _, line := range lines {
		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		// Пропускаем PREINIT:, INIT:, ALIAS: и т.д.
		if strings.HasSuffix(line, ":") {
			continue
		}

		// Пропускаем если это не декларация типа
		if !t.isTypeDeclaration(line) {
			continue
		}

		// Формат: "SV *name" или "int a" или "char *str"
		parts := strings.Fields(line)
		if len(parts) >= 2 {
			// Последнее слово - имя переменной
			varName := parts[len(parts)-1]
			// Всё остальное - тип
			typeName := strings.Join(parts[:len(parts)-1], " ")

			// Убираем * из имени если прилипло
			varName = strings.TrimPrefix(varName, "*")
			// Добавляем * к типу если было в имени
			if strings.HasPrefix(parts[len(parts)-1], "*") {
				typeName += " *"
			}

			args = append(args, XSArg{
				Type: typeName,
				Name: varName,
			})
			argIndex++
		}
	}

	return args
}

func (t *Translator) isTypeDeclaration(line string) bool {
	// Проверяем, похоже ли на декларацию типа
	validTypes := []string{
		"SV", "AV", "HV", "CV", "GV",
		"int", "long", "short", "char",
		"unsigned", "signed",
		"double", "float",
		"I32", "I16", "I8",
		"U32", "U16", "U8",
		"IV", "UV", "NV",
		"STRLEN", "Size_t", "bool",
	}

	for _, vt := range validTypes {
		if strings.HasPrefix(line, vt+" ") || strings.HasPrefix(line, vt+"*") || strings.HasPrefix(line, vt+"\t") {
			return true
		}
	}

	return false
}

func (t *Translator) cleanCode(code string) string {
	lines := strings.Split(code, "\n")
	var cleaned []string

	for _, line := range lines {
		trimmed := strings.TrimSpace(line)

		// Пропускаем пустые строки
		if trimmed == "" {
			continue
		}

		// Останавливаемся на OUTPUT: (если вдруг попало)
		if strings.HasPrefix(trimmed, "OUTPUT:") {
			break
		}

		// Пропускаем метки
		if strings.HasSuffix(trimmed, ":") && !strings.Contains(trimmed, "=") {
			continue
		}

		cleaned = append(cleaned, trimmed)
	}

	return strings.Join(cleaned, "\n")
}

func (t *Translator) parseArgs(argsStr string) []XSArg {
	var args []XSArg

	parts := strings.Split(argsStr, ",")
	for _, part := range parts {
		part = strings.TrimSpace(part)
		if part == "" {
			continue
		}

		// Формат: "SV* name" или "int count"
		tokens := strings.Fields(part)
		if len(tokens) >= 2 {
			typeName := strings.Join(tokens[:len(tokens)-1], " ")
			varName := tokens[len(tokens)-1]
			// Убираем * из имени если прилип
			varName = strings.TrimPrefix(varName, "*")
			args = append(args, XSArg{
				Type: typeName,
				Name: varName,
			})
		} else if len(tokens) == 1 {
			// Только тип, имя сгенерируем
			args = append(args, XSArg{
				Type: tokens[0],
				Name: fmt.Sprintf("arg%d", len(args)),
			})
		}
	}

	return args
}

func (t *Translator) generateHeader() {
	t.output.WriteString("// Auto-generated from XS\n")
	t.output.WriteString(fmt.Sprintf("// Module: %s, Package: %s\n\n", t.module, t.package_))
	t.output.WriteString("package main\n\n")
	t.output.WriteString("import (\n")
	t.output.WriteString("\t\"fmt\"\n")
	t.output.WriteString("\t\"strings\"\n")
	t.output.WriteString(")\n\n")
	t.output.WriteString("var _ = fmt.Sprint\n")
	t.output.WriteString("var _ = strings.Cut\n\n")
}

func (t *Translator) translateFunction(fn *XSFunction) {
	// Имя функции: Package::func → perl_Package_func
	goName := "perl_" + strings.ReplaceAll(t.package_, "::", "_") + "_" + fn.Name

	t.output.WriteString(fmt.Sprintf("func %s(args ...*SV) *SV {\n", goName))

	// Извлекаем аргументы
	for i, arg := range fn.Args {
		goType := t.mapType(arg.Type)
		t.output.WriteString(fmt.Sprintf("\t%s := %s\n", arg.Name, t.extractArg(i, arg.Type, goType)))
	}

	if len(fn.Args) > 0 {
		t.output.WriteString("\n")
	}

	// Переменная для результата
	if fn.OutputVar == "RETVAL" {
		t.output.WriteString("\tvar RETVAL *SV\n\n")
	}

	// Транслируем тело
	goCode := t.translateCCode(fn.Code)

	// Добавляем отступы
	lines := strings.Split(goCode, "\n")
	for _, line := range lines {
		if strings.TrimSpace(line) != "" {
			t.output.WriteString("\t" + line + "\n")
		}
	}

	t.output.WriteString("\n\treturn RETVAL\n")
	t.output.WriteString("}\n\n")
}

func (t *Translator) mapType(cType string) string {
	cType = strings.TrimSpace(cType)

	switch cType {
	case "SV*", "SV *":
		return "*SV"
	case "AV*", "AV *":
		return "*SV"
	case "HV*", "HV *":
		return "*SV"
	case "int", "I32", "IV":
		return "int64"
	case "double", "NV":
		return "float64"
	case "char*", "char *":
		return "string"
	case "bool":
		return "bool"
	case "void":
		return ""
	default:
		return "*SV"
	}
}

func (t *Translator) extractArg(index int, cType, goType string) string {
	_ = cType
	switch goType {
	case "*SV":
		return fmt.Sprintf("args[%d]", index)
	case "int64":
		return fmt.Sprintf("args[%d].AsInt()", index)
	case "float64":
		return fmt.Sprintf("args[%d].AsFloat()", index)
	case "string":
		return fmt.Sprintf("args[%d].AsString()", index)
	case "bool":
		return fmt.Sprintf("args[%d].IsTrue()", index)
	default:
		return fmt.Sprintf("args[%d]", index)
	}
}

// Замени метод translateCCode на:
func (t *Translator) translateCCode(cCode string) string {
	c2goTranslator := c2go.New()
	return c2goTranslator.Translate(cCode)
}

func (t *Translator) generateInit() {
	t.output.WriteString("func init() {\n")

	for _, fn := range t.functions {
		goName := "perl_" + strings.ReplaceAll(t.package_, "::", "_") + "_" + fn.Name
		perlName := t.package_ + "::" + fn.Name
		t.output.WriteString(fmt.Sprintf("\tperl_register_sub(\"%s\", %s)\n", perlName, goName))
	}

	t.output.WriteString("}\n")
}

// Дополнительные методы для SV
const svHelpers = `
// Helper methods for SV
func (sv *SV) IsRef() bool {
	return sv != nil && sv.ref != nil
}

func (sv *SV) IsHash() bool {
	return sv != nil && sv.flags&SVf_HOK != 0
}

func (sv *SV) IsArray() bool {
	return sv != nil && sv.flags&SVf_AOK != 0
}

func (sv *SV) IsInt() bool {
	return sv != nil && sv.flags&SVf_IOK != 0
}

func (sv *SV) IsFloat() bool {
	return sv != nil && sv.flags&SVf_NOK != 0
}

func (sv *SV) Deref() *SV {
	if sv.ref != nil {
		return sv.ref
	}
	return sv
}

type HashIterator struct {
	hv    *SV
	keys  []string
	index int
	key   string
	value *SV
}

func (sv *SV) HashIterator() *HashIterator {
	keys := make([]string, 0, len(sv.hv))
	for k := range sv.hv {
		keys = append(keys, k)
	}
	return &HashIterator{hv: sv, keys: keys, index: -1}
}

func (it *HashIterator) Valid() bool {
	return it.index < len(it.keys)
}

func (it *HashIterator) Next() *HashIterator {
	it.index++
	if it.index < len(it.keys) {
		it.key = it.keys[it.index]
		it.value = it.hv.hv[it.key]
	}
	return it
}

func (it *HashIterator) Key() *SV {
	return svStr(it.key)
}

func (it *HashIterator) Value() *SV {
	return it.value
}
`
```

## File: ./test_xs/test_xs_compiled.go
```go
// test_xs/test_xs_compiled.go
package main

import "fmt"

// Runtime (минимальный)
type SV struct {
	iv    int64
	pv    string
	flags uint8
}

const SVf_IOK uint8 = 1
const SVf_POK uint8 = 4

func svInt(i int64) *SV  { return &SV{iv: i, flags: SVf_IOK} }
func svStr(s string) *SV { return &SV{pv: s, flags: SVf_POK} }

func (sv *SV) AsInt() int64     { return sv.iv }
func (sv *SV) AsString() string { return sv.pv }

var _subs = make(map[string]func(...*SV) *SV)

func perl_register_sub(name string, fn func(...*SV) *SV) {
	_subs[name] = fn
}

// === Сгенерированный код ===

func perl_Test_XS_add(args ...*SV) *SV {
	a := args[0].AsInt()
	b := args[1].AsInt()
	var RETVAL *SV
	RETVAL = svInt(int64(a + b))
	return RETVAL
}

func perl_Test_XS_hello(args ...*SV) *SV {
	name := args[0]
	var RETVAL *SV
	str := name.AsString()
	RETVAL = svStr(fmt.Sprintf("Hello, %s!", str))
	return RETVAL
}

func init() {
	perl_register_sub("Test::XS::hello", perl_Test_XS_hello)
	perl_register_sub("Test::XS::add", perl_Test_XS_add)
}

// === Тест ===

func main() {
	// Тест add
	result := perl_Test_XS_add(svInt(3), svInt(5))
	fmt.Printf("add(3, 5) = %d\n", result.AsInt())

	// Тест hello
	result = perl_Test_XS_hello(svStr("World"))
	fmt.Printf("hello(World) = %s\n", result.AsString())
}
```

## File: ./tests/fileio_test.go
```go
package tests

import (
	"os"
	"testing"
)

// ============================================================
// Extended File I/O Tests
// ============================================================

func TestFileIOBasic(t *testing.T) {
	tests := []TestCase{
		{
			Name: "basic write and read",
			Code: `open(my $fh, ">", "basic_write.txt");
print $fh "Hello";
close($fh);

open($fh, "<", "basic_write.txt");
my $content = <$fh>;
close($fh);
say $content;`,
			ExpectedOutput: "Hello",
			CleanupFiles:   []string{"basic_write.txt"},
		},
		{
			Name: "write multiple lines",
			Code: `open(my $fh, ">", "multi_line.txt");
print $fh "Line 1\n";
print $fh "Line 2\n";
print $fh "Line 3\n";
close($fh);

open($fh, "<", "multi_line.txt");
my @lines;
my $line;
$line = <$fh>; chomp($line); push(@lines, $line);
$line = <$fh>; chomp($line); push(@lines, $line);
$line = <$fh>; chomp($line); push(@lines, $line);
close($fh);
say join("|", @lines);`,
			ExpectedOutput: "Line 1|Line 2|Line 3",
			CleanupFiles:   []string{"multi_line.txt"},
		},
		{
			Name: "say to file adds newline",
			Code: `open(my $fh, ">", "say_file.txt");
say $fh "Hello";
close($fh);

open($fh, "<", "say_file.txt");
my $line = <$fh>;
close($fh);
say length($line);  # Should be 6: "Hello\n"`,
			ExpectedOutput: "6",
			CleanupFiles:   []string{"say_file.txt"},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOAppend(t *testing.T) {
	tests := []TestCase{
		{
			Name: "append to file",
			Code: `open(my $fh, ">", "append.txt");
print $fh "First\n";
close($fh);

open($fh, ">>", "append.txt");
print $fh "Second\n";
close($fh);

open($fh, "<", "append.txt");
my $l1 = <$fh>; chomp($l1);
my $l2 = <$fh>; chomp($l2);
close($fh);
say "$l1, $l2";`,
			ExpectedOutput: "First, Second",
			CleanupFiles:   []string{"append.txt"},
		},
		{
			Name: "multiple appends",
			Code: `open(my $fh, ">", "multi_append.txt");
print $fh "A\n";
close($fh);

foreach my $letter ("B", "C", "D") {
    open($fh, ">>", "multi_append.txt");
    print $fh "$letter\n";
    close($fh);
}

open($fh, "<", "multi_append.txt");
my @lines;
for (1..4) {
    my $line = <$fh>;
    chomp($line);
    push(@lines, $line);
}
close($fh);
say join("", @lines);`,
			ExpectedOutput: "ABCD",
			CleanupFiles:   []string{"multi_append.txt"},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOReadFromExisting(t *testing.T) {
	tests := []TestCase{
		{
			Name: "read single line file",
			Code: `open(my $fh, "<", "single.txt");
my $content = <$fh>;
close($fh);
chomp($content);
say "Content: $content";`,
			ExpectedOutput: "Content: Single line content",
			SetupFiles: map[string]string{
				"single.txt": "Single line content\n",
			},
		},
		{
			Name: "read multi-line file",
			Code: `open(my $fh, "<", "multi.txt");
my @lines;
my $line;
$line = <$fh>;
while (defined $line) {
    chomp($line);
    push(@lines, $line);
    $line = <$fh>;
}
close($fh);
say scalar(@lines);
say $lines[0];
say $lines[2];`,
			ExpectedOutput: "3\nLine A\nLine C",
			SetupFiles: map[string]string{
				"multi.txt": "Line A\nLine B\nLine C\n",
			},
		},
		{
			Name: "read empty file",
			Code: `open(my $fh, "<", "empty.txt");
my $line = <$fh>;
close($fh);
say defined($line) ? "got content" : "empty";`,
			ExpectedOutput: "empty",
			SetupFiles: map[string]string{
				"empty.txt": "",
			},
		},
		{
			Name: "read file without trailing newline",
			Code: `open(my $fh, "<", "no_newline.txt");
my $content = <$fh>;
close($fh);
say "[$content]";`,
			ExpectedOutput: "[Hello World]",
			SetupFiles: map[string]string{
				"no_newline.txt": "Hello World",
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOOpenModes(t *testing.T) {
	tests := []TestCase{
		{
			Name: "3-arg open write",
			Code: `open(my $fh, ">", "three_arg_write.txt");
print $fh "Three arg";
close($fh);

open($fh, "<", "three_arg_write.txt");
my $c = <$fh>;
close($fh);
say $c;`,
			ExpectedOutput: "Three arg",
			CleanupFiles:   []string{"three_arg_write.txt"},
		},
		{
			Name: "3-arg open read",
			Code: `open(my $fh, "<", "read_mode.txt");
my $c = <$fh>;
close($fh);
chomp($c);
say $c;`,
			ExpectedOutput: "Read mode content",
			SetupFiles: map[string]string{
				"read_mode.txt": "Read mode content\n",
			},
		},
		{
			Name: "3-arg open append",
			Code: `open(my $fh, ">", "append_mode.txt");
print $fh "First\n";
close($fh);

open($fh, ">>", "append_mode.txt");
print $fh "Second\n";
close($fh);

open($fh, "<", "append_mode.txt");
my $l1 = <$fh>;
my $l2 = <$fh>;
close($fh);
chomp($l1); chomp($l2);
say "$l1 and $l2";`,
			ExpectedOutput: "First and Second",
			CleanupFiles:   []string{"append_mode.txt"},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOErrorHandling(t *testing.T) {
	tests := []TestCase{
		{
			Name: "open nonexistent file returns false",
			Code: `my $result = open(my $fh, "<", "this_file_does_not_exist_xyz.txt");
say $result ? "success" : "failed";`,
			ExpectedOutput: "failed",
		},
		{
			Name: "check open result",
			Code: `if (open(my $fh, "<", "exists.txt")) {
    my $c = <$fh>;
    close($fh);
    chomp($c);
    say "Opened: $c";
} else {
    say "Failed to open";
}`,
			ExpectedOutput: "Opened: File exists",
			SetupFiles: map[string]string{
				"exists.txt": "File exists\n",
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOWithVariables(t *testing.T) {
	tests := []TestCase{
		{
			Name: "filename in variable",
			Code: `my $filename = "var_file.txt";
open(my $fh, ">", $filename);
print $fh "Variable filename";
close($fh);

open($fh, "<", $filename);
my $c = <$fh>;
close($fh);
say $c;`,
			ExpectedOutput: "Variable filename",
			CleanupFiles:   []string{"var_file.txt"},
		},
		{
			Name: "write variable content",
			Code: `my @data = ("Apple", "Banana", "Cherry");
open(my $fh, ">", "data.txt");
foreach my $item (@data) {
    say $fh $item;
}
close($fh);

open($fh, "<", "data.txt");
my @read;
for (1..3) {
    my $line = <$fh>;
    chomp($line);
    push(@read, $line);
}
close($fh);
say join(", ", @read);`,
			ExpectedOutput: "Apple, Banana, Cherry",
			CleanupFiles:   []string{"data.txt"},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOMultipleHandles(t *testing.T) {
	tests := []TestCase{
		{
			Name: "two files simultaneously",
			Code: `open(my $fh1, ">", "file1.txt");
open(my $fh2, ">", "file2.txt");
print $fh1 "Content 1";
print $fh2 "Content 2";
close($fh1);
close($fh2);

open($fh1, "<", "file1.txt");
open($fh2, "<", "file2.txt");
my $c1 = <$fh1>;
my $c2 = <$fh2>;
close($fh1);
close($fh2);
say "$c1 and $c2";`,
			ExpectedOutput: "Content 1 and Content 2",
			CleanupFiles:   []string{"file1.txt", "file2.txt"},
		},
		{
			Name: "read from one write to another",
			Code: `open(my $in, "<", "source.txt");
open(my $out, ">", "dest.txt");
my $line;
$line = <$in>;
while (defined $line) {
    $line =~ s/old/new/g;
    print $out $line;
    $line = <$in>;
}
close($in);
close($out);

open(my $check, "<", "dest.txt");
my $result = <$check>;
close($check);
chomp($result);
say $result;`,
			ExpectedOutput: "new data here",
			SetupFiles: map[string]string{
				"source.txt": "old data here\n",
			},
			CleanupFiles: []string{"dest.txt"},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestFileIOIntegration(t *testing.T) {
	tests := []TestCase{
		{
			Name: "CSV processing",
			Code: `# Write CSV
open(my $fh, ">", "data.csv");
say $fh "name,age,city";
say $fh "Alice,30,NYC";
say $fh "Bob,25,LA";
say $fh "Charlie,35,Chicago";
close($fh);

# Read and process
open($fh, "<", "data.csv");
my $header = <$fh>; # skip header
my @people;
my $line = <$fh>;
while (defined $line) {
    chomp($line);
    my @fields = split(",", $line);
    push(@people, $fields[0]);
    $line = <$fh>;
}
close($fh);

say join(", ", @people);`,
			ExpectedOutput: "Alice, Bob, Charlie",
			CleanupFiles:   []string{"data.csv"},
		},
		{
			Name: "Log file simulation",
			Code: `my @logs = ("INFO: Started", "WARN: Low memory", "ERROR: Failed");
open(my $fh, ">", "app.log");
foreach my $log (@logs) {
    say $fh $log;
}
close($fh);

# Count errors
open($fh, "<", "app.log");
my $errors = 0;
my $line = <$fh>;
while (defined $line) {
    $errors++ if $line =~ /ERROR/;
    $line = <$fh>;
}
close($fh);
say "Errors: $errors";`,
			ExpectedOutput: "Errors: 1",
			CleanupFiles:   []string{"app.log"},
		},
		{
			Name: "Config file reading",
			Code: `open(my $fh, "<", "config.ini");
my %config;
my $line = <$fh>;
while (defined $line) {
    chomp($line);
    if ($line =~ /^(\w+)\s*=\s*(.+)$/) {
        $config{$1} = $2;
    }
    $line = <$fh>;
}
close($fh);

say "host: $config{host}";
say "port: $config{port}";`,
			ExpectedOutput: "host: localhost\nport: 8080",
			SetupFiles: map[string]string{
				"config.ini": "host = localhost\nport = 8080\ndebug = true\n",
			},
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// Cleanup function for any leftover test files
func TestCleanup(t *testing.T) {
	files := []string{
		"test_io.txt", "input_test.txt", "append_test.txt", "say_test.txt",
		"three_arg_test.txt", "basic_write.txt", "multi_line.txt", "say_file.txt",
		"append.txt", "multi_append.txt", "single.txt", "multi.txt", "empty.txt",
		"no_newline.txt", "three_arg_write.txt", "read_mode.txt", "append_mode.txt",
		"exists.txt", "var_file.txt", "data.txt", "file1.txt", "file2.txt",
		"source.txt", "dest.txt", "data.csv", "app.log", "config.ini",
		"output.txt", "test_output.txt",
	}

	for _, f := range files {
		os.Remove(f)
	}
}
```

## File: ./tests/integration_test.go
```go
package tests

import (
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
)

// TestCase represents a single integration test
type TestCase struct {
	Name           string
	Code           string
	ExpectedOutput string
	ExpectedMatch  string // Regex pattern for flexible matching
	SetupFiles     map[string]string // Files to create before test
	CleanupFiles   []string          // Files to remove after test
	SkipCompile    bool              // Skip compilation test
	SkipInterpret  bool              // Skip interpretation test
}

// runInterpreter runs perlc in interpreter mode
func runInterpreter(t *testing.T, code string) (string, error) {
	// Create temp file with test code
	tmpFile, err := os.CreateTemp("", "test_*.pl")
	if err != nil {
		return "", err
	}
	defer os.Remove(tmpFile.Name())

	if _, err := tmpFile.WriteString(code); err != nil {
		return "", err
	}
	tmpFile.Close()

	// Determine exe name
	exeName := "./perlc"
	if os.PathSeparator == '\\' {
		exeName = "./perlc.exe"
	}

	// Run perlc
	cmd := exec.Command(exeName, tmpFile.Name())
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err = cmd.Run()
	output := stdout.String()
	if stderr.Len() > 0 {
		output += stderr.String()
	}

	return output, err
}

// runCompiled runs perlc with -r flag (compile and run)
func runCompiled(t *testing.T, code string) (string, error) {
	// Create temp file with test code
	tmpFile, err := os.CreateTemp("", "test_*.pl")
	if err != nil {
		return "", err
	}
	defer os.Remove(tmpFile.Name())

	if _, err := tmpFile.WriteString(code); err != nil {
		return "", err
	}
	tmpFile.Close()

	// Determine exe name
	exeName := "./perlc"
	if os.PathSeparator == '\\' {
		exeName = "./perlc.exe"
	}

	// Run perlc -r
	cmd := exec.Command(exeName, "-r", tmpFile.Name())
	var stdout, stderr bytes.Buffer
	cmd.Stdout = &stdout
	cmd.Stderr = &stderr

	err = cmd.Run()
	output := stdout.String()

	// Remove "Compiled: xxx.exe\n---\n" prefix
	if idx := strings.Index(output, "---\n"); idx != -1 {
		output = output[idx+4:]
	}

	// Cleanup exe
	base := strings.TrimSuffix(filepath.Base(tmpFile.Name()), ".pl")
	os.Remove(base + ".exe")
	os.Remove(base)

	return output, err
}

// checkOutput compares actual output with expected
func checkOutput(t *testing.T, name, mode, actual, expected, pattern string) {
	actual = strings.TrimSpace(actual)
	expected = strings.TrimSpace(expected)

	if pattern != "" {
		re := regexp.MustCompile(pattern)
		if !re.MatchString(actual) {
			t.Errorf("[%s] %s:\nExpected pattern: %s\nActual:\n%s", mode, name, pattern, actual)
		}
		return
	}

	if actual != expected {
		t.Errorf("[%s] %s:\nExpected:\n%s\n\nActual:\n%s", mode, name, expected, actual)
	}
}

// runTest executes a single test case
func runTest(t *testing.T, tc TestCase) {
	// Setup files
	for filename, content := range tc.SetupFiles {
		if err := os.WriteFile(filename, []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create setup file %s: %v", filename, err)
		}
	}

	// Cleanup
	defer func() {
		for _, f := range tc.CleanupFiles {
			os.Remove(f)
		}
		for f := range tc.SetupFiles {
			os.Remove(f)
		}
	}()

	// Test interpreter
	if !tc.SkipInterpret {
		output, err := runInterpreter(t, tc.Code)
		if err != nil && tc.ExpectedOutput != "" {
			t.Errorf("[INTERP] %s: interpreter error: %v\nOutput: %s", tc.Name, err, output)
		} else {
			checkOutput(t, tc.Name, "INTERP", output, tc.ExpectedOutput, tc.ExpectedMatch)
		}
	}

	// Test compilation
	if !tc.SkipCompile {
		output, err := runCompiled(t, tc.Code)
		if err != nil && tc.ExpectedOutput != "" {
			t.Errorf("[COMPILE] %s: compilation error: %v\nOutput: %s", tc.Name, err, output)
		} else {
			checkOutput(t, tc.Name, "COMPILE", output, tc.ExpectedOutput, tc.ExpectedMatch)
		}
	}
}

// ============================================================
// Basic Tests
// ============================================================

func TestBasicPrint(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "print string",
			Code:           `print "Hello, World!\n";`,
			ExpectedOutput: "Hello, World!",
		},
		{
			Name:           "say string",
			Code:           `say "Hello";`,
			ExpectedOutput: "Hello",
		},
		{
			Name:           "multiple print",
			Code:           `print "One\n"; print "Two\n"; print "Three\n";`,
			ExpectedOutput: "One\nTwo\nThree",
		},
		{
			Name:           "print with variable",
			Code:           `my $x = "World"; print "Hello, $x!\n";`,
			ExpectedOutput: "Hello, World!",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

func TestVariables(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "scalar assignment",
			Code:           `my $x = 42; say $x;`,
			ExpectedOutput: "42",
		},
		{
			Name:           "scalar reassignment",
			Code:           `my $x = 10; $x = 20; say $x;`,
			ExpectedOutput: "20",
		},
		{
			Name:           "multiple scalars",
			Code:           `my $a = 1; my $b = 2; my $c = 3; say "$a $b $c";`,
			ExpectedOutput: "1 2 3",
		},
		{
			Name:           "string variable",
			Code:           `my $name = "Alice"; say "Hello, $name";`,
			ExpectedOutput: "Hello, Alice",
		},
		{
			Name:           "variable interpolation",
			Code:           `my $x = 5; my $y = 10; say "x=$x, y=$y, sum=" . ($x + $y);`,
			ExpectedOutput: "x=5, y=10, sum=15",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Arithmetic Tests
// ============================================================

func TestArithmetic(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "addition",
			Code:           `say 2 + 3;`,
			ExpectedOutput: "5",
		},
		{
			Name:           "subtraction",
			Code:           `say 10 - 4;`,
			ExpectedOutput: "6",
		},
		{
			Name:           "multiplication",
			Code:           `say 6 * 7;`,
			ExpectedOutput: "42",
		},
		{
			Name:           "division",
			Code:           `say 15 / 3;`,
			ExpectedOutput: "5",
		},
		{
			Name:           "modulo",
			Code:           `say 17 % 5;`,
			ExpectedOutput: "2",
		},
		{
			Name:           "power",
			Code:           `say 2 ** 10;`,
			ExpectedOutput: "1024",
		},
		{
			Name:           "complex expression",
			Code:           `say (2 + 3) * 4 - 5;`,
			ExpectedOutput: "15",
		},
		{
			Name:           "negative numbers",
			Code:           `say -5 + 10;`,
			ExpectedOutput: "5",
		},
		{
			Name:           "float arithmetic",
			Code:           `say 3.14 * 2;`,
			ExpectedMatch:  `6\.28`,
		},
		{
			Name:           "increment",
			Code:           `my $x = 5; $x++; say $x;`,
			ExpectedOutput: "6",
		},
		{
			Name:           "decrement",
			Code:           `my $x = 5; $x--; say $x;`,
			ExpectedOutput: "4",
		},
		{
			Name:           "compound assignment +=",
			Code:           `my $x = 10; $x += 5; say $x;`,
			ExpectedOutput: "15",
		},
		{
			Name:           "compound assignment *=",
			Code:           `my $x = 3; $x *= 4; say $x;`,
			ExpectedOutput: "12",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// String Operations Tests
// ============================================================

func TestStringOperations(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "concatenation",
			Code:           `say "Hello" . " " . "World";`,
			ExpectedOutput: "Hello World",
		},
		{
			Name:           "string repetition",
			Code:           `say "ab" x 3;`,
			ExpectedOutput: "ababab",
		},
		{
			Name:           "length",
			Code:           `say length("hello");`,
			ExpectedOutput: "5",
		},
		{
			Name:           "uc",
			Code:           `say uc("hello");`,
			ExpectedOutput: "HELLO",
		},
		{
			Name:           "lc",
			Code:           `say lc("HELLO");`,
			ExpectedOutput: "hello",
		},
		{
			Name:           "ucfirst",
			Code:           `say ucfirst("hello world");`,
			ExpectedOutput: "Hello world",
		},
		{
			Name:           "lcfirst",
			Code:           `say lcfirst("HELLO");`,
			ExpectedOutput: "hELLO",
		},
		{
			Name:           "reverse string",
			Code:           `say scalar(reverse("hello"));`,
			ExpectedOutput: "olleh",
		},
		{
			Name:           "substr get",
			Code:           `say substr("Hello World", 0, 5);`,
			ExpectedOutput: "Hello",
		},
		{
			Name:           "substr from end",
			Code:           `say substr("Hello World", -5);`,
			ExpectedOutput: "World",
		},
		{
			Name:           "index",
			Code:           `say index("Hello World", "World");`,
			ExpectedOutput: "6",
		},
		{
			Name:           "rindex",
			Code:           `say rindex("Hello Hello", "Hello");`,
			ExpectedOutput: "6",
		},
		{
			Name:           "chomp",
			Code:           `my $s = "hello\n"; chomp($s); say "[$s]";`,
			ExpectedOutput: "[hello]",
		},
		{
			Name:           "chop",
			Code:           `my $s = "hello"; chop($s); say $s;`,
			ExpectedOutput: "hell",
		},
		{
			Name:           "sprintf",
			Code:           `say sprintf("Name: %s, Age: %d", "Alice", 30);`,
			ExpectedOutput: "Name: Alice, Age: 30",
		},
		{
			Name:           "sprintf padding",
			Code:           `say sprintf("%05d", 42);`,
			ExpectedOutput: "00042",
		},
		{
			Name:           "sprintf float",
			Code:           `say sprintf("%.2f", 3.14159);`,
			ExpectedOutput: "3.14",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Array Tests
// ============================================================

func TestArrays(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "array creation and access",
			Code:           `my @arr = (1, 2, 3); say $arr[0];`,
			ExpectedOutput: "1",
		},
		{
			Name:           "array length",
			Code:           `my @arr = (1, 2, 3, 4, 5); say scalar(@arr);`,
			ExpectedOutput: "5",
		},
		{
			Name:           "array push",
			Code:           `my @arr = (1, 2); push(@arr, 3); say "@arr";`,
			ExpectedOutput: "1 2 3",
		},
		{
			Name:           "array pop",
			Code:           `my @arr = (1, 2, 3); my $x = pop(@arr); say "$x: @arr";`,
			ExpectedOutput: "3: 1 2",
		},
		{
			Name:           "array shift",
			Code:           `my @arr = (1, 2, 3); my $x = shift(@arr); say "$x: @arr";`,
			ExpectedOutput: "1: 2 3",
		},
		{
			Name:           "array unshift",
			Code:           `my @arr = (2, 3); unshift(@arr, 1); say "@arr";`,
			ExpectedOutput: "1 2 3",
		},
		{
			Name:           "array join",
			Code:           `my @arr = ("a", "b", "c"); say join("-", @arr);`,
			ExpectedOutput: "a-b-c",
		},
		{
			Name:           "array split",
			Code:           `my @arr = split(",", "a,b,c"); say "@arr";`,
			ExpectedOutput: "a b c",
		},
		{
			Name:           "array sort numeric",
			Code:           `my @arr = (3, 1, 4, 1, 5); my @sorted = sort { $a <=> $b } @arr; say "@sorted";`,
			ExpectedOutput: "1 1 3 4 5",
		},
		{
			Name:           "array sort string",
			Code:           `my @arr = ("banana", "apple", "cherry"); my @sorted = sort @arr; say "@sorted";`,
			ExpectedOutput: "apple banana cherry",
		},
		{
			Name:           "array reverse",
			Code:           `my @arr = (1, 2, 3); my @rev = reverse(@arr); say "@rev";`,
			ExpectedOutput: "3 2 1",
		},
		{
			Name:           "array slice",
			Code:           `my @arr = (10, 20, 30, 40, 50); my @slice = @arr[1, 3]; say "@slice";`,
			ExpectedOutput: "20 40",
		},
		{
			Name:           "array range",
			Code:           `my @arr = (1..5); say "@arr";`,
			ExpectedOutput: "1 2 3 4 5",
		},
		{
			Name:           "negative index",
			Code:           `my @arr = (1, 2, 3); say $arr[-1];`,
			ExpectedOutput: "3",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Hash Tests
// ============================================================

func TestHashes(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "hash creation and access",
			Code:           `my %h = (a => 1, b => 2); say $h{a};`,
			ExpectedOutput: "1",
		},
		{
			Name:           "hash assignment",
			Code:           `my %h; $h{x} = 10; say $h{x};`,
			ExpectedOutput: "10",
		},
		{
			Name:           "hash keys",
			Code:           `my %h = (a => 1, b => 2); my @k = sort keys %h; say "@k";`,
			ExpectedOutput: "a b",
		},
		{
			Name:           "hash values",
			Code:           `my %h = (a => 1, b => 2); my @v = sort values %h; say "@v";`,
			ExpectedOutput: "1 2",
		},
		{
			Name:           "hash exists",
			Code:           `my %h = (a => 1); say exists $h{a} ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "hash delete",
			Code:           `my %h = (a => 1, b => 2); delete $h{a}; say exists $h{a} ? "yes" : "no";`,
			ExpectedOutput: "no",
		},
		{
			Name:           "hash each",
			Code: `my %h = (x => 10);
while (my ($k, $v) = each %h) {
    say "$k=$v";
}`,
			ExpectedOutput: "x=10",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Control Flow Tests
// ============================================================

func TestControlFlow(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "if true",
			Code:           `if (1) { say "yes"; }`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "if false",
			Code:           `if (0) { say "yes"; } else { say "no"; }`,
			ExpectedOutput: "no",
		},
		{
			Name:           "if-elsif-else",
			Code: `my $x = 2;
if ($x == 1) { say "one"; }
elsif ($x == 2) { say "two"; }
else { say "other"; }`,
			ExpectedOutput: "two",
		},
		{
			Name:           "unless",
			Code:           `unless (0) { say "yes"; }`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "statement modifier if",
			Code:           `say "yes" if 1;`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "statement modifier unless",
			Code:           `say "yes" unless 0;`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "while loop",
			Code: `my $i = 0;
while ($i < 3) {
    say $i;
    $i++;
}`,
			ExpectedOutput: "0\n1\n2",
		},
		{
			Name:           "until loop",
			Code: `my $i = 0;
until ($i >= 3) {
    say $i;
    $i++;
}`,
			ExpectedOutput: "0\n1\n2",
		},
		{
			Name:           "for loop C-style",
			Code: `for (my $i = 0; $i < 3; $i++) {
    say $i;
}`,
			ExpectedOutput: "0\n1\n2",
		},
		{
			Name:           "foreach array",
			Code: `my @arr = (1, 2, 3);
foreach my $x (@arr) {
    say $x;
}`,
			ExpectedOutput: "1\n2\n3",
		},
		{
			Name:           "foreach range",
			Code: `foreach my $i (1..3) {
    say $i;
}`,
			ExpectedOutput: "1\n2\n3",
		},
		{
			Name:           "for as foreach",
			Code: `for my $x (1, 2, 3) {
    say $x;
}`,
			ExpectedOutput: "1\n2\n3",
		},
		{
			Name:           "last in loop",
			Code: `foreach my $i (1..10) {
    last if $i > 3;
    say $i;
}`,
			ExpectedOutput: "1\n2\n3",
		},
		{
			Name:           "next in loop",
			Code: `foreach my $i (1..5) {
    next if $i % 2 == 0;
    say $i;
}`,
			ExpectedOutput: "1\n3\n5",
		},
		{
			Name:           "ternary operator",
			Code:           `my $x = 10; say $x > 5 ? "big" : "small";`,
			ExpectedOutput: "big",
		},
		{
			Name:           "logical and",
			Code:           `say 1 && 2;`,
			ExpectedOutput: "2",
		},
		{
			Name:           "logical or",
			Code:           `say 0 || "default";`,
			ExpectedOutput: "default",
		},
		{
			Name:           "defined-or",
			Code:           `my $x; say $x // "undefined";`,
			ExpectedOutput: "undefined",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Comparison Tests
// ============================================================

func TestComparisons(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "numeric equal",
			Code:           `say 5 == 5 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "numeric not equal",
			Code:           `say 5 != 3 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "numeric less than",
			Code:           `say 3 < 5 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "numeric greater than",
			Code:           `say 5 > 3 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "numeric less equal",
			Code:           `say 5 <= 5 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "numeric greater equal",
			Code:           `say 5 >= 5 ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "string equal",
			Code:           `say "abc" eq "abc" ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "string not equal",
			Code:           `say "abc" ne "xyz" ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "string less than",
			Code:           `say "abc" lt "xyz" ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "string greater than",
			Code:           `say "xyz" gt "abc" ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "spaceship operator",
			Code:           `say 5 <=> 3;`,
			ExpectedOutput: "1",
		},
		{
			Name:           "cmp operator",
			Code:           `say "abc" cmp "xyz";`,
			ExpectedOutput: "-1",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Subroutine Tests
// ============================================================

func TestSubroutines(t *testing.T) {
	tests := []TestCase{
		{
			Name: "simple sub",
			Code: `sub greet { say "Hello"; }
greet();`,
			ExpectedOutput: "Hello",
		},
		{
			Name: "sub with args",
			Code: `sub add {
    my ($a, $b) = @_;
    return $a + $b;
}
say add(2, 3);`,
			ExpectedOutput: "5",
		},
		{
			Name: "sub with return",
			Code: `sub double {
    my ($x) = @_;
    return $x * 2;
}
my $result = double(21);
say $result;`,
			ExpectedOutput: "42",
		},
		{
			Name: "sub multiple returns",
			Code: `sub minmax {
    my @nums = @_;
    my $min = $nums[0];
    my $max = $nums[0];
    foreach my $n (@nums) {
        $min = $n if $n < $min;
        $max = $n if $n > $max;
    }
    return ($min, $max);
}
my ($min, $max) = minmax(5, 2, 8, 1, 9);
say "min=$min, max=$max";`,
			ExpectedOutput: "min=1, max=9",
		},
		{
			Name: "recursive sub",
			Code: `sub factorial {
    my ($n) = @_;
    return 1 if $n <= 1;
    return $n * factorial($n - 1);
}
say factorial(5);`,
			ExpectedOutput: "120",
		},
		{
			Name: "sub wantarray",
			Code: `sub context_test {
    if (wantarray()) {
        return (1, 2, 3);
    } else {
        return "scalar";
    }
}
my @arr = context_test();
my $s = context_test();
say "@arr";
say $s;`,
			ExpectedOutput: "1 2 3\nscalar",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Reference Tests
// ============================================================

func TestReferences(t *testing.T) {
	tests := []TestCase{
		{
			Name: "scalar reference",
			Code: `my $x = 42;
my $ref = \$x;
say $$ref;`,
			ExpectedOutput: "42",
		},
		{
			Name: "array reference",
			Code: `my @arr = (1, 2, 3);
my $ref = \@arr;
say $ref->[1];`,
			ExpectedOutput: "2",
		},
		{
			Name: "hash reference",
			Code: `my %h = (a => 1, b => 2);
my $ref = \%h;
say $ref->{a};`,
			ExpectedOutput: "1",
		},
		{
			Name: "anonymous array",
			Code: `my $arr = [1, 2, 3];
say $arr->[2];`,
			ExpectedOutput: "3",
		},
		{
			Name: "anonymous hash",
			Code: `my $h = {x => 10, y => 20};
say $h->{y};`,
			ExpectedOutput: "20",
		},
		{
			Name: "ref function",
			Code: `my $arr = [1, 2, 3];
my $h = {a => 1};
my $x = 5;
say ref($arr);
say ref($h);
say ref(\$x);`,
			ExpectedOutput: "ARRAY\nHASH\nSCALAR",
		},
		{
			Name: "modify through reference",
			Code: `my $x = 10;
my $ref = \$x;
$$ref = 20;
say $x;`,
			ExpectedOutput: "20",
		},
		{
			Name: "nested structures",
			Code: `my $data = {
    name => "Alice",
    scores => [90, 85, 95]
};
say $data->{name};
say $data->{scores}[1];`,
			ExpectedOutput: "Alice\n85",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Regex Tests
// ============================================================

func TestRegex(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "simple match",
			Code:           `my $s = "Hello World"; say $s =~ /World/ ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "no match",
			Code:           `my $s = "Hello"; say $s =~ /World/ ? "yes" : "no";`,
			ExpectedOutput: "no",
		},
		{
			Name:           "negated match",
			Code:           `my $s = "Hello"; say $s !~ /World/ ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "case insensitive",
			Code:           `my $s = "HELLO"; say $s =~ /hello/i ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "capture groups",
			Code:           `my $s = "Name: Alice"; $s =~ /Name: (\w+)/; say $1;`,
			ExpectedOutput: "Alice",
		},
		{
			Name:           "substitution",
			Code:           `my $s = "Hello World"; $s =~ s/World/Perl/; say $s;`,
			ExpectedOutput: "Hello Perl",
		},
		{
			Name:           "global substitution",
			Code:           `my $s = "aaa"; $s =~ s/a/b/g; say $s;`,
			ExpectedOutput: "bbb",
		},
		{
			Name:           "substitution with capture",
			Code:           `my $s = "Hello World"; $s =~ s/(\w+) (\w+)/$2 $1/; say $s;`,
			ExpectedOutput: "World Hello",
		},
		{
			Name:           "match in list context",
			Code:           `my $s = "a1b2c3"; my @nums = $s =~ /(\d)/g; say "@nums";`,
			ExpectedOutput: "1 2 3",
		},
		{
			Name:           "anchors",
			Code:           `say "hello" =~ /^hello$/ ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "word boundary",
			Code:           `say "hello world" =~ /\bworld\b/ ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "character class",
			Code:           `say "abc123" =~ /[0-9]+/ ? "yes" : "no";`,
			ExpectedOutput: "yes",
		},
		{
			Name:           "tr transliteration",
			Code:           `my $s = "hello"; $s =~ tr/a-z/A-Z/; say $s;`,
			ExpectedOutput: "HELLO",
		},
		{
			Name:           "tr count",
			Code:           `my $s = "hello world"; my $cnt = ($s =~ tr/o/o/); say $cnt;`,
			ExpectedOutput: "2",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// File I/O Tests
// ============================================================

func TestFileIO(t *testing.T) {
	tests := []TestCase{
		{
			Name: "write and read file",
			Code: `my $fh;
open($fh, ">", "test_io.txt");
print $fh "Line 1\n";
print $fh "Line 2\n";
close($fh);

open($fh, "<", "test_io.txt");
my $line1 = <$fh>;
my $line2 = <$fh>;
close($fh);

chomp($line1);
chomp($line2);
say "1: $line1";
say "2: $line2";`,
			ExpectedOutput: "1: Line 1\n2: Line 2",
			CleanupFiles:   []string{"test_io.txt"},
		},
		{
			Name: "read existing file",
			Code: `open(my $fh, "<", "input_test.txt");
my $content = <$fh>;
close($fh);
chomp($content);
say "Got: $content";`,
			ExpectedOutput: "Got: Hello from test file",
			SetupFiles: map[string]string{
				"input_test.txt": "Hello from test file\n",
			},
		},
		{
			Name: "append mode",
			Code: `open(my $fh, ">", "append_test.txt");
print $fh "Line 1\n";
close($fh);

open($fh, ">>", "append_test.txt");
print $fh "Line 2\n";
close($fh);

open($fh, "<", "append_test.txt");
my @lines;
while (my $line = <$fh>) {
    chomp($line);
    push(@lines, $line);
}
close($fh);
say join(", ", @lines);`,
			ExpectedOutput: "Line 1, Line 2",
			CleanupFiles:   []string{"append_test.txt"},
		},
		{
			Name: "say to filehandle",
			Code: `open(my $fh, ">", "say_test.txt");
say $fh "Hello";
say $fh "World";
close($fh);

open($fh, "<", "say_test.txt");
my $l1 = <$fh>;
my $l2 = <$fh>;
close($fh);
chomp($l1);
chomp($l2);
say "$l1 $l2";`,
			ExpectedOutput: "Hello World",
			CleanupFiles:   []string{"say_test.txt"},
		},
		{
			Name: "3-arg open read",
			Code: `open(my $fh, "<", "three_arg_test.txt");
my $line = <$fh>;
close($fh);
chomp($line);
say $line;`,
			ExpectedOutput: "Test content",
			SetupFiles: map[string]string{
				"three_arg_test.txt": "Test content\n",
			},
		},
		{
			Name: "open return value",
			Code: `my $result = open(my $fh, "<", "nonexistent_file_xyz.txt");
say $result ? "opened" : "failed";`,
			ExpectedOutput: "failed",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Built-in Function Tests
// ============================================================

func TestBuiltinFunctions(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "abs positive",
			Code:           `say abs(42);`,
			ExpectedOutput: "42",
		},
		{
			Name:           "abs negative",
			Code:           `say abs(-42);`,
			ExpectedOutput: "42",
		},
		{
			Name:           "int",
			Code:           `say int(3.7);`,
			ExpectedOutput: "3",
		},
		{
			Name:           "sqrt",
			Code:           `say sqrt(16);`,
			ExpectedOutput: "4",
		},
		{
			Name:           "sin",
			Code:           `say int(sin(0) * 100);`,
			ExpectedOutput: "0",
		},
		{
			Name:           "cos",
			Code:           `say int(cos(0) * 100);`,
			ExpectedOutput: "100",
		},
		{
			Name:           "log",
			Code:           `say int(log(2.718281828) * 100);`,
			ExpectedOutput: "100",
		},
		{
			Name:           "exp",
			Code:           `say int(exp(1) * 100);`,
			ExpectedOutput: "271",
		},
		{
			Name:           "rand",
			Code:           `my $r = rand(); say $r >= 0 && $r < 1 ? "ok" : "fail";`,
			ExpectedOutput: "ok",
		},
		{
			Name:           "defined",
			Code:           `my $x = 1; my $y; say defined($x) ? "yes" : "no"; say defined($y) ? "yes" : "no";`,
			ExpectedOutput: "yes\nno",
		},
		{
			Name:           "wantarray in scalar",
			Code:           `sub test { wantarray() ? "list" : "scalar" } my $x = test(); say $x;`,
			ExpectedOutput: "scalar",
		},
		{
			Name:           "scalar on array",
			Code:           `my @arr = (1, 2, 3, 4, 5); say scalar(@arr);`,
			ExpectedOutput: "5",
		},
		{
			Name:           "chr and ord",
			Code:           `say chr(65); say ord("A");`,
			ExpectedOutput: "A\n65",
		},
		{
			Name:           "hex",
			Code:           `say hex("ff");`,
			ExpectedOutput: "255",
		},
		{
			Name:           "oct",
			Code:           `say oct("77");`,
			ExpectedOutput: "63",
		},
		{
			Name:           "pack and unpack",
			Code:           `my $packed = pack("A3", "ABC"); say $packed;`,
			ExpectedOutput: "ABC",
		},
		{
			Name:           "lc and uc",
			Code:           `say lc("HELLO"); say uc("world");`,
			ExpectedOutput: "hello\nWORLD",
		},
		{
			Name:           "grep",
			Code:           `my @nums = (1, 2, 3, 4, 5); my @even = grep { $_ % 2 == 0 } @nums; say "@even";`,
			ExpectedOutput: "2 4",
		},
		{
			Name:           "map",
			Code:           `my @nums = (1, 2, 3); my @doubled = map { $_ * 2 } @nums; say "@doubled";`,
			ExpectedOutput: "2 4 6",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Edge Cases and Special Features
// ============================================================

func TestEdgeCases(t *testing.T) {
	tests := []TestCase{
		{
			Name:           "empty string is false",
			Code:           `say "" ? "true" : "false";`,
			ExpectedOutput: "false",
		},
		{
			Name:           "zero string is false",
			Code:           `say "0" ? "true" : "false";`,
			ExpectedOutput: "false",
		},
		{
			Name:           "zero is false",
			Code:           `say 0 ? "true" : "false";`,
			ExpectedOutput: "false",
		},
		{
			Name:           "undef is false",
			Code:           `my $x; say $x ? "true" : "false";`,
			ExpectedOutput: "false",
		},
		{
			Name:           "empty array is false",
			Code:           `my @arr; say @arr ? "true" : "false";`,
			ExpectedOutput: "false",
		},
		{
			Name:           "non-empty array is true",
			Code:           `my @arr = (1); say @arr ? "true" : "false";`,
			ExpectedOutput: "true",
		},
		{
			Name:           "heredoc",
			Code: `my $text = <<END;
Hello
World
END
chomp($text);
say $text;`,
			ExpectedOutput: "Hello\nWorld",
		},
		{
			Name:           "qw operator",
			Code:           `my @arr = qw(one two three); say "@arr";`,
			ExpectedOutput: "one two three",
		},
		{
			Name:           "q and qq",
			Code:           `my $x = 5; say q(no $x); say qq(yes $x);`,
			ExpectedOutput: "no $x\nyes 5",
		},
		{
			Name:           "string numeric context",
			Code:           `my $s = "42abc"; say $s + 8;`,
			ExpectedOutput: "50",
		},
		{
			Name:           "autovivification array",
			Code:           `my @arr; $arr[5] = "x"; say scalar(@arr);`,
			ExpectedOutput: "6",
		},
		{
			Name:           "autovivification hash",
			Code:           `my %h; $h{a}{b} = 1; say $h{a}{b};`,
			ExpectedOutput: "1",
		},
		{
			Name:           "chained comparison",
			Code:           `my $x = 5; say 1 < $x && $x < 10 ? "in range" : "out";`,
			ExpectedOutput: "in range",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Comprehensive Integration Tests
// ============================================================

func TestIntegration(t *testing.T) {
	tests := []TestCase{
		{
			Name: "FizzBuzz",
			Code: `foreach my $i (1..15) {
    if ($i % 15 == 0) {
        say "FizzBuzz";
    } elsif ($i % 3 == 0) {
        say "Fizz";
    } elsif ($i % 5 == 0) {
        say "Buzz";
    } else {
        say $i;
    }
}`,
			ExpectedOutput: "1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzBuzz",
		},
		{
			Name: "Fibonacci",
			Code: `sub fib {
    my ($n) = @_;
    return $n if $n < 2;
    return fib($n-1) + fib($n-2);
}
my @results;
foreach my $i (0..9) {
    push(@results, fib($i));
}
say "@results";`,
			ExpectedOutput: "0 1 1 2 3 5 8 13 21 34",
		},
		{
			Name: "Word frequency counter",
			Code: `my $text = "the quick brown fox jumps over the lazy dog the fox";
my @words = split(/\s+/, $text);
my %freq;
foreach my $word (@words) {
    $freq{$word}++;
}
my @sorted = sort { $freq{$b} <=> $freq{$a} } keys %freq;
foreach my $w (@sorted[0..2]) {
    say "$w: $freq{$w}";
}`,
			ExpectedOutput: "the: 3\nfox: 2\nquick: 1",
		},
		{
			Name: "Prime sieve",
			Code: `my @sieve = (0) x 30;
for my $i (2..29) {
    next if $sieve[$i];
    for (my $j = $i * 2; $j < 30; $j += $i) {
        $sieve[$j] = 1;
    }
}
my @primes;
for my $i (2..29) {
    push(@primes, $i) unless $sieve[$i];
}
say "@primes";`,
			ExpectedOutput: "2 3 5 7 11 13 17 19 23 29",
		},
		{
			Name: "Data processing pipeline",
			Code: `my @data = (
    "Alice,30,Engineer",
    "Bob,25,Designer",
    "Charlie,35,Manager"
);

my @parsed;
foreach my $line (@data) {
    my @fields = split(",", $line);
    push(@parsed, { name => $fields[0], age => $fields[1], role => $fields[2] });
}

my @sorted = sort { $a->{age} <=> $b->{age} } @parsed;
foreach my $person (@sorted) {
    say "$person->{name} ($person->{age}): $person->{role}";
}`,
			ExpectedOutput: "Bob (25): Designer\nAlice (30): Engineer\nCharlie (35): Manager",
		},
	}

	for _, tc := range tests {
		t.Run(tc.Name, func(t *testing.T) {
			runTest(t, tc)
		})
	}
}

// ============================================================
// Main test runner
// ============================================================

func TestMain(m *testing.M) {
	// Change to project root
	os.Chdir("..")
	
	// Determine exe name based on OS
	exeName := "perlc"
	if os.PathSeparator == '\\' {
		exeName = "perlc.exe"
	}
	
	// Check if perlc exists
	if _, err := os.Stat("./" + exeName); os.IsNotExist(err) {
		// Try to build it
		fmt.Println("Building perlc...")
		cmd := exec.Command("go", "build", "-o", exeName, "./cmd/perlc")
		cmd.Stdout = os.Stdout
		cmd.Stderr = os.Stderr
		if err := cmd.Run(); err != nil {
			fmt.Fprintf(os.Stderr, "Failed to build perlc: %v\n", err)
			os.Exit(1)
		}
	}

	code := m.Run()
	
	// Cleanup
	os.Remove(exeName)
	
	os.Exit(code)
}
```

## File: ./tmp/json_xs_output.go
```go
/ /   A u t o - g e n e r a t e d   f r o m   X S  
 / /   M o d u l e :   J S O N : : X S ,   P a c k a g e :   J S O N : : X S  
  
 p a c k a g e   m a i n  
  
 i m p o r t   (  
 	 " f m t "  
 	 " s t r i n g s "  
 )  
  
 v a r   _   =   f m t . S p r i n t  
 v a r   _   =   s t r i n g s . C u t  
  
 f u n c   p e r l _ J S O N _ X S _ i n c r _ p a r s e ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 j s o n s t r   : =   a r g s [ 1 ]  
  
 	 {  
 	 i f   ( ! s e l f - > i n c r _ t e x t )  
 	 s e l f - > i n c r _ t e x t   =   n e w S V p v n   ( " " ,   0 )  
 	 i f   ( ! D E C O D E _ W A N T S _ O C T E T S   ( s e l f )   = =   ! S v U T F 8   ( s e l f - > i n c r _ t e x t ) )  
 	 i f   ( D E C O D E _ W A N T S _ O C T E T S   ( s e l f ) )  
 	 {  
 	 i f   ( s e l f - > i n c r _ p o s )  
 	 s e l f - > i n c r _ p o s   =   u t f 8 _ l e n g t h   ( ( U 8   * ) S v P V X   ( s e l f - > i n c r _ t e x t ) ,  
 	 ( U 8   * ) S v P V X   ( s e l f - > i n c r _ t e x t )   +   s e l f - > i n c r _ p o s )  
 	 s v _ u t f 8 _ d o w n g r a d e   ( s e l f - > i n c r _ t e x t ,   0 )  
 	 }  
 	 e l s e  
 	 {  
 	 s v _ u t f 8 _ u p g r a d e   ( s e l f - > i n c r _ t e x t )  
 	 i f   ( s e l f - > i n c r _ p o s )  
 	 s e l f - > i n c r _ p o s   =   u t f 8 _ h o p   ( ( U 8   * ) S v P V X   ( s e l f - > i n c r _ t e x t ) ,   s e l f - > i n c r _ p o s )  
 	 -   ( U 8   * ) S v P V X   ( s e l f - > i n c r _ t e x t )  
 	 }  
 	 / /   a p p e n d   d a t a ,   i f   a n y  
 	 i f   ( j s o n s t r )  
 	 {  
 	 i f   ( S v U T F 8   ( j s o n s t r )   ! =   S v U T F 8   ( s e l f - > i n c r _ t e x t ) )  
 	 i f   ( S v U T F 8   ( j s o n s t r ) )  
 	 s v _ u t f 8 _ d o w n g r a d e   ( j s o n s t r ,   0 )  
 	 e l s e  
 	 s v _ u t f 8 _ u p g r a d e   ( j s o n s t r )  
 	 {  
 	 S T R L E N   l e n  
 	 s t r   : =   j s o n s t r . A s S t r i n g ( )  
 	 S T R L E N   c u r   =   S v C U R   ( s e l f - > i n c r _ t e x t )  
 	 i f   ( S v L E N   ( s e l f - > i n c r _ t e x t )   -   c u r   < =   l e n )  
 	 j s o n _ s v _ g r o w   ( s e l f - > i n c r _ t e x t ,   c u r ,   l e n )  
 	 M o v e   ( s t r ,   S v E N D   ( s e l f - > i n c r _ t e x t ) ,   l e n ,   c h a r )  
 	 S v C U R _ s e t   ( s e l f - > i n c r _ t e x t ,   S v C U R   ( s e l f - > i n c r _ t e x t )   +   l e n )  
 	 * S v E N D   ( s e l f - > i n c r _ t e x t )   =   0 ;   / /   t h i s   s h o u l d   b a s i c a l l y   b e   a   n o p ,   t o o ,   b u t   m a k e   s u r e   i t ' s   t h e r e  
 	 }  
 	 }  
 	 i f   ( G I M M E _ V   ! =   G _ V O I D )  
 	 d o  
 	 {  
 	 S V   * s v  
 	 S T R L E N   o f f s e t  
 	 i f   ( ! I N C R _ D O N E   ( s e l f ) )  
 	 {  
 	 i n c r _ p a r s e   ( s e l f )  
 	 i f   ( s e l f - > i n c r _ p o s   >   s e l f - > m a x _ s i z e   & &   s e l f - > m a x _ s i z e )  
 	 c r o a k   ( " a t t e m p t e d   d e c o d e   o f   J S O N   t e x t   o f   % l u   b y t e s   s i z e ,   b u t   m a x _ s i z e   i s   s e t   t o   % l u " ,  
 	 ( u n s i g n e d   l o n g ) s e l f - > i n c r _ p o s ,   ( u n s i g n e d   l o n g ) s e l f - > m a x _ s i z e )  
 	 i f   ( ! I N C R _ D O N E   ( s e l f ) )  
 	 {  
 	 / /   a s   a n   o p t i m i s a t i o n ,   d o   n o t   a c c u m u l a t e   w h i t e   s p a c e   i n   t h e   i n c r   b u f f e r  
 	 i f   ( s e l f - > i n c r _ m o d e   = =   I N C R _ M _ W S   & &   s e l f - > i n c r _ p o s )  
 	 {  
 	 s e l f - > i n c r _ p o s   =   0  
 	 S v C U R _ s e t   ( s e l f - > i n c r _ t e x t ,   0 )  
 	 }  
 	 b r e a k  
 	 }  
 	 }  
 	 P U T B A C K ;   s v   =   d e c o d e _ j s o n   ( s e l f - > i n c r _ t e x t ,   s e l f ,   & o f f s e t ) ;   S P A G A I N  
 	 X P U S H s   ( s v )  
 	 s e l f - > i n c r _ p o s   - =   o f f s e t  
 	 s e l f - > i n c r _ n e s t   =   0  
 	 s e l f - > i n c r _ m o d e   =   0  
 	 s v _ c h o p   ( s e l f - > i n c r _ t e x t ,   S v P V X   ( s e l f - > i n c r _ t e x t )   +   o f f s e t )  
 	 }  
 	 w h i l e   ( G I M M E _ V   = =   G _ A R R A Y )  
 	 }  
 	 S V   * i n c r _ t e x t   ( J S O N   * s e l f )  
 	 C O D E :  
 	 {  
 	 i f   ( s e l f - > i n c r _ p o s )  
 	 c r o a k   ( " i n c r _ t e x t   c a n   n o t   b e   c a l l e d   w h e n   t h e   i n c r e m e n t a l   p a r s e r   a l r e a d y   s t a r t e d   p a r s i n g " )  
 	 R E T V A L   =   s v I n t ( i n t 6 4 ( s e l f - > i n c r _ t e x t   ?   S v R E F C N T _ i n c   ( s e l f - > i n c r _ t e x t )   :   & P L _ s v _ u n d e f ) )  
 	 }  
 	 O U T P U T :  
 	 R E T V A L  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ e n c o d e _ j s o n ( a r g s   . . . * S V )   * S V   {  
 	 s c a l a r   : =   a r g s [ 0 ]  
  
 	 {  
 	 J S O N   j s o n  
 	 j s o n _ i n i t   ( & j s o n )  
 	 j s o n . f l a g s   | =   F _ U T F 8  
 	 P U T B A C K ;   s c a l a r   =   e n c o d e _ j s o n   ( s c a l a r ,   & j s o n ) ;   S P A G A I N  
 	 X P U S H s   ( s c a l a r )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ d e c o d e _ j s o n ( a r g s   . . . * S V )   * S V   {  
 	 j s o n s t r   : =   a r g s [ 0 ]  
  
 	 {  
 	 J S O N   j s o n  
 	 j s o n _ i n i t   ( & j s o n )  
 	 j s o n . f l a g s   | =   F _ U T F 8  
 	 P U T B A C K ;   j s o n s t r   =   d e c o d e _ j s o n   ( j s o n s t r ,   & j s o n ,   0 ) ;   S P A G A I N  
 	 X P U S H s   ( j s o n s t r )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ m a x _ d e p t h ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 m a x _ d e p t h   : =   a r g s [ 1 ]  
  
 	 s e l f - > m a x _ d e p t h   =   m a x _ d e p t h  
 	 X P U S H s   ( S T   ( 0 ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ g e t _ m a x _ d e p t h ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 v a r   R E T V A L   * S V  
  
 	 R E T V A L   =   s v I n t ( i n t 6 4 ( s e l f - > m a x _ d e p t h ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ g e t _ m a x _ s i z e ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 v a r   R E T V A L   * S V  
  
 	 R E T V A L   =   s v I n t ( i n t 6 4 ( s e l f - > m a x _ s i z e ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ i n c r _ s k i p ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 {  
 	 i f   ( s e l f - > i n c r _ p o s )  
 	 {  
 	 s v _ c h o p   ( s e l f - > i n c r _ t e x t ,   S v P V _ n o l e n   ( s e l f - > i n c r _ t e x t )   +   s e l f - > i n c r _ p o s )  
 	 s e l f - > i n c r _ p o s     =   0  
 	 s e l f - > i n c r _ n e s t   =   0  
 	 s e l f - > i n c r _ m o d e   =   0  
 	 }  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ i n c r _ r e s e t ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 {  
 	 S v R E F C N T _ d e c   ( s e l f - > i n c r _ t e x t )  
 	 s e l f - > i n c r _ t e x t   =   0  
 	 s e l f - > i n c r _ p o s     =   0  
 	 s e l f - > i n c r _ n e s t   =   0  
 	 s e l f - > i n c r _ m o d e   =   0  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ b o o l e a n _ v a l u e s ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 v _ f a l s e   : =   a r g s [ 1 ]  
 	 v _ t r u e   : =   a r g s [ 2 ]  
  
 	 s e l f - > v _ f a l s e   =   n e w S V s v   ( v _ f a l s e )  
 	 s e l f - > v _ t r u e     =   n e w S V s v   ( v _ t r u e )  
 	 X P U S H s   ( S T   ( 0 ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ g e t _ b o o l e a n _ v a l u e s ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 i f   ( s e l f - > v _ f a l s e   & &   s e l f - > v _ t r u e )  
 	 {  
 	 E X T E N D   ( S P ,   2 )  
 	 P U S H s   ( s e l f - > v _ f a l s e )  
 	 P U S H s   ( s e l f - > v _ t r u e )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ g e t _ a s c i i ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
  
 	 X P U S H s   ( b o o l S V   ( s e l f - > f l a g s   &   i x ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ a s c i i ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 e n a b l e   : =   a r g s [ 1 ] . A s I n t ( )  
  
 	 {  
 	 i f   ( e n a b l e )  
 	 s e l f - > f l a g s   | =     i x  
 	 e l s e  
 	 s e l f - > f l a g s   & =   ~ i x  
 	 X P U S H s   ( S T   ( 0 ) )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ f i l t e r _ j s o n _ o b j e c t ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 c b   : =   a r g s [ 1 ]  
  
 	 {  
 	 S v R E F C N T _ d e c   ( s e l f - > c b _ o b j e c t )  
 	 s e l f - > c b _ o b j e c t   =   S v O K   ( c b )   ?   n e w S V s v   ( c b )   :   0  
 	 X P U S H s   ( S T   ( 0 ) )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ d e c o d e ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 j s o n s t r   : =   a r g s [ 1 ]  
  
 	 P U T B A C K ;   j s o n s t r   =   d e c o d e _ j s o n   ( j s o n s t r ,   s e l f ,   0 ) ;   S P A G A I N  
 	 X P U S H s   ( j s o n s t r )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ e n c o d e ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 s c a l a r   : =   a r g s [ 1 ]  
  
 	 P U T B A C K ;   s c a l a r   =   e n c o d e _ j s o n   ( s c a l a r ,   s e l f ) ;   S P A G A I N  
 	 X P U S H s   ( s c a l a r )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ d e c o d e _ p r e f i x ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 j s o n s t r   : =   a r g s [ 1 ]  
  
 	 {  
 	 S V   * s v  
 	 S T R L E N   o f f s e t  
 	 P U T B A C K ;   s v   =   d e c o d e _ j s o n   ( j s o n s t r ,   s e l f ,   & o f f s e t ) ;   S P A G A I N  
 	 E X T E N D   ( S P ,   2 )  
 	 P U S H s   ( s v )  
 	 P U S H s   ( s v _ 2 m o r t a l   ( n e w S V u v   ( p t r _ t o _ i n d e x   ( j s o n s t r ,   S v P V _ n o l e n   ( j s o n s t r )   +   o f f s e t ) ) ) )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ n e w ( a r g s   . . . * S V )   * S V   {  
 	 k l a s s   : =   a r g s [ 0 ] . A s S t r i n g ( )  
  
 	 {  
 	 S V   * p v   =   N E W S V   ( 0 ,   s i z e o f   ( J S O N ) )  
 	 S v P O K _ o n l y   ( p v )  
 	 j s o n _ i n i t   ( ( J S O N   * ) S v P V X   ( p v ) )  
 	 X P U S H s   ( s v _ 2 m o r t a l   ( s v _ b l e s s   (  
 	 n e w R V _ n o i n c   ( p v ) ,  
 	 s t r E Q   ( k l a s s ,   " J S O N : : X S " )   ?   J S O N _ S T A S H   :   g v _ s t a s h p v   ( k l a s s ,   1 )  
 	 ) ) )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ m a x _ s i z e ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 m a x _ s i z e   : =   a r g s [ 1 ]  
  
 	 s e l f - > m a x _ s i z e   =   m a x _ s i z e  
 	 X P U S H s   ( S T   ( 0 ) )  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   p e r l _ J S O N _ X S _ f i l t e r _ j s o n _ s i n g l e _ k e y _ o b j e c t ( a r g s   . . . * S V )   * S V   {  
 	 s e l f   : =   a r g s [ 0 ]  
 	 k e y   : =   a r g s [ 1 ]  
 	 c b   : =   a r g s [ 2 ]  
  
 	 {  
 	 i f   ( ! s e l f - > c b _ s k _ o b j e c t )  
 	 s e l f - > c b _ s k _ o b j e c t   =   n e w H V   ( )  
 	 i f   ( S v O K   ( c b ) )  
 	 h v _ s t o r e _ e n t   ( s e l f - > c b _ s k _ o b j e c t ,   k e y ,   n e w S V s v   ( c b ) ,   0 )  
 	 e l s e  
 	 {  
 	 h v _ d e l e t e _ e n t   ( s e l f - > c b _ s k _ o b j e c t ,   k e y ,   G _ D I S C A R D ,   0 )  
 	 i f   ( ! H v K E Y S   ( s e l f - > c b _ s k _ o b j e c t ) )  
 	 {  
 	 S v R E F C N T _ d e c   ( s e l f - > c b _ s k _ o b j e c t )  
 	 s e l f - > c b _ s k _ o b j e c t   =   0  
 	 }  
 	 }  
 	 X P U S H s   ( S T   ( 0 ) )  
 	 }  
  
 	 r e t u r n   R E T V A L  
 }  
  
 f u n c   i n i t ( )   {  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : b o o l e a n _ v a l u e s " ,   p e r l _ J S O N _ X S _ b o o l e a n _ v a l u e s )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : g e t _ b o o l e a n _ v a l u e s " ,   p e r l _ J S O N _ X S _ g e t _ b o o l e a n _ v a l u e s )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : g e t _ a s c i i " ,   p e r l _ J S O N _ X S _ g e t _ a s c i i )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : m a x _ d e p t h " ,   p e r l _ J S O N _ X S _ m a x _ d e p t h )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : g e t _ m a x _ d e p t h " ,   p e r l _ J S O N _ X S _ g e t _ m a x _ d e p t h )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : g e t _ m a x _ s i z e " ,   p e r l _ J S O N _ X S _ g e t _ m a x _ s i z e )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : i n c r _ s k i p " ,   p e r l _ J S O N _ X S _ i n c r _ s k i p )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : i n c r _ r e s e t " ,   p e r l _ J S O N _ X S _ i n c r _ r e s e t )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : a s c i i " ,   p e r l _ J S O N _ X S _ a s c i i )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : f i l t e r _ j s o n _ o b j e c t " ,   p e r l _ J S O N _ X S _ f i l t e r _ j s o n _ o b j e c t )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : d e c o d e " ,   p e r l _ J S O N _ X S _ d e c o d e )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : n e w " ,   p e r l _ J S O N _ X S _ n e w )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : m a x _ s i z e " ,   p e r l _ J S O N _ X S _ m a x _ s i z e )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : f i l t e r _ j s o n _ s i n g l e _ k e y _ o b j e c t " ,   p e r l _ J S O N _ X S _ f i l t e r _ j s o n _ s i n g l e _ k e y _ o b j e c t )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : e n c o d e " ,   p e r l _ J S O N _ X S _ e n c o d e )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : d e c o d e _ p r e f i x " ,   p e r l _ J S O N _ X S _ d e c o d e _ p r e f i x )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : i n c r _ p a r s e " ,   p e r l _ J S O N _ X S _ i n c r _ p a r s e )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : e n c o d e _ j s o n " ,   p e r l _ J S O N _ X S _ e n c o d e _ j s o n )  
 	 p e r l _ r e g i s t e r _ s u b ( " J S O N : : X S : : d e c o d e _ j s o n " ,   p e r l _ J S O N _ X S _ d e c o d e _ j s o n )  
 }  
  
 ```

## File: ./test_pl/test_at.pl
```perl
my $s = "test@example";
if ($s =~ /test@example/) {
    say "PASS";
} else {
    say "FAIL";
}
```

## File: ./test_pl/test_at2.pl
```perl
my $s = "test@example";
if ($s =~ /test\@example/) {
    say "PASS";
} else {
    say "FAIL";
}
```

## File: ./test_pl/test_at3.pl
```perl
my $s = "a@b";
say $s;
```

## File: ./test_pl/test_at4.pl
```perl
my $s = 'a@b';
say $s;
```

## File: ./test_pl/test_at5.pl
```perl
my $s = 'test@example';
if ($s =~ /test@example/) {
    say "PASS";
} else {
    say "FAIL";
}
```

## File: ./test_pl/test_cap.pl
```perl
my $str = "Name: Alice";
if ($str =~ /Name: (\w+)/) {
    say "matched";
    say $1;
    if ($1 eq "Alice") {
        say "PASS";
    } else {
        say "FAIL: got [$1]";
    }
}
```

## File: ./test_pl/test_cap2.pl
```perl
my $str = "Name: Alice";
if ($str =~ /Name: (\w+)/) {
    my $cap = $1;
    say "cap: [$cap]";
    say "len: " . length($cap);
    say "Alice len: " . length("Alice");
    if ($cap eq "Alice") {
        say "PASS";
    } else {
        say "FAIL";
    }
}```

## File: ./test_pl/test_cap3.pl
```perl
my $str = "Name: Alice";
$str =~ /Name: (\w+)/;
say "after match: $1";
say $1;
```

## File: ./test_pl/test_debug.pl
```perl
my $s = "abc";
if ($s =~ /abc/) {
    say "PASS: simple";
} else {
    say "FAIL: simple";
}
my $s2 = "a@b";
if ($s2 =~ /a@b/) {
    say "PASS: with @";
} else {
    say "FAIL: with @";
}```

## File: ./test_pl/test_deref.pl
```perl
my $val = 42;
my $ref = \$val;
my $x = $$ref;
say $x;
```

## File: ./test_pl/test_deref2.pl
```perl
my $val = 42;
my $ref = \$val;
say $$ref;
$$ref = 100;
say $val;
```

## File: ./test_pl/test_dot.pl
```perl
my $s = "a.b";
if ($s =~ /a\.b/) {
    say "PASS: escaped dot";
} else {
    say "FAIL: escaped dot";
}
if ($s =~ /a.b/) {
    say "PASS: any char";
} else {
    say "FAIL: any char";
}```

## File: ./test_pl/test_email.pl
```perl
my $email = "test@example.com";
if ($email =~ /\w+@\w+\.\w+/) {
    say "PASS";
} else {
    say "FAIL";
}
```

## File: ./test_pl/test_lex.pl
```perl
/a@b/
```

## File: ./test_pl/test_modifier.pl
```perl
my $x = 10;
say "PASS: if modifier" if $x > 5;
say "FAIL: should not print" if $x > 100;
say "PASS: unless modifier" unless $x > 100;
say "Done!";
```

## File: ./test_pl/test_ref.pl
```perl
my $val = 42;
my $ref = \$val;
say "ref created";

my @arr = (10, 20, 30);
my $ref = \@arr;
print $ref->[1];
print "\n";
```

## File: ./test_pl/test_refs.pl
```perl
my @arr = (10, 20, 30);
my $arr_ref = \@arr;
say $arr_ref->[1];

my %h = ("x" => 5, "y" => 10);
my $h_ref = \%h;
say $h_ref->{x};
```

## File: ./test_pl/test_regex_esc.pl
```perl
my $s = 'test@example';
if ($s =~ /test\@example/) {
    say "PASS";
} else {
    say "FAIL";
}
```

## File: ./test_pl/test_sort.pl
```perl
my @arr = (3, 1, 2);
my @sorted = sort(@arr);
say $sorted[0];
say $sorted[1];
say $sorted[2];
```

## File: ./test_pl/test_tokens.pl
```perl
$$ref
```

## File: ./test_pl/test_var1.pl
```perl
my $x = "test";
say $x;
say $1;
```

## File: ./tests/quick/01_control.pl
```perl
# Test basic control flow

say "Testing control flow...";

my $x = 10;

if ($x > 5) {
    say "PASS: if true";
} else {
    say "FAIL: if should be true";
}

if ($x > 20) {
    say "FAIL: should not run";
} else {
    say "PASS: else branch";
}

# While loop
my $i = 0;
my $sum = 0;
while ($i < 5) {
    $sum = $sum + $i;
    $i = $i + 1;
}

if ($sum == 10) {
    say "PASS: while loop";
} else {
    say "FAIL: while loop got $sum";
}

# Foreach
my @arr = (1, 2, 3);
$sum = 0;
foreach my $n (@arr) {
    $sum = $sum + $n;
}

if ($sum == 6) {
    say "PASS: foreach";
} else {
    say "FAIL: foreach got $sum";
}

# Ternary
my $result = $x > 5 ? "big" : "small";
if ($result eq "big") {
    say "PASS: ternary";
} else {
    say "FAIL: ternary";
}

say "Done!";
```

## File: ./tests/quick/02_arrays.pl
```perl
# Test arrays

say "Testing arrays...";

my @arr = (1, 2, 3, 4, 5);

if ($arr[0] == 1) {
    say "PASS: array access";
} else {
    say "FAIL: array access";
}

if (scalar(@arr) == 5) {
    say "PASS: array length";
} else {
    say "FAIL: array length";
}

push(@arr, 6);
if (scalar(@arr) == 6) {
    say "PASS: push";
} else {
    say "FAIL: push";
}

my $p = pop(@arr);
if ($p == 6) {
    say "PASS: pop";
} else {
    say "FAIL: pop";
}

my $joined = join("-", @arr);
if ($joined eq "1-2-3-4-5") {
    say "PASS: join";
} else {
    say "FAIL: join got $joined";
}

say "Done!";
```

## File: ./tests/quick/03_hashes.pl
```perl
# Test hashes

say "Testing hashes...";

my %h = (a => 1, b => 2, c => 3);

if ($h{a} == 1) {
    say "PASS: hash access";
} else {
    say "FAIL: hash access";
}

$h{d} = 4;
if ($h{d} == 4) {
    say "PASS: hash assign";
} else {
    say "FAIL: hash assign";
}

my @k = keys(%h);
if (scalar(@k) == 4) {
    say "PASS: keys";
} else {
    say "FAIL: keys";
}

say "Done!";
```

## File: ./tests/quick/04_fileio.pl
```perl
# Test file I/O

say "Testing file I/O...";

my $fh;
open($fh, ">", "test_file.txt");
print $fh "Hello\n";
print $fh "World\n";
close($fh);

say "PASS: file written";

open($fh, "<", "test_file.txt");
my $line1 = <$fh>;
my $line2 = <$fh>;
close($fh);

# Remove newlines with regex
$line1 =~ s/\n$//;
$line2 =~ s/\n$//;

if ($line1 eq "Hello") {
    say "PASS: read line 1";
} else {
    say "FAIL: line1 = $line1";
}

if ($line2 eq "World") {
    say "PASS: read line 2";
} else {
    say "FAIL: line2 = $line2";
}

say "Done!";
```

## File: ./tests/quick/05_regex.pl
```perl
		   
# Test regex

say "Testing regex...";

my $s = "Hello World";

if ($s =~ /World/) {
    say "PASS: match";
} else {
    say "FAIL: match";
}

if ($s !~ /Perl/) {
    say "PASS: no match";
} else {
    say "FAIL: no match";
}

$s =~ s/World/Perl/;
if ($s eq "Hello Perl") {
    say "PASS: substitution";
} else {
    say "FAIL: subst got $s";
}

my $t = "aaa";
$t =~ s/a/b/g;
if ($t eq "bbb") {
    say "PASS: global subst";
} else {
    say "FAIL: global subst got $t";
}

# Complex pattern - email
my $email = 'test@example.com';
if ($email =~ /\w+\@\w+\.\w+/) {
    say "PASS: complex pattern";
} else {
    say "FAIL: complex pattern";
}

# Case insensitive
my $text = "HELLO";
if ($text =~ /hello/i) {
    say "PASS: case insensitive";
} else {
    say "FAIL: case insensitive";
}

# Capture group
my $str = "Name: Alice";
if ($str =~ /Name: (\w+)/) {
    if ($1 eq "Alice") {
        say "PASS: capture group";
    } else {
        say "FAIL: capture wrong: $1";
    }
} else {
    say "FAIL: capture match";
}

# Substitution with capture
$str = "Hello World";
$str =~ s/(\w+) (\w+)/$2 $1/;
if ($str eq "World Hello") {
    say "PASS: subst with capture";
} else {
    say "FAIL: subst capture: $str";
}


say "Done!";
# === Nested data structures ===
```

## File: ./tests/quick/06_subs.pl
```perl
# Test subroutines

say "Testing subroutines...";

sub add {
    my ($a, $b) = @_;
    return $a + $b;
}

if (add(2, 3) == 5) {
    say "PASS: sub with args";
} else {
    say "FAIL: sub with args";
}

sub calc {
    my ($a, $b) = @_;
    return $a + $b * 2;
}

if (calc(10, 3) == 16) {
    say "PASS: expression in sub";
} else {
    say "FAIL: expression in sub";
}

sub factorial {
    my ($n) = @_;
    if ($n <= 1) {
        return 1;
    }
    return $n * factorial($n - 1);
}

if (factorial(5) == 120) {
    say "PASS: recursive";
} else {
    say "FAIL: recursive";
}

say "Done!";
```

## File: ./tests/quick/07_refs.pl
```perl
# Test references (anonymous only)

say "Testing references...";

my $arr = [1, 2, 3];

if ($arr->[0] == 1) {
    say "PASS: array ref access";
} else {
    say "FAIL: array ref";
}

my $h = {a => 10, b => 20};

if ($h->{a} == 10) {
    say "PASS: hash ref access";
} else {
    say "FAIL: hash ref";
}

if (ref($arr) eq "ARRAY") {
    say "PASS: ref type ARRAY";
} else {
    say "FAIL: ref type";
}

if (ref($h) eq "HASH") {
    say "PASS: ref type HASH";
} else {
    say "FAIL: ref type";
}

say "Done!";
```

## File: ./tests/quick/08_expressions.pl
```perl
# Test expressions in print/say

say "Testing expressions...";

my $x = 5;
my $y = 3;

if ($x + $y == 8) {
    say "PASS: addition";
} else {
    say "FAIL: addition";
}

if ($x * $y == 15) {
    say "PASS: multiplication";
} else {
    say "FAIL: multiplication";
}

if ($x - $y == 2) {
    say "PASS: subtraction";
} else {
    say "FAIL: subtraction";
}

my $z = $x + $y * 2;
if ($z == 11) {
    say "PASS: precedence";
} else {
    say "FAIL: precedence";
}

sub show_sum {
    my ($a, $b) = @_;
    say $a + $b;
    return $a + $b;
}

if (show_sum(10, 20) == 30) {
    say "PASS: say expr in sub";
} else {
    say "FAIL: say expr in sub";
}

say "Done!";
```

## File: ./tests/quick/09_push.pl
```perl
my @arr = (1, 2, 3);
say "Before push";
push(@arr, 4);
say "After push";```

## File: ./tests/quick/10_oop.pl
```perl
# OOP tests
say "Testing OOP...";

# Test 1: Basic bless
my $obj = {};
bless($obj, "MyClass");
my $type = ref($obj);
if ($type eq "MyClass") {
    say "PASS: basic bless";
} else {
    say "FAIL: basic bless - got $type";
}

# Test 2: Constructor pattern
sub Point::new {
    my $class = shift;
    my $x = shift;
    my $y = shift;
    my $self = {};
    $self->{"x"} = $x;
    $self->{"y"} = $y;
    bless($self, $class);
    return $self;
}

sub Point::get_x {
    my $self = shift;
    return $self->{"x"};
}

sub Point::get_y {
    my $self = shift;
    return $self->{"y"};
}

my $p = Point->new(10, 20);
my $ptype = ref($p);
if ($ptype eq "Point") {
    say "PASS: constructor";
} else {
    say "FAIL: constructor - got $ptype";
}

# Test 3: Method calls
my $px = $p->get_x();
if ($px == 10) {
    say "PASS: method get_x";
} else {
    say "FAIL: method get_x - got $px";
}

my $py = $p->get_y();
if ($py == 20) {
    say "PASS: method get_y";
} else {
    say "FAIL: method get_y - got $py";
}

# Test 4: Inheritance
sub Shape::area {
    return 0;
}

set_isa("Rectangle", "Shape");

sub Rectangle::new {
    my $class = shift;
    my $w = shift;
    my $h = shift;
    my $self = {};
    $self->{"width"} = $w;
    $self->{"height"} = $h;
    bless($self, $class);
    return $self;
}

sub Rectangle::area {
    my $self = shift;
    return $self->{"width"} * $self->{"height"};
}

my $rect = Rectangle->new(5, 4);
my $area = $rect->area();
if ($area == 20) {
    say "PASS: inheritance area";
} else {
    say "FAIL: inheritance area - got $area";
}

say "Done!";```

## File: ./tests/quick/11_advanced.pl
```perl
# Advanced tests - features not in basic tests
say "Testing advanced features...";

# === Until loop ===
say "=== Until loop ===";
my $i = 0;
until ($i >= 3) {
    $i = $i + 1;
}
if ($i == 3) {
    say "PASS: until loop";
} else {
    say "FAIL: until loop - got $i";
}

# === Elsif ===
say "=== Elsif ===";
my $x = 15;
if ($x > 20) {
    say "FAIL: elsif";
} elsif ($x > 10) {
    say "PASS: elsif branch";
} else {
    say "FAIL: elsif";
}

# === Unless ===
say "=== Unless ===";
unless ($x > 100) {
    say "PASS: unless";
}

# === Statement modifiers ===
say "=== Statement modifiers ===";
say "PASS: if modifier" if $x > 10;
say "PASS: unless modifier" unless $x > 100;

# === For C-style loop ===
say "=== For C-style ===";
my $sum = 0;
for (my $j = 0; $j < 5; $j++) {
    $sum = $sum + $j;
}
if ($sum == 10) {
    say "PASS: for C-style";
} else {
    say "FAIL: for C-style - got $sum";
}

# === Foreach with range ===
say "=== Foreach range ===";
$sum = 0;
foreach my $n (1..5) {
    $sum = $sum + $n;
}
if ($sum == 15) {
    say "PASS: foreach range";
} else {
    say "FAIL: foreach range - got $sum";
}

# === Loop control: last ===
say "=== Last ===";
$sum = 0;
foreach my $n (1..10) {
    if ($n > 5) {
        last;
    }
    $sum = $sum + $n;
}
if ($sum == 15) {
    say "PASS: last";
} else {
    say "FAIL: last - got $sum";
}

# === Loop control: next ===
say "=== Next ===";
$sum = 0;
foreach my $n (1..10) {
    if ($n % 2 == 0) {
        next;
    }
    $sum = $sum + $n;
}
if ($sum == 25) {
    say "PASS: next";
} else {
    say "FAIL: next - got $sum";
}

# === Logical and returns value ===
say "=== Logical operators ===";
my $result = 1 && 2;
if ($result == 2) {
    say "PASS: logical and value";
} else {
    say "FAIL: logical and value - got $result";
}

# === Logical or returns value ===
$result = 0 || 42;
if ($result == 42) {
    say "PASS: logical or value";
} else {
    say "FAIL: logical or value - got $result";
}

# === Defined-or ===
say "=== Defined-or ===";
my $undef;
$result = $undef // "default";
if ($result eq "default") {
    say "PASS: defined-or";
} else {
    say "FAIL: defined-or";
}

# === Shift/unshift ===
say "=== Shift/unshift ===";
my @arr = (1, 2, 3);
unshift(@arr, 0);
my $shifted = shift(@arr);
if ($shifted == 0 && scalar(@arr) == 3) {
    say "PASS: shift/unshift";
} else {
    say "FAIL: shift/unshift";
}

# === Negative array index ===
say "=== Negative index ===";
my @arr = (1, 2, 3, 4, 5);
if ($arr[-1] == 5 && $arr[-2] == 4) {
    say "PASS: negative index";
} else {
    say "FAIL: negative index";
}

# === Split ===
say "=== Split ===";
my @parts = split(",", "a,b,c");
if ($parts[0] eq "a" && $parts[1] eq "b" && $parts[2] eq "c") {
    say "PASS: split";
} else {
    say "FAIL: split";
}

# === Reverse ===
say "=== Reverse ===";
my @arr = (1, 2, 3);
my @rev = reverse(@arr);
if ($rev[0] == 3 && $rev[2] == 1) {
    say "PASS: reverse";
} else {
    say "FAIL: reverse";
}

# === Sort ===
say "=== Sort ===";
my @arr = (3, 1, 2);
my @sorted = sort(@arr);
if ($sorted[0] == 1 && $sorted[2] == 3) {
    say "PASS: sort";
} else {
    say "FAIL: sort";
}

# === Hash values ===
say "=== Hash values ===";
my %h = (a => 1, b => 2);
my @vals = values(%h);
if (scalar(@vals) == 2) {
    say "PASS: values";
} else {
    say "FAIL: values";
}

# === Exists ===
say "=== Exists ===";
if (exists $h{a}) {
    say "PASS: exists true";
} else {
    say "FAIL: exists true";
}
if (!exists $h{z}) {
    say "PASS: exists false";
} else {
    say "FAIL: exists false";
}

# === Delete ===
say "=== Delete ===";
$h{temp} = 99;
delete $h{temp};
if (!exists $h{temp}) {
    say "PASS: delete";
} else {
    say "FAIL: delete";
}

# === Scalar reference ===
say "=== Scalar refs ===";
my $val = 42;
my $ref = \$val;
if ($$ref == 42) {
    say "PASS: scalar ref deref";
} else {
    say "FAIL: scalar ref deref";
}

$$ref = 100;
if ($val == 100) {
    say "PASS: modify through scalar ref";
} else {
    say "FAIL: modify through scalar ref";
}

# === Array ref with backslash ===
say "=== Array ref backslash ===";
my @arr = (10, 20, 30);
my $arr_ref = \@arr;
if ($arr_ref->[1] == 20) {
    say "PASS: array ref backslash";
} else {
    say "FAIL: array ref backslash";
}

# === Hash ref with backslash ===
say "=== Hash ref backslash ===";
my %h = (x => 5, y => 10);
my $h_ref = \%h;
if ($h_ref->{x} == 5) {
    say "PASS: hash ref backslash";
} else {
    say "FAIL: hash ref backslash";
}

# === ref() for SCALAR ===
say "=== ref SCALAR ===";
if (ref(\$val) eq "SCALAR") {
    say "PASS: ref SCALAR";
} else {
    say "FAIL: ref SCALAR - got " . ref(\$val);
}

# === Nested data structures ===
say "=== Nested structures ===";
my $data = {
    name => "Test",
    nums => [1, 2, 3],
    info => { id => 42 }
};
if ($data->{name} eq "Test") {
    say "PASS: nested hash";
} else {
    say "FAIL: nested hash";
}
if ($data->{nums}[1] == 2) {
    say "PASS: array in hash";
} else {
    say "FAIL: array in hash";
}
if ($data->{info}{id} == 42) {
    say "PASS: hash in hash";
} else {
    say "FAIL: hash in hash";
}

# === Regex capture groups ===
say "=== Regex capture ===";
my $s = "Name: Alice";
if ($s =~ /Name: (\w+)/) {
    if ($1 eq "Alice") {
        say "PASS: capture group";
    } else {
        say "FAIL: capture group - got $1";
    }
} else {
    say "FAIL: capture match";
}

# === Case insensitive regex ===
say "=== Regex /i ===";
$s = "HELLO";
if ($s =~ /hello/i) {
    say "PASS: case insensitive";
} else {
    say "FAIL: case insensitive";
}

# === Capture in substitution ===
say "=== Subst capture ===";
$s = "Hello World";
$s =~ s/(\w+) (\w+)/$2 $1/;
if ($s eq "World Hello") {
    say "PASS: subst capture";
} else {
    say "FAIL: subst capture - got $s";
}

# === Chomp ===
say "=== Chomp ===";
$s = "test\n";
chomp($s);
if ($s eq "test") {
    say "PASS: chomp";
} else {
    say "FAIL: chomp";
}

# === Multiple return values ===
say "=== Multiple returns ===";
sub minmax {
    my @nums = @_;
    my $min = $nums[0];
    my $max = $nums[0];
    foreach my $n (@nums) {
        if ($n < $min) { $min = $n; }
        if ($n > $max) { $max = $n; }
    }
    return ($min, $max);
}
my ($min, $max) = minmax(5, 2, 8, 1, 9);
if ($min == 1 && $max == 9) {
    say "PASS: multiple return";
} else {
    say "FAIL: multiple return";
}

# === Increment/decrement ===
say "=== Inc/Dec ===";
my $n = 5;
$n++;
if ($n == 6) {
    say "PASS: post-increment";
} else {
    say "FAIL: post-increment";
}
$n--;
if ($n == 5) {
    say "PASS: post-decrement";
} else {
    say "FAIL: post-decrement";
}

# === Compound assignment ===
say "=== Compound assignment ===";
$n = 10;
$n += 5;
if ($n == 15) {
    say "PASS: +=";
} else {
    say "FAIL: +=";
}
$n -= 3;
if ($n == 12) {
    say "PASS: -=";
} else {
    say "FAIL: -=";
}
$n *= 2;
if ($n == 24) {
    say "PASS: *=";
} else {
    say "FAIL: *=";
}
my $str = "Hello";
$str .= " World";
if ($str eq "Hello World") {
    say "PASS: .=";
} else {
    say "FAIL: .=";
}


# === Defined ===
say "=== Defined ===";
my $undef_var;
if (!defined($undef_var)) {
    say "PASS: undef detected";
} else {
    say "FAIL: undef not detected";
}
$undef_var = 42;
if (defined($undef_var)) {
    say "PASS: defined detected";
} else {
    say "FAIL: defined not detected";
}


say "Done!";```

## File: ./tests/quick/12_mixed.pl
```perl
# tests/quick/12_mixed.pl
say "Testing mixed arrays...";

# Массив с разными типами
my @mix = (42, "hello", 3.14, [1, 2, 3], {name => "test"});

# Доступ к элементам разных типов
if ($mix[0] == 42) {
    say "PASS: int element";
} else {
    say "FAIL: int element";
}

if ($mix[1] eq "hello") {
    say "PASS: string element";
} else {
    say "FAIL: string element";
}

if ($mix[2] > 3.0) {
    say "PASS: float element";
} else {
    say "FAIL: float element";
}

# Вложенный массив
if ($mix[3][1] == 2) {
    say "PASS: nested array";
} else {
    say "FAIL: nested array";
}

# Вложенный хеш
if ($mix[4]{name} eq "test") {
    say "PASS: nested hash";
} else {
    say "FAIL: nested hash";
}

# Массив хешей (очень частый паттерн)
my @users = (
    {name => "Alice", age => 30},
    {name => "Bob", age => 25},
);

if ($users[0]{name} eq "Alice" && $users[1]{age} == 25) {
    say "PASS: array of hashes";
} else {
    say "FAIL: array of hashes";
}

# Хеш массивов
my %data = (
    numbers => [1, 2, 3],
    letters => ["a", "b", "c"],
);

if ($data{numbers}[0] == 1 && $data{letters}[2] eq "c") {
    say "PASS: hash of arrays";
} else {
    say "FAIL: hash of arrays";
}

say "Done!";```

## File: ./shell/create_snapshot.sh
```bash
#!/bin/bash
OUTPUT="snapshot/perlc_snapshot_$(date +%Y%m%d_%H%M%S).md"

echo "# Perl Compiler Snapshot - $(date)" > "$OUTPUT"
echo "" >> "$OUTPUT"

# Project structure
echo "## Project Structure" >> "$OUTPUT"
echo '```' >> "$OUTPUT"
find . -type f \( -name "*.go" -o -name "*.pl" -o -name "*.sh" \) | grep -v vendor | sort >> "$OUTPUT"
echo '```' >> "$OUTPUT"
echo "" >> "$OUTPUT"

# All Go files
for f in $(find . -name "*.go" | grep -v vendor | sort); do
    echo "## File: $f" >> "$OUTPUT"
    echo '```go' >> "$OUTPUT"
    cat "$f" >> "$OUTPUT"
    echo '```' >> "$OUTPUT"
    echo "" >> "$OUTPUT"
done

# Test files
for f in $(find . -name "*.pl" | sort); do
    echo "## File: $f" >> "$OUTPUT"
    echo '```perl' >> "$OUTPUT"
    cat "$f" >> "$OUTPUT"
    echo '```' >> "$OUTPUT"
    echo "" >> "$OUTPUT"
done

# Shell scripts
for f in $(find . -name "*.sh" | sort); do
    echo "## File: $f" >> "$OUTPUT"
    echo '```bash' >> "$OUTPUT"
    cat "$f" >> "$OUTPUT"
    echo '```' >> "$OUTPUT"
    echo "" >> "$OUTPUT"
done

echo "Snapshot created: $OUTPUT"
wc -l "$OUTPUT"```

## File: ./tests/quick_test.sh
```bash
#!/bin/bash

# Quick Test Runner for Perl Compiler
# Runs all .pl test files in tests/quick/
# Works on Linux, macOS, and Windows (MINGW/Git Bash)

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

cd "$PROJECT_ROOT"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

# Detect OS and set executable extension
EXE=""
if [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "win32" ]]; then
    EXE=".exe"
fi

# Build perlc
echo -e "${BLUE}Building perlc...${NC}"
go build -o "perlc${EXE}" ./cmd/perlc
if [ $? -ne 0 ]; then
    echo -e "${RED}Build failed!${NC}"
    exit 1
fi
echo -e "${GREEN}Build OK${NC}"
echo

# Test modes
MODE=${1:-both}  # interp, compile, or both

TOTAL=0
PASSED=0
FAILED=0

run_interp_test() {
    local file=$1
    local name=$(basename "$file" .pl)
    
    TOTAL=$((TOTAL + 1))
    
    echo -e "${CYAN}[$name] Interpreter...${NC}"
    output=$("./perlc${EXE}" "$file" 2>&1)
    
    if echo "$output" | grep -q "FAIL"; then
        echo -e "${RED}  FAILED${NC}"
        echo "$output" | grep "FAIL"
        FAILED=$((FAILED + 1))
        return 1
    elif echo "$output" | grep -qi "error"; then
        echo -e "${RED}  ERROR${NC}"
        echo "$output" | head -5
        FAILED=$((FAILED + 1))
        return 1
    else
        echo -e "${GREEN}  PASSED${NC}"
        PASSED=$((PASSED + 1))
        return 0
    fi
}

run_compile_test() {
    local file=$1
    local name=$(basename "$file" .pl)
    
    TOTAL=$((TOTAL + 1))
    
    echo -e "${CYAN}[$name] Compiled...${NC}"
    
    # Compile only first
    compile_out=$("./perlc${EXE}" -c -o "${name}_test" "$file" 2>&1)
    if [ $? -ne 0 ]; then
        echo -e "${RED}  COMPILE ERROR${NC}"
        echo "$compile_out" | head -10
        FAILED=$((FAILED + 1))
        return 1
    fi
    
    # Run the compiled exe
    if [ -f "${name}_test${EXE}" ]; then
        output=$("./${name}_test${EXE}" 2>&1)
    elif [ -f "${name}_test" ]; then
        output=$("./${name}_test" 2>&1)
    else
        echo -e "${RED}  EXE NOT FOUND${NC}"
        FAILED=$((FAILED + 1))
        return 1
    fi
    
    # Cleanup exe
    rm -f "${name}_test${EXE}" "${name}_test" 2>/dev/null
    
    if echo "$output" | grep -q "FAIL"; then
        echo -e "${RED}  FAILED${NC}"
        echo "$output" | grep "FAIL"
        FAILED=$((FAILED + 1))
        return 1
    else
        echo -e "${GREEN}  PASSED${NC}"
        PASSED=$((PASSED + 1))
        return 0
    fi
}

echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Quick Tests for Perl Compiler${NC}"
echo -e "${BLUE}======================================${NC}"
echo

# Find all test files
TEST_FILES=$(find tests/quick -name "*.pl" 2>/dev/null | sort)

if [ -z "$TEST_FILES" ]; then
    echo -e "${YELLOW}No test files found in tests/quick/${NC}"
    exit 0
fi

# Run tests
for file in $TEST_FILES; do
    echo -e "${YELLOW}--- Testing: $(basename $file) ---${NC}"
    
    if [ "$MODE" = "both" ] || [ "$MODE" = "interp" ]; then
        run_interp_test "$file"
    fi
    
    if [ "$MODE" = "both" ] || [ "$MODE" = "compile" ]; then
        run_compile_test "$file"
    fi
    
    echo
done

# Cleanup
rm -f "perlc${EXE}"
rm -f *.txt 2>/dev/null || true

# Summary
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Summary${NC}"
echo -e "${BLUE}======================================${NC}"
echo "Total:  $TOTAL"
echo -e "${GREEN}Passed: $PASSED${NC}"
echo -e "${RED}Failed: $FAILED${NC}"

if [ $FAILED -gt 0 ]; then
    echo -e "${RED}Some tests failed!${NC}"
    exit 1
else
    echo -e "${GREEN}All tests passed!${NC}"
fi
```

## File: ./tests/run_tests.sh
```bash
#!/bin/bash

# Perl Compiler Integration Test Runner
# Usage: ./run_tests.sh [options]
#
# Options:
#   -v          Verbose output
#   -f FILTER   Run only tests matching filter
#   -c          Run only compilation tests
#   -i          Run only interpreter tests
#   -q          Quick test (subset)

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"

cd "$PROJECT_ROOT"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Parse arguments
VERBOSE=""
FILTER=""
TEST_TYPE=""

while getopts "vf:ciq" opt; do
    case $opt in
        v) VERBOSE="-v" ;;
        f) FILTER="$OPTARG" ;;
        c) TEST_TYPE="compile" ;;
        i) TEST_TYPE="interpret" ;;
        q) FILTER="Basic" ;;
        *) echo "Unknown option: $opt" >&2; exit 1 ;;
    esac
done

echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Perl Compiler Integration Tests${NC}"
echo -e "${BLUE}======================================${NC}"
echo

# Build perlc first
echo -e "${YELLOW}Building perlc...${NC}"
go build -o perlc ./cmd/perlc
if [ $? -ne 0 ]; then
    echo -e "${RED}Build failed!${NC}"
    exit 1
fi
echo -e "${GREEN}Build successful${NC}"
echo

# Move to tests directory
cd tests

# Build test filter
TEST_ARGS=""
if [ -n "$FILTER" ]; then
    TEST_ARGS="-run $FILTER"
fi

# Run tests
echo -e "${YELLOW}Running tests...${NC}"
echo

if go test $VERBOSE $TEST_ARGS -count=1 .; then
    echo
    echo -e "${GREEN}======================================${NC}"
    echo -e "${GREEN}  All tests passed!${NC}"
    echo -e "${GREEN}======================================${NC}"
else
    echo
    echo -e "${RED}======================================${NC}"
    echo -e "${RED}  Some tests failed!${NC}"
    echo -e "${RED}======================================${NC}"
    exit 1
fi

# Cleanup
cd "$PROJECT_ROOT"
rm -f perlc perlc.exe

echo
echo -e "${BLUE}Done.${NC}"
```

